=======================================================================================
OZ80MANDIAS: a Z80 assembler; Copyright (C) Kroc Camen, 2013-14
Licenced under a Creative Commons 3.0 Attribution Licence
--You may use and modify this document how you see fit as long as you give credit
=======================================================================================

				TABLE OF CONTENTS
	
        i.              Terminology
        
        1.              Comments
	1.1.		. Register Hints
	
	2.		Numbers
        2.1.            | Decimal
        2.2.            | Negatives
        2.3.            | Fractions
        2.4.            | Hexadecimal
        2.5.            | Binary
	2.6.		| Units
	2.7.		. Limits
	
        3.              Expressions
        
	4.              Procedures
        4.1.            | Parameters
        4.2.            . Sub-Labels
        
        5.              Constants
        5.1.            . Enumerations
        
        5.              Variables
        
        6.              Objects:
        6.1.            . Bit Flags

=======================================================================================
i.      Terminology
=======================================================================================
:: "Value", "<value>"
        A number, or something that can be evaluated into a number, i.e. Constants,
        Labels, RAM Names and Properties. This does not include Text.
        
:: "Expression", "<expr>"
        A calculation. It can be a single Value, or a calculation involving Operators
        and multiple Values.
        
:: "List", "<list>"
        A series of Expressions one after the other,
        e.g. `1, 2, 3, 4, :label, CONSTANT, 7+8`
        
        Text is a list in of itself and can be included in other Lists,
        e.g. `1, 2, "three", 4, 5`

:: "Scope"
        The nesting-depth of statements within each other.
        For example, Z80 instructions go within a PROC block.
        Root is the top-most scope, not nested within anything else.

:: "Block"
        An encapsulation. `PROC`, `TABLE` & `STRUCT` are all types of blocks.

 
=======================================================================================
1.	Comments
=======================================================================================
Scopes: Any
Format:
	`single-line
        
	``multi-
	  line``

A single-line comment begins with a back-tick.
All text from that point to the end of the line is ignored.

	ld	de, 3			`sprite table is 3 bytes per sprite

A multi-line comment begins with double back-tick ("``") and continues until the next
double back-tick is encountered. All text in between is ignored.
	
	``in the solidity data, bit 7 determines that the tile should appear in
	  front of sprites. rotate the byte three times to position bit 7 at bit 4.
	  this byte will form the high-byte of the 16-bit value for the name table
	  entry (bit 4 will therefore become bit 12)``
	rrca
	rrca
	rrca

1.1.	Register Hints
---------------------------------------------------------------------------------------
Scopes: Any
Format:
	<register>;<hintName>		`or:
	<register>'<hintName>		`for indicating shadow registers in use

Register hints provide the ability to keep track of the temporary "role" of registers.
It allows you to explain 'what' a register currently is, without resorting to comments
(which should be used to describe why rather than just name things)

Take for example this section of Z80 code in the middle of a procedure:

	ld      c, a
	ld      b, $00
	ld      hl, ($.TEMP3)
	add     hl, bc

What's the purpose of this code? Adding comments can answer that, but we can better
visualise at a glance the flow of information by providing register hints like so:
  
	ld      c;blockIndex, a;blockIndex
	ld      b;blockIndex, $00
	ld      hl;solidityData, ($.TEMP3)
	add     hl;solidityData, bc;blockIndex

Now we can see that `$.TEMP3` contained "solidityData" this time (even though it
could be used for other purposes else where in the code) -- thus you do not have to
scroll around to find where `$.TEMP3` was last modified.

Overall, we can see that the "blockIndex" in register A is copied to BC and then added
to the "solidityData" in HL.

Note that register hints are optional and completely arbitrary, anything A-Z, 0-9 and
underscore can appear after the semi-colon and is not stored or referenced by the
assembler. They are purely for readability.


=======================================================================================
2.	Numbers
=======================================================================================
2.1.    Decimal
---------------------------------------------------------------------------------------
With Z80 code some instructions will require 8-bit numbers and some 16-bit numbers.
Any decimal number above 255 is implicitly a 16-bit number, therefore the following
would not work:

	`can't load 16-bit number into 8-bit register!
	ld a, 4096

It's fine to use an 8-bit number on 16-bit instructions though, i.e.

	ld bc, 8

The number will be used as 16-bit with the correct high and low byte order.
(the high byte will be 0) 

2.2     Fractions
---------------------------------------------------------------------------------------
Decimal numbers can also be fractional, i.e. with decimal places.
Up to 15 decimal places are supported.
        
        DEF PI 3.141592653589793

Expressions may also result in fractional values:
        
        DEF HALF 1 / 2

WARNING: Whilst fractional values can be supplied to Z80 instruction parameters,
the value will be rounded *DOWN* and a warning raised.
        
        ld a, 1.6                       `produces a warning, result will be 1

2.3.	Negatives
---------------------------------------------------------------------------------------
8-bit negative numbers are represented on the Master System by having the upper-most
bit set. This limits a negative number to -127 (8-bit) or -32767 (16-bit)

2.4.    Hexadecimal
---------------------------------------------------------------------------------------
Hexadecimal numbers are prefixed with the dollar sign "$", e.g.

	ld de, $ABCD

Hexadecimal numbers cannot be negative or have fractions.

2.5.    Binary
---------------------------------------------------------------------------------------
Binary numbers are prefixed with the percent sign "%".
You can include all 8 digits or only as many as you need

	ld h, %00001111
	ld h, %1111

For 16-bit numbers use more digits.
	
	ld hl, %0000111100001111

Binary numbers cannot be negative (in the sense of `-%10101010`), or have fractions.
        
2.6.	Units
---------------------------------------------------------------------------------------
Number suffixes (units) are supported to represent larger numbers in a simpler
fashion.

	1 K	= 1'000 (Kilobytes)
	1 KB	= 1'024 (Kibibytes)
	1 Kbit	= 128 (Kibibits)

2.7.    Limits
---------------------------------------------------------------------------------------
Numbers are limited to 32-bits even though internally the assembler stores numbers
using 64-bits. This is so that signed, unsigned and floating point numbers can all
be stored and treated the same. Therefore the following limitations apply to all
numbers:

        Type: `LONG` (32 bits)
              (unless otherwise defined, all numbers are by default 32-bit)
        
        Maximum:         4'294'967'295          (all 32 bits)
        Minimum:        -2'147'483'648          (31 bits & negative sign)
        
        Type: `TRIP` (24 bits "triple")
        
        Maximum:         16'777'216             (all 24 bits)
        Minimum:         -8'388'608             (23 bits & negative sign)
        
        TYPE: `WORD` (16 bits)
        
        Maximum:          65'536                (all 16 bits)
        Minimum:         -32'768                (15 bits & negative sign)
        
        TYPE: `BYTE` (8 bits)
        
        Maximum:          255                   (all 8 bits)
        Minimum:         -128                   (7 bits & negative sign)

NOTE: Fractions are supported on all decimal numbers, even 8-bit ones, e.g. `128.54`


=======================================================================================
3.	Expressions
=======================================================================================
An Expression is a calculation consisting of either a single Value, or multiple Values
separated by Operators, e.g. `1 + 1` (See the Terminology section).

These are the Operators supported:

:: Plus `+`
        Addition. I.e. `1 + 1`

:: Minus `-`
        Subtraction. I.e. `1 - 1`

:: Times `*`
        Multiplication. I.e. `2 * 2`

:: Divide `/`
        Division. I.e. `6 / 2`

:: Power `^`
        Exponentiation. I.e. multiplied a given number of times, `2 ^ 3` = `2 * 2 * 2`
        
:: Mod `\`
        Modulus. I.e. remainder of division, `5 \ 2` = 1
        
:: And `&`
        Bitwise AND. The bits of the two sides are combined using AND logic, that is:
        0 & 0 = 0 / 0 & 1 = 0 / 1 & 1 = 1
        
:: Or `|`
        Bitwise OR. The bits of the two sides are combined using OR logic, that is:
        0 | 0 = 0 / 0 | 1 = 1 / 1 | 1 = 1

:: Not `!`
        Bitwise NOT. The bits of the proceeding value are inverted.
        
:: Xor `~`
        Bitwise XOR. The bits of the two sides are combined using XOR logic, that is:
        0 ~ 0 = 0 / 0 ~ 1 = 1 / 1 ~ 1 = 0
        
:: Shift-left `<<`
        Shifts the bits of the value to the left by the number of places given by the
        right-hand Value, dropping the overflow into the bit-bucket and inserting
        zeroes to the right.

:: Shift-right `>>`
        Shifts the bits of the value to the right by the number of places given by the
        right-hand Value, dropping the overflow into the bit-bucket and inserting
        zeroes to the left.


=======================================================================================
4.      Procedures
=======================================================================================
Scopes: Root
Format:
        PROC    :<labelName>
        {
                [...]
        }
        
When writing assembly code, flexibility in the assembler is needed to handle the
inherit in-flexibility of assembly language. With pure assembly, inserting a single
instruction would throw off every consequent memory address and break the entire
code-base!

Labels allow you to point to an address in the ROM in a flexible & safe manner so that
your code can expand, contract or even change order without breaking the ROM addresses
used in the jump and load instructions (amongst others).

A label gives a name to a place in the code and the assembler will fill in the final
ROM address (accounting for the correct bank & slot) everywhere the name is used.

Unlike other assemblers, OZ80MANDIAS requires that all code / data be wrapped in a
relevant structure that will define the beginning and end of the block of code / data.
Many of the unique features of OZ80MANDIAS require that it know the boundaries of the
code and data.

Procedures (also known as routines) are the sections of code which you `call` into and
return from (`ret`). 

Whilst OZ80MANDIAS supports standard Z80 instruction syntax, your Z80 instructions
must be divided into named "procedures". OZ80MANDIAS cannot parse Z80 instructions
that lie outside of a procedure, so this is the first and most important structure
you must know.

For example:
        
        PROC :doThing {
                inc a
                ret
        }
        
The curly braces form a "block", a special encapsulation that defines the beginning
and end of the code that makes up the procedure.
        
In the example, some Z80 code is encapsulated in a procedure named ":doThing".
All procedure names begin with a colon so that their use elsewhere can be easily
recognised as a procedure. The location of this code in the ROM can now be addressed
using ":doThing" rather than a fixed number.

        PROC :someThing {
                ld a, $80
                call :doThing
                ret
        }

4.1.    Parameters
---------------------------------------------------------------------------------------
Scopes: Root
Format:
        PROC    :<procedureName>
                [PARAMS <list>]
                [RETURN <list>]
        {
                [...]
        }
        
Many times your procedures will require certain registers or memory addresses to have
been set before calling them. As a pure documentation / memory aid you can provide a
parameter list for procedures. The assembler does not yet use this information in any
way, but could in the future to check for clobbering (unintended register changes
between procedures).

In addition to listing the parameters you may also list the return registers / values
to help any user understand how to use a procedure at a quick glance without having
to decipher the code.

	PROC :decodeTheThing
		PARAMS	a;index 	`which thing to use
			hl;address	`data starts here
			bc;length	`data is this long
		RETURN	de;result	`decoding result
	{
		[...]
	}

Here the procedure is noted to use registers A, HL & BC as inputs and sets DE upon
return.

4.2.	Sub-Labels
---------------------------------------------------------------------------------------
Scopes: PROC
Format:
        .<labelName>

Within procedure blocks, special labels can be provided for the procedure to reference
internal locations, i.e. jumps and private pieces of data. These are placed at the
beginning of a line and start with a dot, followed by the name.

	PROC :myProcedure {
		ld b, 10
	.loop	nop
		djnz .loop
		ret
	}
	
	PROC :test {
                ld b, 20
                call :myProcedure.loop
                ret
        }

Here the sub-label `.loop` is defined and recognised as `:myProcedure.loop` but can be
referred to within the procedure as `.loop`. This prevents common labels within
procedures (such as "loop") from clashing with other procedures' internal labelling.
Outside of "myProcedure", it is referred to via the full label name.


=======================================================================================
5.      Constants
=======================================================================================
Scopes: Root
Format:
        DEF <name> [<expr>]

To reduce the amount of maintenance needed for changing values across a code base, 
you may define names for common values and use these names throughout to provide you
a single point to change that value in the future.

In its simplest form a constant is defined using the `DEF` statement,
a constant name and a value:

	DEF SIR_LANCELOTS_FAVOURITE_COLOUR $30

Anywhere you would normally use a value, you can now instead use the constant name:

	ld a, SIR_LANCELOTS_FAVOURITE_COLOUR

---------------------------------------------------------------------------------------
5.1.    Enumerations
---------------------------------------------------------------------------------------
Scopes: Root
Format: 
        ENUM <name> [<expr>] {
                .<name>         [<expr>]
                [...]
        }
        
Rather than have to manage the numbers of a list manually (especially when trying to
remove one in the middle), an enumeration provides names for a list, numbering
automatically for you.

        ENUM STATUS {
                .SLEEP                  `i.e. 'cp STATUS.SLEEP'
                .PARALYZE
                .POISEN
                .BURN
                .FREEZE
        }
        
=======================================================================================
5.	Variables
=======================================================================================
Scopes: Root
Format:
	VAR #<varName> [<expr>]
	
To reduce the amount of maintenance needed for changing values across a code base, 
you may define names for common values and use these names throughout to provide you
a single point to change that value in the future.

In its simplest form a variable is defined using the `VAR` statement,
a variable name and a value:

	VAR #sirLancelotsFavouriteColour $30

Anywhere you would normally use a value, you can now instead use the variable name:

	ld a, #sirLancelotsFavouriteColour

All variables are prefixed with a hash (a.k.a. 'pound', 'sharp' or 'octothorpe') any
place where they appear in the program. This convention is used so as to distinguish
in code (to any reader) that the variable is an arbitrary value defined by the
assembler and not native Z80 code (that would work on any assembler). This convention
also reduces confusion with the use of labels in Z80 instruction parameters.

If the value expression is omitted, a variable defaults to 0, e.g.

	VAR #ZERO

But a variable is re-defined without a value, it defaults to its previous value, e.g.

	VAR #ONE	1		`set to 1
	VAR #ONE			`value is still 1, not zero


=======================================================================================
6.	Objects
=======================================================================================
Scopes: Root
Format:
	OBJECT #<objName> {
                .<propName> AS BYTE|WORD|TRIP|LONG [x <expr>] [DEFAULT <expr>] [BITS {
                        .<propName>     [x <expr>]      `define a bit name
                        .               [x <expr>]      `skip bits
                }]
		.<propName> AS #<objName>
		[...]
	}

In your code you will likely be handling structured data of some kind. A common example
would be sprite definitions for players and enemies. The structured data would normally
consist of a number of parameters offset from some starting point, for example
X position, Y position, ID, speed and so forth.

Managing these objects in a flexible manner is possible by using object constructs,
essentially variables extended with custom properties defined by you.

Let's imagine an enemy object:

	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE
	}

First, a variable is defined, #enemy, with a value of 0 -- the starting offset point.
Additional properties are defined, each with a given size. These properties hold the
value of their offset, for example.

	ld ix, :alien			`the location of an enemy instance
	ld a, (ix+#enemy.id)		`gives 4
	ld bc, (ix+#enemy.x)		`gives 0
	ld de, (ix+#enemy.y)		`gives 2
	ld l, (ix+#enemy.speed)		`gives 5

As you can see, using an object provides the flexibility to rearrange the object's
properties, insert new ones in the middle or remove properties from any point without
breaking your assembly code (other than when reading bytes linearly).

When you need to specify a property bigger than 2 bytes, you may use the `x` operator
to give multiples of bytes or words; for example:

	OBJECT #thing {
		.someStuff	AS BYTE x 8
		.moreStuff	AS WORD x 16
	}

All variables and properties have a sub-property `.size` which gives the size of the
variable or property in bytes. E.g.

	PRINT #thing.moreStuff.size	`outputs 32 (16 words)
	PRINT #thing.size		`outputs 40 (8 + 32)

Objects can also contain other objects, allowing finer grained structure.

	OBJECT #position {
		.x 		AS WORD
		.y 		AS WORD
	}
	
	OBJECT #path {
		.start		AS #position
		.end		AS #position
	}
	
These sub-properties would be accessed with `#path.start.x`, for example.

...

6.1.	Bit Flags
---------------------------------------------------------------------------------------
Scopes: OBJECT, RAM
Format:
	BITS {
		.<propName>
		.			`unused bit
	}
	
Manipulating individual bits is a common task in assembly.
        
	VAR #elements AS BITS {
		.earth
		.wind
		.fire
		.water
	}
...

6.2.    Object Variables
---------------------------------------------------------------------------------------
Scopes: Root
Format:
        VAR #<varName> AS #<objName>

...


=======================================================================================
#.      Data
=======================================================================================
#.#.    Data Tables
---------------------------------------------------------------------------------------
Scope:  Root
Format:
        TABLE :<labelName> {
                [...]
        }
        
Whilst `PROC` is designed for holding Z80 code, data tables are designed for storing
your program's data such as graphics, levels and sound.

#.#.    Data Statements
---------------------------------------------------------------------------------------
Scope:  PROC, TABLE
Format:
        DATA|BYTE|WORD|TRIP|LONG|TEXT <list>

It's important to note that 16-bit numbers are stored in little-endian format, that is
the low-order byte is first and the hi-order byte second, therefore `$1234` would be
outputted as `$34, $12`. This is the format understood by the Master System.

#.#.	Binary Strings
---------------------------------------------------------------------------------------
Format:
	$"<data>"

To ease the work in providing longer sections of data, you can specify the bytes in a
more compact manner using hexadecimal digits:

	DATA $"0102030405060708090A0B0C"

The bytes will be inserted into the output without any re-ordering.

#.#.    ASCII Maps
---------------------------------------------------------------------------------------


#.#.    Indexes
---------------------------------------------------------------------------------------


=======================================================================================
#.	Memory Management:
=======================================================================================
#.1.    Introduction
---------------------------------------------------------------------------------------
The Master System can address 64 KB of memory which is mapped into 3 configurable
slots spanning 48 KB. Since a cartridge may contain more than 48 KB (typically 256 KB
or 512 KB), the contents of the cartridge can be "paged" into the slots in memory in
16 KB chunks known as "banks".

Slots 0, 1 & 2 can each hold any of the 16 KB banks in the cartridge.
A 256 KB cartridge, for example, would have 16 banks.

		Z80:					Cartridge ROM:

	$0000	+-----------------+ 1 KB	$00000	+-----------------+
	$0400	+ - - - - - - - - +			| BANK 0          | 16 KB
		| SLOT 0          | 15 KB	$04000	+-----------------+
		|                 |			| BANK 1          | 16 KB
	$4000	+-----------------+		$08000	+-----------------+
		|                 |			| BANK 2          | 16 KB
		| SLOT 1          | 16 KB	$0C000	+-----------------+
		|                 |			| BANK 3          | 16 KB
	$8000	+-----------------+		$10000	+-----------------+
		|                 |			| BANK 4          | 16 KB
		| SLOT 2          | 16 KB	$14000	+-----------------+
		|                 |			| BANK 5          | 16 KB
	$C000	+-----------------+		$18000	+-----------------+
	        | RAM             | 8 KB		| BANK 6          | 16 KB
	$E000	+-----------------+		$1C000	+-----------------+
	        | RAM (mirror)    |			| BANK 7          | 16 KB
	$FFFF	+-----------------+		$20000	+-----------------+
							| BANK 8          | 16 KB
						$24000	+-----------------+
							| BANK 9          | 16 KB
						$28000	+-----------------+
							| BANK 10         | 16 KB
						$2C000	+-----------------+
							| BANK 11         | 16 KB
						$30000	+-----------------+
							| BANK 12         | 16 KB
						$34000	+-----------------+
							| BANK 13         | 16 KB
						$38000	+-----------------+
							| BANK 14         | 16 KB
						$3C000	+-----------------+
							| BANK 15         | 16 KB
						$3FFFF	+-----------------+

What must be understood is that the code in the cartridge ROM that needs to refer to
elsewhere in the ROM cannot do so using absolute addresses, e.g. $2C000.

Letâ€™s say that you have some code in BANK 10 that needs to refer to some data in
BANK 14. The code must begin by loading these banks into the memory slots.
For example, BANK 10 is loaded into SLOT 1 and BANK 14 is loaded into SLOT 2.
That means that the contents of BANK 14 are referenced by addresses $4000 - $7FFF,
and *not* $38000-$3BFFF as in the ROM.

NOTE: The first 1 KB of memory is *always* paged in to the first 1 KB of the cartridge,
regardless of which bank in the cartridge slot 0 is assigned to. That means $0000-$03FF
in the memory is always mapped to $0000-$03FF in the ROM.

To make your life easier, the assembler will do all the necessary translation of
addresses for you automatically, however you must divide your code into SECTIONs
to alert the assembler when a particular bank or slot is required for a piece of code.

#.2.    Sections
---------------------------------------------------------------------------------------


=======================================================================================
#.      RAM
=======================================================================================
#.1.    Naming RAM Addresses
---------------------------------------------------------------------------------------
Format:
        RAM [<expr>] {
                .<ramName>              AS BYTE|WORD|TRIP|LONG [x <expr>]
                .<ramName>              AS #<objName>
                [...]
        }

Your assembly code will contain numerous references to the Master System's RAM
(Located from $C000 to $DFFF and mirrored at $E000 to $FFFF). Manually managing the
RAM addresses is difficult, and could make using 3rd party code untenable.

With OZ80 you can define a name for each RAM address and the assembler
will choose the address for you. Begin by defining a RAM block as such:

        RAM {
                .someRAM AS BYTE
                .moreRAM AS WORD
                .muchRAM AS BYTE x 1 KB
        }
        
Here, a RAM constant ".someRAM" is defined to be a byte in length. The assembler will
automatically choose the RAM address for it and move on to the next address based on
the size of the constant. The second constant ".moreRAM" is 2-bytes in length and the
third is 1 KB (1024 Bytes) in length.

You can have multiple RAM blocks throughout your code, so as to define relevant RAM
near the relevant code. The assembler chooses the RAM addresses starting from $C000,
but can you can override this on a RAM block by specifying a different starting point:

        RAM $D700 {
                [...]
        }

Here, the addressing will begin from $D700 in memory, for this particular RAM block.

TODO: RAM #Objects

TODO: Unnumbered RAM blocks will continue from the previous unnumbered RAM block,
      NOT a numbered one
      
TODO: Two numbered RAM blocks with same addresses will duplicate RAM


#.2.    Using RAM Constants
---------------------------------------------------------------------------------------
Format:
        $.<ramName>

Once a RAM constant is defined, it can be accessed in your Z80 code with the special
prefix "$.", e.g.

        ld a, ($.someRAM)
        
An additional ".size" property is defined on the RAM constant that provides the size
of the RAM constant in bytes (useful perhaps for setting up loop limits), e.g.

        ld bc, ($.muchRAM.size)         `loads BC with 1024


=======================================================================================
#.	Properties
=======================================================================================
A property is a sub-value of a named-item (i.e. variable, object, label etc.)
that tells you something about that item.

#.1.    Of Variables & Objects
---------------------------------------------------------------------------------------
Scope:  Any
Format:
	<varName>.<propName>

#.2.    Of Labels
---------------------------------------------------------------------------------------
Often-times in Z80 assembly you need to access the high or low bytes of a 16-bit value.
Instead of specifying these bytes in a fixed fashion, you can use the flexibility of
variables with the `hi` & `lo` properties, e.g.

	DEF FOO $1234
	ld      h, FOO.lo		`"$34"
	ld      l, FOO.hi		`"$12"

Notice that HL is loaded in low, high order due to the Z80 being little-endian.

The `.bank` property retrieves the bank number of where the Label resides,
the `.slot` property does likewise for the slot number - 0, 1 or 2 

	DEF BANKNUM :label.bank
	DEF SLOTNUM :label.slot

TODO:
	.size
...        

#.3.    Of Tables
---------------------------------------------------------------------------------------
...


=======================================================================================
#.	Includes
=======================================================================================
Scope:  Root
Format:
	INCLUDE <expr>
...

Scope:  PROC, TABLE
Format:
        BINARY <expr> [START <expr> [LENGTH <expr>|STOP <expr>]]
...




=======================================================================================
#.	Structures
=======================================================================================
Scope:  Root
Format:
	STRUCT :<labelName> AS #<varName> {
		.<propName> <list>
		[...]
	}

Objects are abstract concepts as defining one does not write any data in to the ROM;
they are for your convenience in referring to structured data. To make maintaining the
data statements easier, you can use the structure syntax, for example:

	STRUCT :alien AS #enemy {
		.id		$3F
		.x		$0080
		.y		$0020
		.speed		$1A
	}

This defines a structure labelled :alien, using the #enemy object as a template.
Each of the properties defined by the object are given a value.

What's interesting is that the order of the properties here does not have to be in the
same order as they are defined by the object! The assembler will automatically output
bytes in the order defined by the object, filling in the correct values in the correct
places.

What's more, you can omit properties entirely from the structure, and the default
value will be used: either 0 if undefined, or the DEFAULT attribute from the object
definition, e.g.:
	
	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE DEFAULT 5
	}
	
	STRUCT :alien AS #enemy {
		.id		$3F
	}
	
Even though this omits properties, the full object will assembled,
in the correct order and the 6th byte (speed) will be 5.

TODO: sub-objects of a structure


=======================================================================================
#.	Strings
=======================================================================================
Textual data can be represented easily:

	DATA "The quick brown fox"

Will write out the ASCII bytes for the given string of text between quotes.

Within strings, tabs and line-breaks are ignored so that you may space large portions
of text over multiple lines in your source code. To insert a tab, line-break or any
value into the output you can break the quote and insert the value:

	DATA "The quick brown fox", 13, "Jumps over the lazy dog"


=======================================================================================
#.	Program Flow
=======================================================================================
#.#.	Logic
---------------------------------------------------------------------------------------
Format:
	IF [NOT] <expr>|DEF #<variableName>|EXISTS <filename> {
		<code>
	[} ELSE IF <expr> {
		<code> ...]
	[} ELSE {
		<code>]
	}

TODO: "EXIT IF"
...

#.#.	Logical Operators
---------------------------------------------------------------------------------------
TODO: =, NOT, <, <=, >, >=, AND, OR (`&`/`|`/`!` are purely bitwise operators)


=======================================================================================
#.	Macros & Functions
=======================================================================================
#.#.	Macros
---------------------------------------------------------------------------------------
Format:
	MACRO @<macroName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
	}

TODO: "SHIFT", variable arguments, "ARGS.size"?
TODO: EXIT MACRO
TODO: USE MACRO @macroName
...

#.#.	Functions
---------------------------------------------------------------------------------------
Scope:  Root
Format:
	FUNCTION ?<functionName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
		DEF ?<functionName> <expr>
	}

A function is similar to a macro but is used to calculate values at expression points,
rather than inserting whole lines or blocks of code.

Since the purpose of a function is to calculate and return a value, functions cannot
contain assembly code and can only use these statements:

TODO: update this list
DEF :<label>, EXIT IF / FUNCTION / LOOP, IF / ELSE / ELSE IF / END IF

TODO: "EXIT FUNCTION"
...

Format:
	?<functionName> [<expr>[, <expr> ...]]


	DATA $AA, {?functionName $10, $20, $30}, $BB, $CC

...


=======================================================================================
#.      Z80 Helpers
=======================================================================================

PUSH / POP

JP HL|IX|IY / (HL|IX|IY)

