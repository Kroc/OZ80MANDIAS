=======================================================================================
OZ80MANDIAS: a Z80 assembler; Copyright (C) Kroc Camen, 2013-14
Licenced under a Creative Commons 3.0 Attribution Licence
--You may use and modify this code how you see fit as long as you give credit
=======================================================================================

i.	Goals:
=======================================================================================
:: Accessible
	The primary goal is to educate others and preserve code for the future.
	The purpose of this new assembler language is to be readable, obvious, more
	self-documenting and less cryptic than other syntaxes

:: Flexible, Portable
	Features are provided so that, when used properly, source code can be re-used,
	re-ordered, modified, expanded and contracted with hopefully a minimum amount
	of adjustment. In this regard, it goes further than any previous assembler

:: Minimal
	Effort has been made to use a concise vocabulary, to work with the best
	assumptions under doubt and to not duplicate functionality across multiple
	features

It's important to note that source compatibility with existing assemblers is *not* a
goal. Most assemblers are very good but fall short in a few areas that cannot be
overcome without a new, clean language design.


#	Comments
=======================================================================================
Format:
	;single-line
	/* multi-
	line */

The first thing available to you to make writing Z80 assembly easier is the ability
to add descriptive comments to your source.

The purpose of comments is to describe why things happen the way they do in the code
(such as an algorithm) as the purpose of a series of instructions cannot always be
gleamed just by looking at them alone.

	/* in the solidity data, bit 7 determines that the tile should appear in front
	   of sprites. rotate the byte three times to position bit 7 at bit 4.
	   this byte will form the high-byte of the 16-bit value for the name table
	   entry (bit 4 will therefore become bit 12) */
	rrca
	rrca
	rrca


#	Register Hints
=======================================================================================
Format:
	<register>\<hintName>

The Z80 registers are your temporary working space for manipulating information with
the CPU, as such register contents change constantly, for differing purposes.

Register hints provide the ability to keep track of the temporary "role" of registers.
It allows you to explain 'what' a register currently is, without resorting to comments
(which are bulkier and should be used to describe rather than just name things)

Take for example this section of Z80 code in the middle of a routine:

	ld      c, a
	ld      b, $00
	ld      hl, (#RAM_TEMP3)
	add     hl, bc

What's the purpose of this code? Adding comments can answer that, but we can better
visualise at a glance the flow of information by providing register hints like so:
  
	ld      c\blockIndex, a\blockIndex
	ld      b\blockIndex, $00
	ld      hl\solidityData, (#RAM_TEMP3)
	add     hl\solidityData, bc\blockIndex

Now we can see that #RAM_TEMP3 contained "solidityData" this time (even though it
could be used for other purposes else where in the code) -- thus you do not have to
scroll around to find where #RAM_TEMP3 was last assigned.

Overall, we can see that the "blockIndex" in register A is copied to BC and then added
to the "solidityData" in HL.

Note that register hints are completely arbitrary, anything A-Z, 0-9 and underscore
can appear after the backslash ("\") and is not stored or referenced by the assembler.
They are purely for readability.

Register hints do not replace the need for comments since comments should be used to
explain why this piece of code is doing what it is, but register hints do remove the
need to waste comments on explaining the mechanics of basic information flow.


#	Numbers
=======================================================================================
It's safe to say you know how to use numbers. With Z80 code some instructions will
require 8-bit numbers and some 16-bit numbers.

Any decimal number above 255 is implicitly a 16-bit number, therefore the following
would not work:

	ld a, 4096			;can't load 16-bit number into 8-bit register!

It's fine to use an 8-bit number on 16-bit instructions though, i.e.

	ld bc, 8

The number will be used as 16-bit with the correct high and low byte order.
(the high byte will be 0) 

Hexadecimal numbers are prefixed with the dollar sign "$", e.g.

	ld de, $ABCD

Binary numbers are prefixed with the percent sign "%".
You can include all 8 digits or only as many as you need

	ld h, %00001111
	ld h, %1111

For 16-bit numbers either use more digits, or place another binary number after the
first (for better readability), e.g.
	
	ld hl, %0000111100001111
	ld hl, %00001111%00001111

The second convention allows you to abbreviate 16-bit words like so:

	ld hl, %1%1			;%00000001%00000001 = 257

TODO:
Suffixes:		1 K		= 1'000
			1 KB		= 1'024
			1 Kbit		= 128 (1 Kibibit)
...

#	Variables
=======================================================================================
Format:
	DEF #<variableName> [<expr>]
	
The key benefit of a macro assembler over just an assembler is the ability to define
names for common values and use these names throughout to provide you a single point
to change that value in the future.

In its simplest form a variable is defined using the DEF statement,
a name and a value:

	DEF #SMS_SOUND_PORT $7F

Anywhere you would normally use a value, you can now instead use the variable name:

	out (#SMS_SOUND_PORT), a

All variables are prefixed with a hash (a.k.a. 'pound', 'sharp' or 'octothorpe') any
place where they appear in the program. This convention is used so as to distinguish
in code (to any reader) that the variable is an arbitrary value defined by the
assembler and not native Z80 code (that would work on any assembler). This convention
also reduces confusion with the use of labels (see the section on Labels for details)

If the value expression is omitted, a variable defaults to 0, e.g.

	DEF #ZERO

But a variable is re-defined without a value, it defaults to its previous value, e.g.

	DEF #ONE	1		;set to 1
	DEF #ONE			;value is still 1, not zero

The practical application of this behaviour will be demonstrated later when it comes
to using properties and defining RAM addresses

#.#	Properties
---------------------------------------------------------------------------------------
Format:
	#<variableName>.<propertyName>
	
A property is a sub-value of a variable that tells you something about that variable.

Oftentimes in Z80 assembly you need to access the high or low bytes of a 16-bit value.
Instead of specifying these bytes in a fixed fashion, you can use the flexibility of
variables with the `hi` & `lo` properties, e.g.

	DEF #foo	$1234
	ld b, #foo.lo			;"$34"
	ld c, #foo.hi			;"$12"

Notice that BC is loaded in low, high order due to the Z80 being little-endian.

The `.bank` property retrieves the bank number of where the Label resides,
the `.slot` property does likewise for the slot number - 0, 1 or 2 
(see section 3, "Banks & Slots")

```
DEF #labelBank :label.bank
DEF #RealAddr :label.slot * $4000
```

TODO:
	.size
...


#	Labels
=======================================================================================
Format:
	:<labelName>

A label is a little like a variable, however the value assigned is a memory
address based on where in your code it goes. It allows you to refer to points in code
without using the real hexadecimal address (which will be calculated for you).

```
:infiniteLoop
	nop
	jr :infiniteLoop
```

#.#	Sub-Labels
---------------------------------------------------------------------------------------
Labels that begin with a dot are attached as properties to the last regular label
defined, for example:

```
:myRoutine
	<code>
	...
.loop	<code>
	...
	jr .loop

:aDifferentRoutine
	jp :myRoutine.loop
```

Here the sub-label `.loop` is defined and recognised as `:myRoutine.loop`.
Outside of the label `:myRoutine`, it is referred to via the full label name
(to not confuse it with a potential `:aDifferentRoutine.loop`).

#.#	Anonymous Labels
---------------------------------------------------------------------------------------
...


#	Objects
=======================================================================================
Format:
	DEF #<objectName>
	DEF .<propertyName> [AS BYTE|WORD [x <expr>]|#<objectName>]

In your code you will likely be handling structured data of some kind.
A common example would be sprite definitions for players and enemies.
The structured data would normally consist of a number of parameters offset from some
starting point, for example X position, Y position, ID, speed and so forth.

Managing these objects in a flexible manner is possible by using object constructs,
essentially variables extended with custom properties defined by you.

Let's imagine an enemy object:

	DEF #enemy
	DEF .x		AS WORD
	DEF .y		AS WORD
	DEF .id		AS BYTE
	DEF .speed	AS BYTE

First, a variable is defined, #enemy, with a value of 0 -- the starting offset point.
Additional properties are defined, each with a given size. These properties hold the
value of their offset, for example.

	ld ix, :alien			;the location of an enemy instance
	ld a, (ix+#enemy.id)		;gives 4
	ld bc, (ix+#enemy.x)		;gives 0
	ld de, (ix+#enemy.y)		;gives 2
	ld l, (ix+#enemy.speed)		;gives 5

As you can see, using an object provides the flexibility to rearrange the object's
properties, insert new ones in the middle or remove properties from any point without
breaking your assembly code (other than when reading bytes linearly).

Supported data types are "BYTE" & "WORD" (2 bytes). More types will be supported in
future (including 24 / 32-bit words and single bits)

When you need to specify a property bigger than 2 bytes, you may use the `x` operator
to give multiples of bytes or words; for example:

	DEF #thing
	DEF .someStuff	AS BYTE x 8
	DEF .moreStuff	AS WORD x 16

All variables and properties have a sub-property `.size` which gives the size of the
variable or property in bytes. E.g.

	PRINT #thing.moreStuff.size	;outputs 32 (16 words)
	PRINT #thing.size		;outputs 40 (8 + 32)

Objects can also contain other objects, allowing finer grained structure.

	DEF #position
	DEF .x 		AS WORD
	DEF .y 		AS WORD
	
	DEF #path
	DEF .start	AS #position
	DEF .end	AS #position
	
These sub-properties would be accessed with `#path.start.x`, for example.

...

#.#	Structures
---------------------------------------------------------------------------------------
Format:
	DEF :<structureName> AS #<objectName>
	DEF .<propertyName> <expr>[, <expr> ...]

Objects are abstract concepts as defining one does not write any data in to the ROM;
they are for your convenience in referring to structured data. To make maintaining the
data statements easier, you can use the structure syntax, for example:

	DEF :alien AS #enemy
	DEF .x		$0080
	DEF .y		$0020
	DEF .id		$3F
	DEF .speed	$1A

This defines a structure labelled :alien, using the #enemy object as a template.
Each of the properties defined by the object are given a value.

What's interesting is that the order of the properties here does not have to be in the
same order as they are defined by the object! The assembler will automatically output
bytes in the order defined by the object, filling in the correct values in the correct
places.

What's more, you can omit properties entirely from the structure, and 0 will be used
by default!

	DEF :alien AS #enemy
	DEF .id		$3F
	
Even though this omits properties, the full object will assembled,
in the correct order.


#.	Expressions:
=======================================================================================
In the format descriptors given throughout this document, the term "<expr>" can
be substituted for a Number, a Label, a Variable, a Property or a calculation of any
combination using the Operators, to produce a value.

#.#	Operators
---------------------------------------------------------------------------------------
The standard operators are supported as `+` add, `-` subtract, `*` multiply,
`/` divide, `^` power & `\` modulus.

TODO:
& (AND)
| (OR)
! (NOT)
~ (XOR)
<< (Shift Left)
>> (Shift Right)
<<< (Rotate Left)?
>>> (Rotate Right)?

A final special operator `x` is supported. This repeats the preceding value by the
value on the right hand side. For example, the following:

```
DATA $80 x 6
```

Would insert 6 bytes of $80


#.	Banks & Slots
=======================================================================================
Format:
	BANK <expr>[, <expr> ...] [SLOT <expr> [, <expr> ...]]

TODO: This may very well be replaced by SECTION use

The Master System can address 64 KB of memory which is mapped into different 
configurable slots. Since a cartridge may contain more than 64 KB (typically 256 KB
or 512 KB), the contents of the cartridge can be "paged" into the slots in memory in
16 KB chunks known as "banks".

Here's a map of the Master System's memory as seen by the Z80 processor.

	$FFFF	+-----------------+
	        | RAM (mirror)    |
	$E000	+-----------------+
	        | RAM             | 8 KB
	$C000	+-----------------+
		|                 |
		| SLOT 2          | 16 KB
		|                 |
	$8000	+-----------------+
		|                 |
		| SLOT 1          | 16 KB
		|                 |
	$4000	+-----------------+
		|                 |
		| SLOT 0          | 15 KB
	$0400	+ - - - - - - - - +
	$0000	+-----------------+ 1 KB

It's important to note that the first 1 KB of memory is *always* paged in to the first
1 KB of the cartridge, regardless of which bank in the cartridge slot 0 is assigned to.
That means that $0000-$03FF in the memory is always mapped to $0000-$03FF in the ROM.

The `BANK` directive tells the assembler which bank of the cartridge the following
code is to be assembled into and automatically sets the origin to $0000 -- the start
of the bank.

In its simplest form just state the bank number, the slot is assumed to be 0.

```
BANK 0
```

You can also specify the slot number explicitly:

```
BANK 5 SLOT 1
```

This will assemble the code as if it is located between $4000-$7FFF even though it is
positioned at $10000-$13FFF in the ROM.

An error will occur if the assembler overflows the 16 KB limit of the bank.

If you are assembling a large amount of code or data that is bigger than 16 KB you may
not want to manage the boundary line manually as this is inflexible. Instead you can
specify more than one bank number (separated by commas) and the data will overflow
from one bank into the next automatically, i.e.

```
BANK 10, 11, 12
```

When the slot number is not specified it will begin at 0 and increase with each
automatic bank change until it reaches 2, before restarting back at 0.

You can specify a slot number which will be used for each bank, or a series of slot
numbers which will be used in order, e.g.

```
BANK 10, 11, 12 SLOT 2
BANK 3, 4, 5, 6 SLOT 0, 1, 0, 1
```

If no `BANK` declaration exists before the first line of assembled code,
`BANK 0 SLOT 0` will be assumed.

#.#	Setting the Assembly Point
---------------------------------------------------------------------------------------
Format:
	AT <expr>

If you need to place a piece of code or data starting in a particular location within
a bank the `AT` statement specifies an offset address from the beginning of the bank
to the desired starting point. In other assemblers this is usually known as `ORG`.

```
BANK 5		;bank 5 begins at $10000
AT $2000	;begin assembling at $12000
```

TODO: SKIP
...


#.	Data:
=======================================================================================
#.#.	Data statements
---------------------------------------------------------------------------------------
Format:
	DATA <expr>[, <expr> ...]

The data statement assembles numbers and text into the output file. It is used for
storing non-code data in the output ROM such as graphics, text and sound.

The data statement accepts one or more expressions separated by commas.

```
DATA $00, $FF, $00FF, $FF00, "STRING", :label, #variable
```

It's important to note that 16-bit numbers are stored in little-endian format, that is
the low-order byte is first and the hi-order byte second, therefore `$1234` would be
outputted as `$34, $12`. This is the format understood by the Master System.

#.#.	Filling Space
---------------------------------------------------------------------------------------
Format:
	FILL [BINARY] <expr>[, <expr> ...]

Fills unused space from the point of the declaration onwards with the given value,
string or binary file. The filling is done in a repeating background fashion so that
it will appear as if the assembled code/data has been placed over the top of an area
previously filled with the `FILL` value.

```
FILL $FF
FILL $00, $80, $FF
FILL "Copyright (C) SEGA"
FILL BINARY "filename.bin"
```


#.	Strings:
=======================================================================================
...

#.#.	Escape Sequences
---------------------------------------------------------------------------------------
...

#.#.	ASCII Maps
---------------------------------------------------------------------------------------
...


#.	Includes:
=======================================================================================
Format:
	INCLUDE [BINARY] <expr> [START <expr> [LENGTH <expr>|STOP <expr>]]
...


#.	Program Flow:
=======================================================================================
#.#.	Logic
---------------------------------------------------------------------------------------
Format:
	IF [NOT] [<expr>|DEF #<variableName>|EXISTS <filename>]
		<code>
	[ELSE IF <expr>
		<code> ...]
	[ELSE
		<code>]
	END IF

TODO: "EXIT IF"
...

#.#.	Logical Operators
---------------------------------------------------------------------------------------
TODO: =, NOT, <, <=, >, >=, AND, OR (`&`/`|`/`!` are purely bitwise operators)

#.#.	Loops
---------------------------------------------------------------------------------------
Format:
	BEGIN LOOP [<expr>]
		<code>
		[EXIT LOOP]
	END LOOP
...

'TODO: `DEF LOOP` doesn't seem right..., need better syntax?
	Could use recursive macros and do away with any specific loop syntax


#.	Sections:
=======================================================================================
Format:
	DEF SECTION :<sectionName> [MAXSIZE <expr>]
		<code>
	END DEF

A SECTION defines a standard label, but with an additional `.size` property that will
give the number of bytes in the section *after* assembly. This will allow you to
determine how large a block of code/data is, and to include this value in your code.

'TODO: MAXSIZE property
'TODO: BANK/SLOT/AT parameters?


#.	Macros & Functions:
=======================================================================================
#.#	Macros
---------------------------------------------------------------------------------------
Format:
	DEF MACRO @<macroName> [ARGS #<variableName>[, #<variableName> ...]]
		<code>
	END MACRO

TODO: "SHIFT", variable arguments, "ARGS.size"?
TODO: EXIT MACRO
TODO: USE MACRO @macroName
...

#.#	Functions
---------------------------------------------------------------------------------------
Format:
	DEF FUNCTION ?<functionName> [ARGS #<variableName>[, #<variableName> ...]]
		<code>
		LET ?<functionName> <expr>
	END DEF

A function is similar to a macro but is used to calculate values at expression points,
rather than inserting whole lines or blocks of code.

Since the purpose of a function is to calculate and return a value, functions cannot
contain assembly code and can only use these statements:

BEGIN / END LOOP, DEF :<label>, EXIT IF / FUNCTION / LOOP, IF / ELSE / ELSE IF / END IF


TODO: "EXIT FUNCTION"
...

Format:
	(?<functionName> [<expr>[, <expr> ...]])

```
DATA $AA, (?functionName $10, $20, $30), $BB, $CC
```

...


#.	Data Tables:
=======================================================================================
Format:
	DEF TABLE :<tableName>
		ROW .<rowIndexName>
		<data> ...
		[ROW .<rowIndexName>
		<data> ...]
	END DEF
...


#.	Memory Layout:
=======================================================================================
Format:
	DEF RAM [AT <expr>]
		DEF #<variableName> [AT <expr>] AS BYTE|WORD [x <expr>]
		DEF #<variableName> [AT <expr>] AS #<objectName>
		...
	END DEF
...


#.	The `#SYSTEM` Variables:
=======================================================================================
A special variable `#SYSTEM` holds a number of pieces of information that the
assembler updates as it progresses.

:: `#SYSTEM.PC`
	Gives the current assembly address (accounting for BANK and SLOT)
	
:: `#SYSTEM.PC.bank`
	Gives the current bank number of the assembly point

:: `#SYSTEM.PC.slot`
	Gives the current slot number of the assembly point

:: `#SYSTEM.TABLE.row`
	Within a ROW definition, gives the index number of the row.
	An error will occur if used outside of a ROW definition

...

'TODO: Is this needed? Is there a better way to do it? Name-squatting is bad