=======================================================================================
OZ80MANDIAS: a Z80 assembler; Copyright (C) Kroc Camen, 2013-14
Licenced under a Creative Commons 3.0 Attribution Licence
--You may use and modify this code how you see fit as long as you give credit
=======================================================================================

				TABLE OF CONTENTS
	
	i.		Goals
	
	1.		Comments
	1.1.		Register Hints
	
	2.		Numbers
	2.1.		Number Suffixes
	2.2.		Signed Numbers
	
	3.		Memory Management
	3.1.		Sections
	3.2.		Setting the Assembly Point
	
	4.		Labels
	4.1.		Procedures
	4.2.		Params
	4.3.		Sub-Labels
	4.4.		Anonymous Labels
	
	5.		Variables
	
	

i.	Goals:
---------------------------------------------------------------------------------------
:: Accessible
	The primary goal is to educate others and preserve code for the future.
	The purpose of this new assembler language is to be readable, obvious, more
	self-documenting and less ambiguous than other syntaxes
	
:: Flexible Source Code
	Features are provided so that, when used properly, source code can be re-used,
	re-ordered, modified, expanded and contracted with hopefully a minimum amount
	of adjustment. In this regard, it goes further than any previous assembler
	
:: Minimal
	Effort has been made to use a concise vocabulary, to work with the best
	assumptions under doubt and to not duplicate functionality across multiple
	features
	
It's important to note that source compatibility with existing assemblers is *not* a
goal. Most assemblers are very good but fall short in a few areas that cannot be
overcome without a new, clean language design.


1.	Comments
=======================================================================================
Format:
	`single-line
	``multi-
	  line``

The first thing available to you to make writing Z80 assembly easier is the ability
to add descriptive comments to your source.

The purpose of comments is to describe why things happen the way they do in the code
(such as an algorithm) as the purpose of a series of instructions cannot always be
gleaned just by looking at them alone.

A single-line comment begins with a back-tick. All text from that point to the end
of the line is ignored.

	ld	de, 3			`sprite table is 3 bytes per sprite

A multi-line comment begins with double back-tick ("``") and continues until the next
double back-tick is encountered. All text in between is ignored.
	
	``in the solidity data, bit 7 determines that the tile should appear in
	  front of sprites. rotate the byte three times to position bit 7 at bit 4.
	  this byte will form the high-byte of the 16-bit value for the name table
	  entry (bit 4 will therefore become bit 12)``
	rrca
	rrca
	rrca

1.1.	Register Hints
---------------------------------------------------------------------------------------
Format:
	<register>;<hintName>		`or:
	<register>'<hintName>		`for indicating shadow registers in use

The Z80 registers are your temporary working space for manipulating information with
the CPU. As such, register contents change constantly; for differing purposes.

Register hints provide the ability to keep track of the temporary "role" of registers.
It allows you to explain 'what' a register currently is, without resorting to comments
(which are bulkier and should be used to describe why rather than just name things)

Take for example this section of Z80 code in the middle of a routine:

	ld      c, a
	ld      b, $00
	ld      hl, (#RAM_TEMP3)
	add     hl, bc

What's the purpose of this code? Adding comments can answer that, but we can better
visualise at a glance the flow of information by providing register hints like so:
  
	ld      c;blockIndex, a;blockIndex
	ld      b;blockIndex, $00
	ld      hl;solidityData, (#RAM_TEMP3)
	add     hl;solidityData, bc;blockIndex

Now we can see that #RAM_TEMP3 contained "solidityData" this time (even though it
could be used for other purposes else where in the code) -- thus you do not have to
scroll around to find where #RAM_TEMP3 was last assigned.

Overall, we can see that the "blockIndex" in register A is copied to BC and then added
to the "solidityData" in HL.

Note that register hints are optional and completely arbitrary, anything A-Z, 0-9 and
underscore can appear after the semi-colon and is not stored or referenced by the
assembler. They are purely for readability.

Register hints do not replace the need for comments since comments should be used to
explain why a piece of code is doing what it is, but register hints do remove the
need to waste comments on explaining the mechanics of basic information flow.


2.	Numbers
=======================================================================================
It's safe to say you know how to use numbers. With Z80 code some instructions will
require 8-bit numbers and some 16-bit numbers.

Any decimal number above 255 is implicitly a 16-bit number, therefore the following
would not work:

	`can't load 16-bit number into 8-bit register!
	ld a, 4096

It's fine to use an 8-bit number on 16-bit instructions though, i.e.

	ld bc, 8

The number will be used as 16-bit with the correct high and low byte order.
(the high byte will be 0) 

Hexadecimal numbers are prefixed with the dollar sign "$", e.g.

	ld de, $ABCD

Binary numbers are prefixed with the percent sign "%".
You can include all 8 digits or only as many as you need

	ld h, %00001111
	ld h, %1111

For 16-bit numbers use more digits. Up to a maximum of 31 digits are supported at this
time, but more may be supported in the future.
	
	ld hl, %0000111100001111

2.1.	Number Suffixes:
---------------------------------------------------------------------------------------
Some number suffixes (units) are supported to represent larger number in a simpler
fashion.

	1 K		= 1'000 (kilobytes)
	1 KB		= 1'024 (kibibytes)
	1 Kbit		= 128 (kibibits)
	
2.2.	Signed Numbers:
---------------------------------------------------------------------------------------
Numbers are assumed to be positive and filling the full space of the 8 or 16-bits
available, i.e. 0-255 or 0-65535.

Negative numbers are represented on the Master System by having bit 7 set.
This limits a negative number to -127.

TODO: Is this one or two's compliment???


3.	Memory Management
=======================================================================================
The Master System can address 64 KB of memory which is mapped into 3 configurable
slots spanning 48 KB. Since a cartridge may contain more than 48 KB (typically 256 KB
or 512 KB), the contents of the cartridge can be "paged" into the slots in memory in
16 KB chunks known as "banks".

Slots 0, 1 & 2 can each hold any of the 16 KB banks in the cartridge.
A 256 KB cartridge, for example, would have 16 banks.

		Z80:					Cartridge ROM:

	$0000	+-----------------+ 1 KB	$00000	+-----------------+
	$0400	+ - - - - - - - - +			| BANK 0          | 16 KB
		| SLOT 0          | 15 KB	$04000	+-----------------+
		|                 |			| BANK 1          | 16 KB
	$4000	+-----------------+		$08000	+-----------------+
		|                 |			| BANK 2          | 16 KB
		| SLOT 1          | 16 KB	$0C000	+-----------------+
		|                 |			| BANK 3          | 16 KB
	$8000	+-----------------+		$10000	+-----------------+
		|                 |			| BANK 4          | 16 KB
		| SLOT 2          | 16 KB	$14000	+-----------------+
		|                 |			| BANK 5          | 16 KB
	$C000	+-----------------+		$18000	+-----------------+
	        | RAM             | 8 KB		| BANK 6          | 16 KB
	$E000	+-----------------+		$1C000	+-----------------+
	        | RAM (mirror)    |			| BANK 7          | 16 KB
	$FFFF	+-----------------+		$20000	+-----------------+
							| BANK 8          | 16 KB
						$24000	+-----------------+
							| BANK 9          | 16 KB
						$28000	+-----------------+
							| BANK 10         | 16 KB
						$2C000	+-----------------+
							| BANK 11         | 16 KB
						$30000	+-----------------+
							| BANK 12         | 16 KB
						$34000	+-----------------+
							| BANK 13         | 16 KB
						$38000	+-----------------+
							| BANK 14         | 16 KB
						$3C000	+-----------------+
							| BANK 15         | 16 KB
						$3FFFF	+-----------------+

What must be understood is that the code in the cartridge ROM that needs to refer to
elsewhere in the ROM cannot do so using absolute addresses, e.g. $2C000.

Letâ€™s say that you have some code in BANK 10 that needs to refer to some data in
BANK 14. The code must begin by loading these banks into the memory slots.
For example, BANK 10 is loaded into SLOT 1 and BANK 14 is loaded into SLOT 2.
That means that the contents of BANK 14 are referenced by addresses $4000 - $7FFF,
and *not* $38000-$3BFFF as in the ROM.

NOTE: The first 1 KB of memory is *always* paged in to the first 1 KB of the cartridge,
regardless of which bank in the cartridge slot 0 is assigned to. That means $0000-$03FF
in the memory is always mapped to $0000-$03FF in the ROM.

To make your life easier, the assembler will do all the necessary translation of
addresses for you automatically, however you must divide your code into SECTIONs
to alert the assembler when a particular bank or slot is required for a piece of code.

3.1.	Sections
---------------------------------------------------------------------------------------
Format:
	SECTION ::<sectionName>
		[BANK <expr> [SLOT <expr>] [AT <expr>]] [LIMIT <expr>]
	{
		<code>
	}
	
A Section exists as an encapsulation for your code to keep closely related code/data
together.
	
	SECTION ::code {
		ld a, (::data)
		ld b, (::data+1)
		ld c, (::data+2)
	}
	
	SECTION ::data {
		DATA 1, 2, 3
	}
	
The assembler will automatically choose where in the ROM to place each section and will
calculate the correct memory references to use for you. If your cartridge ROM is 48 KB
or less, you will not have to do any additional work.

For larger ROMs, your Z80 code will need to specifically page in the desired banks
where the data is stored. The assembler allows you to do this in such a way that you
do not have to manually manage the bank numbers yourself.
	
	SECTION ::code {
		ld a, ::data.bank
		ld ($FFFE), a
	}
	
	SECTION ::data {
		DATA 1, 2, 3
	}

In this example, the code loads the bank containing the data section into the first
slot (`$FFFE` on the Master System). `::data.bank` is automatically filled in with
the correct bank number by the assembler. Thankfully, your code will continue to
assemble even as your program grows and the data section moves into increasing bank
numbers!

For any Section, you can provide a specific Bank number to use and Slot number to
apply. For example:

	SECTION ::code BANK 10 {
		ld a, ::data.bank
		ld ($FFFD+::data.slot), a
	}
	
	SECTION ::data BANK 14 SLOT 1 {
		DATA 1, 2, 3
	}

Here, the data section will be located in Bank 14 in the ROM and references to its
content will be addressed through Slot 1 ($4000-$7FFF). This is a good example of
writing portable code that will adapt automatically to changes.

If you require a section to assemble into a very specific location, you can provide
the `AT` parameter to provide an offset address from the beginning of the Bank.
(You cannot specify `AT` without specifying at least a bank number)

	`force this code to appear at $00066 in the ROM
	SECTION ::PauseHandler BANK 0 SLOT 0 AT $66 {
		ld (#pauseFlag), 1
	}

3.2.	Handling Bank & Slot Boundaries
---------------------------------------------------------------------------------------
Sections are by default limited to 16 KB. If the contents of a Section overflow,
the source code will not assemble. This is because Banks & Slots are 16 KB in size
and for any Sections larger than this you will have to write Z80 code to load the
additional Banks into whichever desired slots.

(A Section that unknowingly overflows its Bank can easily cause difficult to debug 
problems with your game, so this is done for your safety.)

TODO: BANK / SLOT PARAMETERS
TODO: SKIP?


4.	Labels
=======================================================================================
Format:
	:<labelName>

When writing assembly code flexibility in the assembler is needed to handle the
inherit in-flexibility of assembly language. With pure assembly, inserting a single
instruction would throw off every consequent memory address!

Labels allow you to point to an address in the ROM in a flexible & safe manner so that
your code can expand, contract or even change order without breaking the ROM addresses
used in the jump and load instructions (amongst others).

A label gives a name to a place in the code and the assembler will fill in the final
ROM address (accounting for the correct bank & slot) everywhere the name is used.
	
	:someData
	DATA $3B
	
	[...]
	
	ld a, (:someData)

4.1.	Procedures
---------------------------------------------------------------------------------------
Format:
	PROC :<procedureName> {
		<code>
	}

Procedures (also known as routines) are the sections of code which you `call` into and
return from (`ret`).

To help organise your procedures and make them more portable, a specific procedure
syntax (`PROC`) is provided.

	PROC :myProcedure {
		ret
	}
	
	[...]
	
	call :myProcedure

The procedure is defined with a label, giving you a means to name your procedure and
the assembler will calculate the label's address in memory for you.

The curly braces form a "block", a special encapsulation that define the beginning
and end of the code that makes up the procedure.

4.2.	Params
---------------------------------------------------------------------------------------
Format:
	PROC :myProcedure
		[PARAMS <register>|$<address>|#<variable>[, ...]]
		[RETURN <register>|$<address>|#<variable>[, ...]] {
	}

Most of the time your procedures will require certain registers or memory addresses
to have been set before calling them. As a pure documentation / memory aid you can
provide a parameter list for procedures. The assembler does not yet use this
information in any way, but could in the future to check for clobbering (unintended
register changes between procedures).

In addition to listing the parameters you may also list the return registers / values
to help any user understand how to use a procedure at a quick glance without having
to decipher the code.

Here's a diverse sample:

	PROC :decodeTheThing
		PARAMS	a;index,	`which thing to use
			hl;address,	`data starts here
			bc;length	`data is this long
		RETURN	de;result	`decoding result
			#RAM.thing	`the decoded data
	{
		<code>
	}

Here the procedure is noted to use registers A, HL & BC as inputs and sets DE and
the memory address referred to by #RAM.thing on return.

4.3.	Sub-Labels
---------------------------------------------------------------------------------------
Within procedure blocks, labels that begin with a dot are attached as properties of
the procedure, e.g.

	PROC :myProcedure {
		ld b, 10
	.loop	nop
		djnz .loop
		ret
	}
	
	[...]
	
	ld b, 20
	call :myProcedure.loop

Here the sub-label `.loop` is defined and recognised as `:myProcedure.loop` but can be
referred to within the procedure as `.loop`. This prevents common labels within
procedures (such as "loop") from clashing with other procedures' internal labelling.
Outside of "myProcedure", it is referred to via the full label name.


5.	Variables
=======================================================================================
Format:
	DEF #<variableName> [<expr>]
	
The key benefit of a macro assembler over just an assembler is the ability to define
names for common values and use these names throughout to provide you a single point
to change that value in the future.

In its simplest form a variable is defined using the DEF statement,
a name and a value:

	DEF #sirLancelotsFavouriteColour $30

Anywhere you would normally use a value, you can now instead use the variable name:

	ld a, #sirLancelotsFavouriteColour

All variables are prefixed with a hash (a.k.a. 'pound', 'sharp' or 'octothorpe') any
place where they appear in the program. This convention is used so as to distinguish
in code (to any reader) that the variable is an arbitrary value defined by the
assembler and not native Z80 code (that would work on any assembler). This convention
also reduces confusion with the use of labels (see the section on Labels for details)

If the value expression is omitted, a variable defaults to 0, e.g.

	DEF #ZERO

But a variable is re-defined without a value, it defaults to its previous value, e.g.

	DEF #ONE	1		`set to 1
	DEF #ONE			`value is still 1, not zero

The practical application of this behaviour will be demonstrated later when it comes
to using properties and defining RAM addresses.


#.	Properties
=======================================================================================
Format:
	#<variableName>.<propertyName>
	
A property is a sub-value of a variable that tells you something about that variable.

Oftentimes in Z80 assembly you need to access the high or low bytes of a 16-bit value.
Instead of specifying these bytes in a fixed fashion, you can use the flexibility of
variables with the `hi` & `lo` properties, e.g.

	DEF #foo	$1234
	ld h, #foo.lo			`"$34"
	ld l, #foo.hi			`"$12"

Notice that HL is loaded in low, high order due to the Z80 being little-endian.

The `.bank` property retrieves the bank number of where the Label resides,
the `.slot` property does likewise for the slot number - 0, 1 or 2 
(see section 3, "Banks & Slots")

	DEF #labelBank :label.bank
	DEF #realAddr :label.slot * $4000

TODO:
	.size
...


#.	Data
=======================================================================================
#.#.	Data statements
---------------------------------------------------------------------------------------
Format:
	DATA <expr>[, <expr> ...]	//selects 8 or 16-bit automatically per value
	BYTE <expr>[, <expr> ...]	//8 bit values only
	WORD <expr>[, <expr> ...]	//16 bit values

The data statement assembles numbers and text into the output file. It is used for
storing non-code data in the output ROM such as graphics, text and sound.

The data statement accepts one or more expressions separated by commas.

	DATA $00, $FF, $00FF, $FF00, "string", :label, #variable, 1+2

It's important to note that 16-bit numbers are stored in little-endian format, that is
the low-order byte is first and the hi-order byte second, therefore `$1234` would be
outputted as `$34, $12`. This is the format understood by the Master System.

#.#.	Binary Strings
---------------------------------------------------------------------------------------
Format:
	$"<data>"
	%"<data>"

To ease the work in providing longer sections of data, you can specify the bytes in a
more compact manner using binary string, in either hexadecimal digits or binary digits
(if that's more representative of your data)

	$"0102030405060708090A0B0C"	`hexadecimal digits
	%"000001010011100101110111"	`binary digits

The bytes will be inserted into the output without any re-ordering.

#.#.	Filling Space
---------------------------------------------------------------------------------------
Format:
	FILL [BINARY] <expr>[, <expr> ...]

Fills unused space from the point of the declaration onwards with the given value,
string or binary file. The filling is done in a repeating background fashion so that
it will appear as if the assembled code/data has been placed over the top of an area
previously filled with the `FILL` value.

	FILL $FF
	FILL $00, $80, $FF
	FILL "Copyright (C) SEGA"
	FILL BINARY "filename.bin"


#.	Includes
=======================================================================================
Format:
	INCLUDE [BINARY] <expr> [START <expr> [LENGTH <expr>|STOP <expr>]]
...


#.	Data Tables
=======================================================================================
Format:
	TABLE :<tableName> {
		.<rowName>		;Also defines `rowName.index`
		<data> ...
		[.<rowName>
		<data> ...]
	}
...


#.	Objects
=======================================================================================
Format:
	OBJECT #<objectName> {
		.<propertyName> [AS BYTE|WORD [x <expr>]|#<object>] [DEFAULT <expr>]
		[...]
	}

In your code you will likely be handling structured data of some kind.
A common example would be sprite definitions for players and enemies.
The structured data would normally consist of a number of parameters offset from some
starting point, for example X position, Y position, ID, speed and so forth.

Managing these objects in a flexible manner is possible by using object constructs,
essentially variables extended with custom properties defined by you.

Let's imagine an enemy object:

	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE
	}

First, a variable is defined, #enemy, with a value of 0 -- the starting offset point.
Additional properties are defined, each with a given size. These properties hold the
value of their offset, for example.

	ld ix, :alien			`the location of an enemy instance
	ld a, (ix+#enemy.id)		`gives 4
	ld bc, (ix+#enemy.x)		`gives 0
	ld de, (ix+#enemy.y)		`gives 2
	ld l, (ix+#enemy.speed)		`gives 5

As you can see, using an object provides the flexibility to rearrange the object's
properties, insert new ones in the middle or remove properties from any point without
breaking your assembly code (other than when reading bytes linearly).

Supported data types are "BYTE" & "WORD" (2 bytes). More types will be supported in
future (including 24 / 32-bit words and single bits)

When you need to specify a property bigger than 2 bytes, you may use the `x` operator
to give multiples of bytes or words; for example:

	OBJECT #thing {
		.someStuff	AS BYTE x 8
		.moreStuff	AS WORD x 16
	}

All variables and properties have a sub-property `.size` which gives the size of the
variable or property in bytes. E.g.

	PRINT #thing.moreStuff.size	`outputs 32 (16 words)
	PRINT #thing.size		`outputs 40 (8 + 32)

Objects can also contain other objects, allowing finer grained structure.

	OBJECT #position {
		.x 		AS WORD
		.y 		AS WORD
	}
	
	OBJECT #path {
		.start		AS #position
		.end		AS #position
	}
	
These sub-properties would be accessed with `#path.start.x`, for example.

...

#.#.	Bit Flags
---------------------------------------------------------------------------------------
Format:
	DEF #<variableName> [<expr>] AS BITS {
		.<bitName>
		.			`unused bit
	}
	
Manipulating individual bits is a common task in assembly.

	DEF #elements $C000 AS BITS {
		.earth
		.wind
		.fire
		.water
	}
...

#.#.	Structures
---------------------------------------------------------------------------------------
Format:
	STRUCT :<structureName> AS #<objectName> {
		.<propertyName> <expr>[, <expr> ...]
		[...]
	}

Objects are abstract concepts as defining one does not write any data in to the ROM;
they are for your convenience in referring to structured data. To make maintaining the
data statements easier, you can use the structure syntax, for example:

	STRUCT :alien AS #enemy {
		.id		$3F
		.x		$0080
		.y		$0020
		.speed		$1A
	}

This defines a structure labelled :alien, using the #enemy object as a template.
Each of the properties defined by the object are given a value.

What's interesting is that the order of the properties here does not have to be in the
same order as they are defined by the object! The assembler will automatically output
bytes in the order defined by the object, filling in the correct values in the correct
places.

What's more, you can omit properties entirely from the structure, and the default
value will be used: either 0 if undefined, or the DEFAULT attribute from the object
definition, e.g.:
	
	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE DEFAULT 5
	}
	
	STRUCT :alien AS #enemy {
		.id		$3F
	}
	
Even though this omits properties, the full object will assembled,
in the correct order and the 6th byte (speed) will be 5.

TODO: sub-objects of a structure


#.	Expressions
=======================================================================================
In the format descriptors given throughout this document, the term "<expr>" can
be substituted for a Number, a Label, a Variable, a Property or a calculation of any
combination using the Operators, to produce a value.

#.#.	Operators
---------------------------------------------------------------------------------------
The standard operators are supported as `+` add, `-` subtract, `*` multiply,
`/` divide, `^` power & `\` modulus (remainder of division).

TODO:
& (AND)
| (OR)
! (NOT)
~ (XOR)
<< (Shift Left)
>> (Shift Right)
<<< (Rotate Left)?
>>> (Rotate Right)?

A final special operator `x` is supported. This repeats the preceding value by the
value on the right hand side. For example, the following:

	DATA $80 x 6

Would insert 6 bytes of $80


#.	Strings
=======================================================================================
Textual data can be represented easily:

	DATA "The quick brown fox"

Will write out the ASCII bytes for the given string of text between quotes.

Within strings, tabs and line-breaks are ignored so that you may space large portions
of text over multiple lines in your source code. To insert a tab, line-break or any
value into the output you can break the quote and insert the value:

	DATA "The quick brown fox", 13, "Jumps over the lazy dog"

#.#.	ASCII Maps
---------------------------------------------------------------------------------------
...


#.	Program Flow
=======================================================================================
#.#.	Logic
---------------------------------------------------------------------------------------
Format:
	IF [NOT] <expr>|DEF #<variableName>|EXISTS <filename> {
		<code>
	[} ELSE IF <expr> {
		<code> ...]
	[} ELSE {
		<code>]
	}

TODO: "EXIT IF"
...

#.#.	Logical Operators
---------------------------------------------------------------------------------------
TODO: =, NOT, <, <=, >, >=, AND, OR (`&`/`|`/`!` are purely bitwise operators)


#.	Macros & Functions
=======================================================================================
#.#.	Macros
---------------------------------------------------------------------------------------
Format:
	MACRO @<macroName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
	}

TODO: "SHIFT", variable arguments, "ARGS.size"?
TODO: EXIT MACRO
TODO: USE MACRO @macroName
...

#.#.	Functions
---------------------------------------------------------------------------------------
Format:
	FUNCTION ?<functionName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
		DEF ?<functionName> <expr>
	}

A function is similar to a macro but is used to calculate values at expression points,
rather than inserting whole lines or blocks of code.

Since the purpose of a function is to calculate and return a value, functions cannot
contain assembly code and can only use these statements:

TODO: update this list
DEF :<label>, EXIT IF / FUNCTION / LOOP, IF / ELSE / ELSE IF / END IF

TODO: "EXIT FUNCTION"
...

Format:
	?<functionName> [<expr>[, <expr> ...]]


	DATA $AA, {?functionName $10, $20, $30}, $BB, $CC

...


#.	Memory Layout
=======================================================================================
TODO: RAM can be easier defined using the object syntax

	OBJECT #RAM		$C000 {
		.floorLayout	AS BYTE x 4 KB
	}
	
	[...]
	
	`the offset will continue where it left off:
	OBJECT #RAM {
		.someThing	AS WORD
	}

Downside of this is that it forces a prefix, i.e. #RAM.floorLayout