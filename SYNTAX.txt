=======================================================================================
OZ80MANDIAS: a Z80 assembler; Copyright (C) Kroc Camen, 2013-14
Licenced under a Creative Commons 3.0 Attribution Licence
--You may use and modify this code how you see fit as long as you give credit
=======================================================================================

				TABLE OF CONTENTS
	
	i.		Goals
	1.		Comments
	2.		Register Hints
	3.		Numbers
	3.1.		Number Suffixes
	3.2.		Signed Numbers
	4.		Banks & Slots
	4.1.		Setting the Assembly Point
	5.		Labels
	5.1.		Procedures
	5.2.		Params
	5.3.		Sub-Labels
	5.4.		Anonymous Labels
	6.		Variables
	
	

i.	Goals:
---------------------------------------------------------------------------------------
:: Accessible
	The primary goal is to educate others and preserve code for the future.
	The purpose of this new assembler language is to be readable, obvious, more
	self-documenting and less ambiguous than other syntaxes
	
:: Flexible Source Code
	Features are provided so that, when used properly, source code can be re-used,
	re-ordered, modified, expanded and contracted with hopefully a minimum amount
	of adjustment. In this regard, it goes further than any previous assembler
	
:: Minimal
	Effort has been made to use a concise vocabulary, to work with the best
	assumptions under doubt and to not duplicate functionality across multiple
	features
	
It's important to note that source compatibility with existing assemblers is *not* a
goal. Most assemblers are very good but fall short in a few areas that cannot be
overcome without a new, clean language design.


1.	Comments
=======================================================================================
Format:
	`single-line
	``multi-
	line``

The first thing available to you to make writing Z80 assembly easier is the ability
to add descriptive comments to your source.

The purpose of comments is to describe why things happen the way they do in the code
(such as an algorithm) as the purpose of a series of instructions cannot always be
gleaned just by looking at them alone.

A single-line comment begins with a back-tick. All text from that point to the end
of the line is ignored.

	ld	de, 3			`sprite table is 3 bytes per sprite

A multi-line comment begins with double back-tick ("``") and continues until the next
double back-tick is encountered. All text in between is ignored.
	
	``in the solidity data, bit 7 determines that the tile should appear in
	  front of sprites. rotate the byte three times to position bit 7 at bit 4.
	  this byte will form the high-byte of the 16-bit value for the name table
	  entry (bit 4 will therefore become bit 12)``
	rrca
	rrca
	rrca


2.	Register Hints
=======================================================================================
Format:
	<register>;<hintName>		`or:
	<register>'<hintName>		`for indicating shadow registers in use

The Z80 registers are your temporary working space for manipulating information with
the CPU, as such register contents change constantly, for differing purposes.

Register hints provide the ability to keep track of the temporary "role" of registers.
It allows you to explain 'what' a register currently is, without resorting to comments
(which are bulkier and should be used to describe why rather than just name things)

Take for example this section of Z80 code in the middle of a routine:

	ld      c, a
	ld      b, $00
	ld      hl, (#RAM_TEMP3)
	add     hl, bc

What's the purpose of this code? Adding comments can answer that, but we can better
visualise at a glance the flow of information by providing register hints like so:
  
	ld      c;blockIndex, a;blockIndex
	ld      b;blockIndex, $00
	ld      hl;solidityData, (#RAM_TEMP3)
	add     hl;solidityData, bc;blockIndex

Now we can see that #RAM_TEMP3 contained "solidityData" this time (even though it
could be used for other purposes else where in the code) -- thus you do not have to
scroll around to find where #RAM_TEMP3 was last assigned.

Overall, we can see that the "blockIndex" in register A is copied to BC and then added
to the "solidityData" in HL.

Note that register hints are optional and completely arbitrary, anything A-Z, 0-9 and
underscore can appear after the semi-colon and is not stored or referenced by the
assembler. They are purely for readability.

Register hints do not replace the need for comments since comments should be used to
explain why a piece of code is doing what it is, but register hints do remove the
need to waste comments on explaining the mechanics of basic information flow.


3.	Numbers
=======================================================================================
It's safe to say you know how to use numbers. With Z80 code some instructions will
require 8-bit numbers and some 16-bit numbers.

Any decimal number above 255 is implicitly a 16-bit number, therefore the following
would not work:

	`can't load 16-bit number into 8-bit register!
	ld a, 4096

It's fine to use an 8-bit number on 16-bit instructions though, i.e.

	ld bc, 8

The number will be used as 16-bit with the correct high and low byte order.
(the high byte will be 0) 

Hexadecimal numbers are prefixed with the dollar sign "$", e.g.

	ld de, $ABCD

Binary numbers are prefixed with the percent sign "%".
You can include all 8 digits or only as many as you need

	ld h, %00001111
	ld h, %1111

For 16-bit numbers use more digits. Up to a maximum of 31 digits are supported at this
time, but more may be supported in the future.
	
	ld hl, %0000111100001111

3.1.	Number Suffixes:
---------------------------------------------------------------------------------------
Some number suffixes (units) are supported to represent larger number in a simpler
fashion.

	1 K		= 1'000 (kilobytes)
	1 KB		= 1'024 (kibibytes)
	1 Kbit		= 128 (kibibits)
	
3.2.	Signed Numbers:
---------------------------------------------------------------------------------------
Numbers are assumed to be positive and filling the full space of the 8 or 16-bits
available, i.e. 0-255 or 0-65535.

Negative numbers are represented on the Master System by having bit 7 set.
This limits a negative number to -127 (8-bit) or -32'767 (16-bit).

TODO: Is this one or two's compliment???


4.	Banks & Slots
=======================================================================================
Format:
	BANK <expr>[, <expr> ...] [SLOT <expr> [, <expr> ...]]

TODO: This will ideally be replaced by SECTION use, e.g.
      SECTION :<sectionName> [BANK <expr> SLOT <expr>] [AT <expr>]

The Master System can address 64 KB of memory which is mapped into different 
configurable slots. Since a cartridge may contain more than 64 KB (typically 256 KB
or 512 KB), the contents of the cartridge can be "paged" into the slots in memory in
16 KB chunks known as "banks".

Here's a map of the Master System's memory as seen by the Z80 processor.

	$FFFF	+-----------------+
	        | RAM (mirror)    |
	$E000	+-----------------+
	        | RAM             | 8 KB
	$C000	+-----------------+
		|                 |
		| SLOT 2          | 16 KB
		|                 |
	$8000	+-----------------+
		|                 |
		| SLOT 1          | 16 KB
		|                 |
	$4000	+-----------------+
		|                 |
		| SLOT 0          | 15 KB
	$0400	+ - - - - - - - - +
	$0000	+-----------------+ 1 KB

It's important to note that the first 1 KB of memory is *always* paged in to the first
1 KB of the cartridge, regardless of which bank in the cartridge slot 0 is assigned to.
That means that $0000-$03FF in the memory is always mapped to $0000-$03FF in the ROM.

The `BANK` directive tells the assembler which bank of the cartridge the following
code is to be assembled into and automatically sets the origin to $0000 -- the start
of the bank.

In its simplest form just state the bank number, the slot is assumed to be 0.

	BANK 0

You can also specify the slot number explicitly:

	BANK 5 SLOT 1

This will assemble the code as if it is located between $4000-$7FFF even though it is
positioned at $10000-$13FFF in the ROM.

An error will occur if the assembler overflows the 16 KB limit of the bank.

If you are assembling a large amount of code or data that is bigger than 16 KB you may
not want to manage the boundary line manually as this is inflexible. Instead you can
specify more than one bank number (separated by commas) and the data will overflow
from one bank into the next automatically, i.e.

	BANK 10, 11, 12

When the slot number is not specified it will begin at 0 and increase with each
automatic bank change until it reaches 2, before restarting back at 0.

You can specify a slot number which will be used for each bank, or a series of slot
numbers which will be used in order, e.g.

	BANK 10, 11, 12 SLOT 2
	BANK 3, 4, 5, 6 SLOT 0, 1, 0, 1

If no `BANK` declaration exists before the first line of assembled code,
`BANK 0 SLOT 0` will be assumed.

4.1.	Setting the Assembly Point
---------------------------------------------------------------------------------------
Format:
	AT <expr>

If you need to place a piece of code or data starting in a particular location within
a bank the `AT` statement specifies an offset address from the beginning of the bank
to the desired starting point. In other assemblers this is usually known as `ORG`.

	BANK 5				`bank 5 begins at $10000
	AT $2000			`begin assembling at $12000

TODO: SKIP
...


5.	Labels
=======================================================================================
Format:
	:<labelName>

When writing assembly code flexibility in the assembler is needed to handle the
inherit in-flexibility of assembly language. With pure assembly, inserting a single
instruction would throw off every consequent memory address!

Labels allow you to point to an address in the ROM in a flexible & safe manner so that
your code can expand, contract or even change order without breaking the ROM addresses
used in the jump and load instructions (amongst others).

A label gives a name to a place in the code and the assembler will fill in the final
ROM address (accounting for the correct bank & slot) everywhere the name is used.
	
	:someData
	DATA $3B
	
	[...]
	
	ld a, (:someData)

5.1.	Procedures
---------------------------------------------------------------------------------------
Format:
	PROC :<procedureName> {
		<code>
	}

Procedures (also known as routines) are the sections of code which you `call` into and
return from (`ret`).

To help organise your procedures and make them more portable, a specific procedure
syntax (`PROC`) is provided.

	PROC :myProcedure {
		ret
	}
	
	[...]
	
	call :myProcedure

The procedure is defined with a label, giving you a means to name your procedure and
the assembler will calculate the label's address in memory for you.

The curly braces form a "block", a special encapsulation that define the beginning
and end of the code that makes up the procedure.

5.2.	Params
---------------------------------------------------------------------------------------
Format:
	PROC :myProcedure
		[PARAMS <register>|$<address>|#<variable>[, ...]]
		[RETURN <register>|$<address>|#<variable>[, ...]] {
	}

Most of the time your procedures will require certain registers or memory addresses
to have been set before calling them. As a pure documentation / memory aid you can
provide a parameter list for procedures. The assembler does not yet use this
information in any way, but could in the future to check for clobbering (unintended
register changes between procedures).

In addition to listing the parameters you may also list the return registers / values
to help any user understand how to use a procedure at a quick glance without having
to decipher the code.

Here's a diverse sample:

	PROC :decodeTheThing
		PARAMS	a;index,	`which thing to use
			hl;address,	`data starts here
			bc;length	`data is this long
		RETURN	de;result	`decoding result
			#RAM.thing	`the decoded data
	{
		<code>
	}

Here the procedure is noted to use registers A, HL & BC as inputs and sets DE and
the memory address referred to by #RAM.thing on return.

5.3.	Sub-Labels
---------------------------------------------------------------------------------------
Within procedure blocks, labels that begin with a dot are attached as properties of
the procedure, e.g.

	PROC :myProcedure {
		ld b, 10
	.loop	nop
		djnz .loop
		ret
	}
	
	[...]
	
	ld b, 20
	call :myProcedure.loop

Here the sub-label `.loop` is defined and recognised as `:myProcedure.loop` but can be
referred to within the procedure as `.loop`. This prevents common labels within
procedures (such as "loop") from clashing with other procedures' internal labelling.
Outside of "myProcedure", it is referred to via the full label name.

5.4.	Anonymous Labels
---------------------------------------------------------------------------------------
Format:
	-	<code>			`negative label
	+	<code>			`forward label
	=	<code>			`bi-directional label
		jp : | djnz :		`refers to the PROC's label
...


6.	Variables
=======================================================================================
Format:
	DEF #<variableName> [<expr>]
	
The key benefit of a macro assembler over just an assembler is the ability to define
names for common values and use these names throughout to provide you a single point
to change that value in the future.

In its simplest form a variable is defined using the DEF statement,
a name and a value:

	DEF #sirLancelotsFavouriteColour $30

Anywhere you would normally use a value, you can now instead use the variable name:

	ld a, #sirLancelotsFavouriteColour

All variables are prefixed with a hash (a.k.a. 'pound', 'sharp' or 'octothorpe') any
place where they appear in the program. This convention is used so as to distinguish
in code (to any reader) that the variable is an arbitrary value defined by the
assembler and not native Z80 code (that would work on any assembler). This convention
also reduces confusion with the use of labels (see the section on Labels for details)

If the value expression is omitted, a variable defaults to 0, e.g.

	DEF #ZERO

But a variable is re-defined without a value, it defaults to its previous value, e.g.

	DEF #ONE	1		`set to 1
	DEF #ONE			`value is still 1, not zero

The practical application of this behaviour will be demonstrated later when it comes
to using properties and defining RAM addresses.


#.	Properties
=======================================================================================
Format:
	#<variableName>.<propertyName>
	
A property is a sub-value of a variable that tells you something about that variable.

Oftentimes in Z80 assembly you need to access the high or low bytes of a 16-bit value.
Instead of specifying these bytes in a fixed fashion, you can use the flexibility of
variables with the `hi` & `lo` properties, e.g.

	DEF #foo	$1234
	ld h, #foo.lo			`"$34"
	ld l, #foo.hi			`"$12"

Notice that HL is loaded in low, high order due to the Z80 being little-endian.

The `.bank` property retrieves the bank number of where the Label resides,
the `.slot` property does likewise for the slot number - 0, 1 or 2 
(see section 3, "Banks & Slots")

	DEF #labelBank :label.bank
	DEF #realAddr :label.slot * $4000

TODO:
	.size
...


#.	Data
=======================================================================================
#.#.	Data statements
---------------------------------------------------------------------------------------
Format:
	DATA <expr>[, <expr> ...]	//selects 8 or 16-bit automatically per value
	BYTE <expr>[, <expr> ...]	//8 bit values only
	WORD <expr>[, <expr> ...]	//16 bit values

The data statement assembles numbers and text into the output file. It is used for
storing non-code data in the output ROM such as graphics, text and sound.

The data statement accepts one or more expressions separated by commas.

	DATA $00, $FF, $00FF, $FF00, "string", :label, #variable, 1+2

It's important to note that 16-bit numbers are stored in little-endian format, that is
the low-order byte is first and the hi-order byte second, therefore `$1234` would be
outputted as `$34, $12`. This is the format understood by the Master System.

#.#.	Binary Strings
---------------------------------------------------------------------------------------
Format:
	$"<data>"
	%"<data>"

To ease the work in providing longer sections of data, you can specify the bytes in a
more compact manner using binary string, in either hexadecimal digits or binary digits
(if that's more representative of your data)

	$"0102030405060708090A0B0C"	`hexadecimal digits
	%"000001010011100101110111"	`binary digits

The bytes will be inserted into the output without any re-ordering.

#.#.	Filling Space
---------------------------------------------------------------------------------------
Format:
	FILL [BINARY] <expr>[, <expr> ...]

Fills unused space from the point of the declaration onwards with the given value,
string or binary file. The filling is done in a repeating background fashion so that
it will appear as if the assembled code/data has been placed over the top of an area
previously filled with the `FILL` value.

	FILL $FF
	FILL $00, $80, $FF
	FILL "Copyright (C) SEGA"
	FILL BINARY "filename.bin"


#.	Includes
=======================================================================================
Format:
	INCLUDE [BINARY] <expr> [START <expr> [LENGTH <expr>|STOP <expr>]]
...


#.	Data Tables
=======================================================================================
Format:
	TABLE :<tableName> {
		.<rowIndexName>
		<data> ...
		[.<rowIndexName>
		<data> ...]
	}
...


#.	Objects
=======================================================================================
Format:
	OBJECT #<objectName> {
		.<propertyName> [AS BYTE|WORD [x <expr>]|#<object>] [DEFAULT <expr>]
		[...]
	}

In your code you will likely be handling structured data of some kind.
A common example would be sprite definitions for players and enemies.
The structured data would normally consist of a number of parameters offset from some
starting point, for example X position, Y position, ID, speed and so forth.

Managing these objects in a flexible manner is possible by using object constructs,
essentially variables extended with custom properties defined by you.

Let's imagine an enemy object:

	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE
	}

First, a variable is defined, #enemy, with a value of 0 -- the starting offset point.
Additional properties are defined, each with a given size. These properties hold the
value of their offset, for example.

	ld ix, :alien			`the location of an enemy instance
	ld a, (ix+#enemy.id)		`gives 4
	ld bc, (ix+#enemy.x)		`gives 0
	ld de, (ix+#enemy.y)		`gives 2
	ld l, (ix+#enemy.speed)		`gives 5

As you can see, using an object provides the flexibility to rearrange the object's
properties, insert new ones in the middle or remove properties from any point without
breaking your assembly code (other than when reading bytes linearly).

Supported data types are "BYTE" & "WORD" (2 bytes). More types will be supported in
future (including 24 / 32-bit words and single bits)

When you need to specify a property bigger than 2 bytes, you may use the `x` operator
to give multiples of bytes or words; for example:

	OBJECT #thing {
		.someStuff	AS BYTE x 8
		.moreStuff	AS WORD x 16
	}

All variables and properties have a sub-property `.size` which gives the size of the
variable or property in bytes. E.g.

	PRINT #thing.moreStuff.size	`outputs 32 (16 words)
	PRINT #thing.size		`outputs 40 (8 + 32)

Objects can also contain other objects, allowing finer grained structure.

	OBJECT #position {
		.x 		AS WORD
		.y 		AS WORD
	}
	
	OBJECT #path {
		.start		AS #position
		.end		AS #position
	}
	
These sub-properties would be accessed with `#path.start.x`, for example.

...

#.#.	Bit Flags
---------------------------------------------------------------------------------------
Format:
	DEF #<variableName> [<expr>] AS BITS {
		.<bitName>
		.			`unused bit
	}
	
Manipulating individual bits is a common task in assembly.

	DEF #elements $C000 AS BITS {
		.earth
		.wind
		.fire
		.water
	}
...

#.#.	Structures
---------------------------------------------------------------------------------------
Format:
	STRUCT :<structureName> AS #<objectName> {
		.<propertyName> <expr>[, <expr> ...]
		[...]
	}

Objects are abstract concepts as defining one does not write any data in to the ROM;
they are for your convenience in referring to structured data. To make maintaining the
data statements easier, you can use the structure syntax, for example:

	STRUCT :alien AS #enemy {
		.id		$3F
		.x		$0080
		.y		$0020
		.speed		$1A
	}

This defines a structure labelled :alien, using the #enemy object as a template.
Each of the properties defined by the object are given a value.

What's interesting is that the order of the properties here does not have to be in the
same order as they are defined by the object! The assembler will automatically output
bytes in the order defined by the object, filling in the correct values in the correct
places.

What's more, you can omit properties entirely from the structure, and the default
value will be used: either 0 if undefined, or the DEFAULT attribute from the object
definition, e.g.:
	
	OBJECT #enemy {
		.x		AS WORD
		.y		AS WORD
		.id		AS BYTE
		.speed		AS BYTE DEFAULT 5
	}
	
	STRUCT :alien AS #enemy {
		.id		$3F
	}
	
Even though this omits properties, the full object will assembled,
in the correct order and the 6th byte (speed) will be 5.

TODO: sub-objects of a structure


#.	Expressions
=======================================================================================
In the format descriptors given throughout this document, the term "<expr>" can
be substituted for a Number, a Label, a Variable, a Property or a calculation of any
combination using the Operators, to produce a value.

#.#.	Operators
---------------------------------------------------------------------------------------
The standard operators are supported as `+` add, `-` subtract, `*` multiply,
`/` divide, `^` power & `\` modulus (remainder of division).

TODO:
& (AND)
| (OR)
! (NOT)
~ (XOR)
<< (Shift Left)
>> (Shift Right)
<<< (Rotate Left)?
>>> (Rotate Right)?

A final special operator `x` is supported. This repeats the preceding value by the
value on the right hand side. For example, the following:

	DATA $80 x 6

Would insert 6 bytes of $80


#.	Strings
=======================================================================================
Textual data can be represented easily:

	DATA "The quick brown fox"

Will write out the ASCII bytes for the given string of text between quotes.

Within strings, tabs and line-breaks are ignored so that you may space large portions
of text over multiple lines in your source code. To insert a tab, line-break or any
value into the output you can break the quote and insert the value:

	DATA "The quick brown fox", 13, "Jumps over the lazy dog"

#.#.	ASCII Maps
---------------------------------------------------------------------------------------
...


#.	Program Flow
=======================================================================================
#.#.	Logic
---------------------------------------------------------------------------------------
Format:
	IF [NOT] <expr>|DEF #<variableName>|EXISTS <filename> {
		<code>
	[} ELSE IF <expr> {
		<code> ...]
	[} ELSE {
		<code>]
	}

TODO: "EXIT IF"
...

#.#.	Logical Operators
---------------------------------------------------------------------------------------
TODO: =, NOT, <, <=, >, >=, AND, OR (`&`/`|`/`!` are purely bitwise operators)


#.	Sections
=======================================================================================
Format:
	SECTION :<sectionName> [BANK <expr> SLOT <expr>] [AT <expr>] [MAXSIZE <expr>] {
		<code>
	}

A SECTION defines a standard label, but with an additional `.size` property that will
give the number of bytes in the section *after* assembly. This will allow you to
determine how large a block of code/data is, and to include this value in your code.

TODO: MAXSIZE property
TODO: BANK/SLOT/AT parameters?


#.	Macros & Functions
=======================================================================================
#.#.	Macros
---------------------------------------------------------------------------------------
Format:
	MACRO @<macroName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
	}

TODO: "SHIFT", variable arguments, "ARGS.size"?
TODO: EXIT MACRO
TODO: USE MACRO @macroName
...

#.#.	Functions
---------------------------------------------------------------------------------------
Format:
	FUNCTION ?<functionName> [ARGS #<variableName>[, #<variableName> ...]] {
		<code>
		DEF ?<functionName> <expr>
	}

A function is similar to a macro but is used to calculate values at expression points,
rather than inserting whole lines or blocks of code.

Since the purpose of a function is to calculate and return a value, functions cannot
contain assembly code and can only use these statements:

TODO: update this list
DEF :<label>, EXIT IF / FUNCTION / LOOP, IF / ELSE / ELSE IF / END IF

TODO: "EXIT FUNCTION"
...

Format:
	?<functionName> [<expr>[, <expr> ...]]


	DATA $AA, {?functionName $10, $20, $30}, $BB, $CC

...


#.	Memory Layout
=======================================================================================
TODO: RAM can be easier defined using the object syntax

	OBJECT #RAM		$C000 {
		.floorLayout	AS BYTE x 4 KB
	}
	
	[...]
	
	`the offset will continue where it left off:
	OBJECT #RAM {
		.someThing	AS WORD
	}

Downside of this is that it forces a prefix, i.e. #RAM.floorLayout