`` Sonic 1 Master System Disassembly
   created by Kroc Camen <kroc@camendesign.com>
   for MaSS1VE: The Master System Sonic 1 Visual Editor <github.com/Kroc/MaSS1VE>
   ================================================================================= ``

PROC    :decompressArt                  SECTION ::main
        `====================================================================[$0405]===
PARAMS	hl	`relative address from the beginning of the intended bank (A)
	de	`VDP register number (D) and value byte (E) to send to the VDP
	a	`bank number for the relative address HL
{
	di				`disable interrupts
._1	push	af			`remember the A parameter
	
	`--- determine bank number ----------------------------------------------------
	
	`is the HL parameter address below the $40xx range?
	 `--that is, does the relative address extend into the second page?
	ld	a, h
	cp	$40
	jr	c, ._2
	
	`remove #$40xx (e.g. so $562B becomes $162B)
	sub	$40
	ld	h, a
	
	`restore the A parameter (the starting bank number) and increase it so that
	 `HL now represents a relative address from the next bank up. this would mean
	 `that instead of paging in, for example, banks 9 & 10, we would get 10 & 11
	pop	af
	inc	a
	jp	._1
	
	`--- configure the VDP --------------------------------------------------------
	
._2	ld	a, e			`load the second byte from the DE parameter
	out	(#SMS_VDP_CONTROL), a	`send as the value byte to the VDP
	
	ld	a, d
	or	%01000000		`add bit 7 (that is, convert A to a
					 `VDP control register number)
	out	(#SMS_VDP_CONTROL), a	`send it to the VDP
	
	`--- switch banks -------------------------------------------------------------
	
	pop	af			`restore the A parameter
	
	`add $4000 to the HL parameter to re-base it for page 1 (Z80:$4000-$7FFF)
	ld	de, $4000
	add	hl, de
	
	`stash the current page 1/2 bank numbers cached in RAM
	ld	de, (#RAM_PAGE_1)
	push	de
	
	`change pages 1 & 2 (Z80:$4000-$BFFF) to banks A & A+1
	ld	(#SMS_PAGE_1), a
	ld	(#RAM_PAGE_1), a
	inc	a
	ld	(#SMS_PAGE_2), a
	ld	(#RAM_PAGE_2), a
	
	`--- read header --------------------------------------------------------------
	
	bit	1, (iy+#vars.flags9)
	jr	nz, ._3
	ei
	
._3	ld	(#RAM_TEMP4), hl
	
	`begin reading the compressed art header:
	 `see <info.sonicretro.org/SCHG:Sonic_the_Hedgehog_%288-bit%29#Header>
	 `for details on the format
	
	`skip the "48 59" art header marker
	inc	hl
	inc	hl
	
	`read the DuplicateRows value into DE and save for later
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	inc	hl
	push	de
	
	`read the ArtData value into DE and save for later
	ld	e, (hl)
	inc	hl
	ld	d, (hl)
	push	de
	
	`read the row count (#$0400 for sprites, #$0800 for tiles) into BC
	inc	hl
	ld	c, (hl)
	inc	hl
	ld	b, (hl)
	inc	hl
	
	ld	(#RAM_TEMP3), bc	`store the row count in $D210
	ld	(#RAM_TEMP6), hl	`where the UniqueRows list begins
	
	`swap BC/DE/HL with their shadow values
	exx
	
	`load BC with the absolute starting address of the art header;
	 `the DuplicateRows and ArtData values are always relative to this
	ld	bc, (#RAM_TEMP4)
	`copy it to DE
	ld	e, c
	ld	d, b
	
	pop	hl			`pull the ArtData value from the stack
	add	hl, bc			`get the absolute address of ArtData
	ld	(#RAM_TEMP1), hl	`and store that in $D20E
	`copy it to BC. this will be used to produce a counter from 0 to RowCount
	ld	c, l
	ld	b, h
	
	pop	hl			`load HL with the DuplicateRows value
	add	hl, de			`get the absolute address of DuplicateRows
	
	`swap DE & HL. DE will now be the DuplicateRows absolute address,
	 `and HL will be the absolute address of the art header
	ex	de, hl
	
	`now swap the original values back,
	 `BC will be the row counter
	 `DE will be the ArtData value
	exx
	
	`--- process row --------------------------------------------------------------
.processRow
	ld	hl, (#RAM_TEMP3)	`load HL with the original row count number
					 `(#$0400 for sprites, #$0800 for tiles)
	xor	a			`set A to 0 (Carry is reset)
	sbc	hl, bc			`subtract current counter from the row count
					 `that is, count upwards from 0
	push	hl			`save the counter value
	
	`get the row number in the current tile (0-7):
	ld	d, a			`zero-out D
	ld	a, l			`load A with the lo-byte of the counter
	and	%00000111		`clip to the first three bits,
					 `that is, "mod 8" it so it counts 0-7
	ld	e, a			`load E with this value, making it a
					 `16-bit number in DE
	ld	hl, .rowIndexTable
	add	hl, de			`add the row number to $04F9
	ld	a, (hl)			`get the bit mask for the particular row
	
	pop	de			`fetch our counter back
	
	`divide the counter by 4
	srl	d
	rr	e
	srl	d
	rr	e
	srl	d
	rr	e
	
	ld	hl, (#RAM_TEMP6)	`the absolute address where the UniqueRows
					 `list begins
	add	hl, de			`add the counter, so move along to the
					 `DE'th byte in the UniqueRows list
	ld	e, a			
	ld	a, (hl)			`read the current byte in the UniqueRows list
	and	e			`test if the masked bit is set
	jr	nz, .duplicateRow	`if the bit is set, it's a duplicate row,
					 `otherwise continue for a unique row
	
	`--- unique row ---------------------------------------------------------------
	
	`swap back the BC/DE/HL shadow values
	 `BC will be the absolute address to the ArtData
	 `DE will be the DuplicateRows absolute address
	 `HL will be the absolute address of the art header
	exx
	
	`write 1 row of pixels (4 bytes) to the VDP
	ld	a, (bc)
	out	(#SMS_VDP_DATA), a
	inc	bc
	nop
	nop
	ld	a, (bc)
	out	(#SMS_VDP_DATA), a
	inc	bc
	nop
	nop
	ld	a, (bc)
	out	(#SMS_VDP_DATA), a
	inc	bc
	nop
	nop
	ld	a, (bc)
	out	(#SMS_VDP_DATA), a
	inc	bc
	
	`swap BC/DE/HL back again
	 `HL is the current byte in the UniqueRows list
	exx
	
	dec	bc			`decrease the length counter
	ld	a, b			`combine the high byte,
	or	c			`with the low byte...
	jp	nz, .processRow		`loop back if not zero
	jp	._5			`otherwise, skip to finalisation

.duplicateRow
	`--- duplicate row ------------------------------------------------------------
	
	`swap in the BC/DE/HL shadow values
	 `BC will be the absolute address to the ArtData
	 `DE will be the DuplicateRows absolute address
	 `HL will be the absolute address of the art header
	exx
	
	ld	a, (de)			`read a byte from the duplicate rows list
	inc	de			`move to the next byte
	
	`swap back the original BC/DE/HL values
	exx
	
	`HL will be re-purposed as the index into the art data
	ld	h, $00
	`check if the byte from the duplicate rows list begins with $F, i.e. $Fxxx
	 `this is used as a marker to specify a two-byte number for indexes over 256
	cp	$F0
	jr	c, ._4			`if less than $F0, skip reading next byte
	sub	$F0			`strip the $F0, i.e $F3 = $03
	ld	h, a			`and set as the hi-byte for the art data index
	exx				`switch DE to DuplicateRows list abs. address
	ld	a, (de)			`fetch the next byte
	inc	de			`and move forward in the list
	exx				`return BC/DE/HL to before
	`multiply the duplicate row's index number to the art data by 4
	 `--each row of art data is 4 bytes
._4	ld	l, a
	add	hl, hl			
	add	hl, hl
	
	ld	de, (#RAM_TEMP1)	`get the absolute address to the art data
	add	hl, de			`add the index from the duplicate row list
	
	`write 1 row of pixels (4 bytes) to the VDP
	ld	a, (hl)			
	out	(#SMS_VDP_DATA), a
	inc	hl
	nop
	nop
	ld	a, (hl)
	out	(#SMS_VDP_DATA), a
	inc	hl
	nop
	nop
	ld	a, (hl)
	out	(#SMS_VDP_DATA), a
	inc	hl
	nop
	nop
	ld	a, (hl)
	out	(#SMS_VDP_DATA), a
	inc	hl
	
	`decrease the remaining row count
	dec	bc
	
	`check if all rows have been done
	ld	a, b
	or	c
	jp	nz, .processRow

._5	bit	1, (iy+#vars.flags9)
	jr	nz, ._6
	di
._6	`restore the pages to the original banks at the beginning of the procedure
	pop	de
	ld	(#RAM_PAGE_1), de
	ld	(#SMS_PAGE_1), de
	
	ei
	res	1, (iy+#vars.flags9)
	ret

.rowIndexTable
        DATA %00000001
        DATA %00000010
        DATA %00000100
        DATA %00001000
        DATA %00010000
        DATA %00100000
        DATA %01000000
        DATA %10000000
}

PROC    :decompressScreen               SECTION ::main
        `====================================================================[$0501]===
PARAMS	bc	`length of the compressed data
	de	`VDP register number (D) and value byte (E) to send to the VDP
	hl	`absolute address to the start of the compressed screen data
{        
	di				`disable interrupts
	
	`configure the VDP based on the DE parameter
	ld	a, e
	out	(#SMS_VDP_CONTROL), a
	ld	a, d
	or	%01000000		`add bit 7 (that is, convert A to a
					 `VDP control register number)
	out	(#SMS_VDP_CONTROL), a
	
	ei				`enable interrupts
	
`a screen layout is compressed using RLE (run-length-encoding). any byte that there
 `are multiple of in a row are listed as two repeating bytes, followed by another byte
 `specifying the remaining number of times to repeat
	
._1	`the current byte is stored in E to be able to check when two bytes in a row
	 `occur (the marker for a compressed byte). it's actually stored inverted
	 `so that the first data byte doesn't trigger an immediate repeat
	
	ld	a, (hl)			`read the current byte from the screen data
	cpl				`invert the bits ("NOT")
	ld	e, a			`move this to E
	
._2	ld	a, (hl)			`read the current byte from the screen data
	cp	e			`is this equal to the previous byte?
	jr	z, ._3			`if yes, decompress the byte
	
	cp	$FF			`is this tile $FF?
	jr	z, .skip		
	
	`--- uncompressed byte --------------------------------------------------------
	out	(#SMS_VDP_DATA), a	`send the tile to the VDP
	ld	e, a			`update the "current byte" being compared
	ld	a, (#RAM_TEMP1)		`get the upper byte to use for the tiles
					 `(foreground / background / flip)
	out	(#SMS_VDP_DATA), a
	
	inc	hl			`move to the next byte
	dec	bc			`decrease the remaining bytes to read
	ld	a, b			`check if remaining bytes is zero
	or	c
	jp	nz, ._2			`if remaining bytes, loop
	jr	._6			`otherwise end
	
	`--- decompress byte ----------------------------------------------------------
._3	ld	d, a			`put the current data byte into D
	inc	hl			`move to the next byte
	dec	bc			`decrease the remaining bytes to read
	ld	a, b			`check if remaining bytes is zero
	or	c
	jr	z, ._6			`if no bytes left, finish
					 `(couldn't I just put `ret z` here?)
	
	ld	a, d			`return the data byte back to A
	ld	e, (hl)			`get the number of times to repeat the byte
	cp	$FF			`is a skip being repeated?
	jr	z, .multiSkip
	
	`repeat the byte
._4	out	(#SMS_VDP_DATA), a
	push	af
	ld	a, (#RAM_TEMP1)
	out	(#SMS_VDP_DATA), a
	pop	af
	dec	e
	jp	nz, ._4
	
._5	`move to the next byte in the data
	inc	hl
	dec	bc
	
	`any remaining bytes?
	ld	a, b
	or	c
	jp	nz, ._1			`if yes start checking duplicate bytes again
	
	`all bytes processed - we're done!
._6	ret
	
.skip
	ld	e, a
	in	a, (#SMS_VDP_DATA)
	nop
	inc	hl
	dec	bc
	in	a, (#SMS_VDP_DATA)
	
	ld	a, b
	or	c
	jp	nz, ._2
	
	ei
	ret

.multiSkip
	in	a, (#SMS_VDP_DATA)
	push	af
	pop	af
	in	a, (#SMS_VDP_DATA)
	nop
	dec	e
	jp	nz, .multiSkip
	jp	._5
}

PROC    :loadPalette                    SECTION ::main
        `====================================================================[$0566]===
PARAMS	a	`which palette(s) to set
		 `bit 0 - tile palette (0-15)
		 `bit 1 - sprite palette (16-31)
	hl	`address of palette
RETURN	#RAM_LOADPALETTE_TILE,
	#RAM_LOADPALETTE_SPRITE
{        
	push	af
	
	ld	b, 16			`we will copy 16 colours
	ld	c, 0			`beginning at palette index 0 (tiles)
	
	bit	0, a			`are we loading a tile palette?
	jr	z, ._1			`if no, skip ahead to the sprite palette
	
	ld	(#RAM_LOADPALETTE_TILE), hl
	call	.sendPalette		`send the palette colours to the VDP
	
._1	pop	af
	
	bit	1, a			`are we loading a sprite palette?
	ret	z			`if no, finish here
	
	`store the address of the sprite palette
	ld	(#RAM_LOADPALETTE_SPRITE), hl
	
	ld	b, 16			`we will copy 16 colours
	ld	c, 16			`beginning at palette index 16 (sprites)
	
	bit	0, a			`if loading both tile and sprite palette	
	jr	nz, .sendPalette	 `then stick with what we've set and do it
	
	`if loading sprite palette only, then ignore the first colour
	 `(I believe this has to do with the screen background colour being set from
	 ` the sprite palette?)
	inc	hl
	ld	b, 15			`copy 15 colours
	ld	c, 17			`to indexes 17-31, that is, skip no. 16
	
.sendPalette
	ld	a, c			`send the palette index number to begin at
	out	(#SMS_VDP_CONTROL), a
	ld	a, %11000000		`specify palette operation (bits 7 & 6)
	out	(#SMS_VDP_CONTROL), a
	ld	c, $BE			`send the colours to the palette
	otir
	ret
}

PROC    :clearVRAM                      SECTION ::main
        `====================================================================[$0595]===
        `called only by `::interrupts:init`
        
PARAMS	hl,	`VRAM address
	bc,	`length
	a	`value
{        
	ld	e, a
	ld	a, l
	out	(#SMS_VDP_CONTROL), a
	ld	a, h
	or	%01000000
	out	(#SMS_VDP_CONTROL), a
	
.loop	ld	a, e
	out	(#SMS_VDP_DATA), a
	dec	bc
	ld	a, b
	or	c
	jr	nz, .loop
	ret
}

PROC    :readJoypad                     SECTION ::main
        `====================================================================[$05A7]===
RETURN	iy+#vars.joypad
{       
	in	a, (#SMS_JOYPAD_1)	`read the joypad port
	or	%11000000		`mask out bits 7 & 6 - these are joypad 2
					 `down / up
	ld	(iy+#vars.joypad), a	`store the joypad value in $D203
	ret
}

PROC    :print                          SECTION ::main
        `====================================================================[$05AF]===
PARAMS	hl      `address to memory with column & row numbers,
{                `then data terminated with $FF
	`get the column number
	ld	c, (hl)
	inc	hl
	
	`the screen layout on the Master System is a 32x28 table of 16-bit values
	 `(64 bytes per row). we therefore need to multiply the row number by 64
	 `to get the right offset into the screen layout data
	ld	a, (hl)			`read the row number
	inc	hl
	
	`we multiply by 64 by first multiplying by 256 -- very simple, we just make
	 `the value the hi-byte in a 16-bit word, e.g. "$0C00" -- and then divide
	 `by 4 by rotating the bits to the right
	rrca				`divide by two
	rrca				`and again, making it four times
	
	ld	e, a
	and	%00111111		`strip off the rotated bits
	ld	d, a
	
	ld	a, e
	and	%11000000
	ld	e, a
	
	ld	b, $00
	ex	de, hl
	sla	c			`multiply column number by 2 (16-bit values)
	add	hl, bc
	ld	bc, #SMS_VDP_SCREENNAMETABLE
	add	hl, bc
	
	`set the VDP to point to the screen address calculated
	di
	ld	a, l
	out	(#SMS_VDP_CONTROL), a
	ld	a, h
	or	%01000000
	out	(#SMS_VDP_CONTROL), a
	ei

	`read bytes from memory until hitting $FF
.loop	ld	a, (de)
	cp	$FF
	ret	z
	
	out	(#SMS_VDP_DATA), a
	push	af			`kill time?
	pop	af
	ld	a, (#RAM_TEMP1)		`what to use as the tile upper bits
					 `(front/back, flip &c.)
	out	(#SMS_VDP_DATA), a
	inc	de
	djnz	.loop
	
	ret
}

PROC    :hideSprites                    SECTION ::main
        `====================================================================[$05E2]===
{        
	ld	hl, #RAM_SPRITETABLE
	ld	e, l
	ld	d, h
	ld	bc, 3 * 63		`three bytes (X/Y/I) for each sprite
	`set the first two bytes as 224 (X&Y position)
	ld	a, 224
	ld	(de), a
	inc	de
	ld	(de), a
	`then move forward another two bytes (skips the sprite index number)
	inc	de
	inc	de
	`copy 189 bytes from $D000 to $D003+ (up to $D0C0)
	ldir
	
	`set parameters so that at the next interrupt,
	 `all sprites will be hidden (see `updateVDPSprites`)
	 
	`mark all 64 sprites as requiring update 
	ld	(iy+#vars.spriteUpdateCount), 64	
	`and set zero active sprites
	xor	a			`(set A to 0)
	ld	(#RAM_ACTIVESPRITECOUNT), a
	ret
}

PROC    :decimalMultiplyBy10            SECTION ::main
        `====================================================================[$05FC]===
        `does a decimal multiplication by 10. e.g. 3 > 30
        
PARAMS	hl	`input number, e.g. RAM_LIVES
	c	`base? i.e. 10
{        
	xor	a			`set A to 0
	ld	b, 7			`we will be looping 7 times
	ex	de, hl			`transfer the HL parameter to DE
	ld	l, a			`set HL as $0000
	ld	h, a
	
.loop	rl	c			`shift the bits in C up one
	jp	nc, ._1			`skip if it hasn't overflowed yet
	add	hl, de			`add the parameter value
._1	add	hl, hl			`double the current value
	djnz	.loop
	
	`is there any carry remaining?
	or	c			`check if C is 0
	ret	z			`if so, no carry the number is final
	add	hl, de			`otherwise add one more
	ret
}

PROC    :_LABEL_60F_111                 SECTION ::main
        `====================================================================[$060F]===
        `convert to decimal? (used by Map & Act Complete screens for the lives number)
PARAMS	c	`10
	hl	`number of lives
{        
	xor	a			`set A to 0
	ld	b, 16
	
	`16-bit left-rotation -- that is, multiply by 2
.loop	rl	l
	rl	h
	rla				`if it goes above $FFFF, overflow into A
	
	cp	c			`check the overflow portion against C
	jp	c, ._1			`if less than 10, skip ahead
	sub	c			`-10
	
	`invert the carry flag. for values of A of 0-9, the carry will become 0,
	 `when A hits 10, the carry will become 1 and adds 1 to DE
._1	ccf
	
	`multiply DE by 2
	rl	e
	rl	d
	
	djnz	.loop
	
	`swap DE and HL:
	 `HL will be the number of 10s (in two's compliment?)
	ex	de, hl
	ret
}

PROC    :_LABEL_625_57                  SECTION ::main
        `====================================================================[$0625]===
        `random number generator?
{        
	push	hl
	push	de
	
	ld	hl, ($D2D7)
	ld	e, l
	ld	d, h
	add	hl, de			`x2
	add	hl, de			`x4
	
	ld	a, l
	add	a, h
	ld	h, a
	add	a, l
	ld	l, a
	
	ld	de, $0054
	add	hl, de
	ld	($D2D7), hl
	ld	a, h
	
	pop	de
	pop	hl
	ret
}

PROC    :updateCamera                   SECTION ::main
        `====================================================================[$063E]===
        `calculate the VDP scroll offset according to the camera position?
{        
	`fill B with vertical and C with horizontal VDP scroll values
	ld	bc,(#RAM_VDPSCROLL_HORIZONTAL)
	
	`------------------------------------------------------------------------------
	`has the camera scrolled left?
	ld	hl,(#RAM_CAMERA_X)
	ld	de,(#RAM_CAMERA_X_LEFT)
	and	a			`clear carry flag
	sbc	hl,de			`is `RAM_CAMERA_X_LEFT` > `RAM_CAMERA_X`?
	jr	c,._1			`jump if the camera has moved left
	
	`HL will contain the amount the screen has scrolled since the last time this
	 `function was called
	
	`camera moved right:
	ld	a,l
	add	a,c
	ld	c,a
	res	6,(iy+#vars.flags0)
	jp	._2
	
	`camera moved left:
._1	ld	a,l
	add	a,c
	ld	c,a
	set	6,(iy+#vars.flags0)
	
	`------------------------------------------------------------------------------
	`has the camera scrolled up?
	
._2	ld	hl,(#RAM_CAMERA_Y)
	ld	de,(#RAM_CAMERA_Y_UP)
	and	a			`clear carry flag
	sbc	hl,de			`is `RAM_CAMERA_Y_UP` > `RAM_CAMERA_Y`?
	jr	c,._4			`jump if the camera has moved up
	
	`camera moved down:
	ld	a,l
	add	a,b
	cp	224			`if greater than 224 (bottom of the screen)
	jr	c,._3
	add	a,32			`add 32 to wrap it around 256 back to 0+
._3	ld	b,a
	res	7,(iy+#vars.flags0)
	jp	._6
	
	`camera moved up:
._4	ld	a,l
	add	a,b
	cp	224
	jr	c,._5
	sub	32
._5	ld	b,a
	set	7,(iy+#vars.flags0)
	
	`------------------------------------------------------------------------------
	`update the VDP horizontal / vertical scroll values in the RAM,
	 `the interrupt routine will send the values to the chip
._6	ld	(#RAM_VDPSCROLL_HORIZONTAL),bc
	
	`get the number of blocks across / down the camera is located:
	 `we do this by multiplying the camera position by 8 and taking only the high
	 `byte (effectively dividing by 256) so that everything below 32 pixels of
	 `precision is lost
	
	ld	hl,(#RAM_CAMERA_X)
	sla	l			`x2 ...
	rl	h
	sla	l			`x4 ...
	rl	h
	sla	l			`x8
	rl	h
	ld	c,h			`take the high byte
	
	ld	hl,(#RAM_CAMERA_Y)
	sla	l			`x2 ...
	rl	h
	sla	l			`x4 ...
	rl	h
	sla	l			`x8
	rl	h
	ld	b,h			`take the high byte
	
	`now store the block X & Y counts
	ld	(#RAM_BLOCK_X),bc
	
	`update the left / up values now that the camera has moved
	ld	hl,(#RAM_CAMERA_X)
	ld	(#RAM_CAMERA_X_LEFT),hl
	ld	hl,(#RAM_CAMERA_Y)
	ld	(#RAM_CAMERA_Y_UP),hl
	
	ret
}

PROC    :fillOverscrollCache            SECTION ::main
        `====================================================================[$06BD]===
        ``this fills in the cache of the overscroll area so that when the screen
          scrolls onto new tiles, they can be copied across in a fast and
          straight-forward fashion``
{        
	`scrolling enabled??
	bit	5,(iy+#vars.flags0)
	ret	z
	
	di	
	`switch pages 1 & 2 ($4000-$BFFF) to banks 4 & 5 ($10000-$17FFF)
	ld	a,:S1_BlockMappings#bank
	ld	(#SMS_PAGE_1),a
	ld	(#RAM_PAGE_1),a
	ld	a,:S1_BlockMappings#bank+1
	ld	(#SMS_PAGE_2),a
	ld	(#RAM_PAGE_2),a
	ei	
	
	`------------------------------------------------------------------------------
	`get the address of the solidity data for the level's tilemap:
	
	ld	a,(#RAM_LEVEL_SOLIDITY)	`get the solidity index for the level
	add	a,a			`double it (for a pointer)
	ld	c,a			`and put it into a 16-bit number (BC)
	ld	b,$00
	
	`look up the index in the solidity pointer table
	ld	hl,:S1_SolidityPointers
	add	hl,bc
	
	`load an address at the table
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	
	`store the solidity data address in RAM
	ld	(#RAM_TEMP3),hl
	
	`------------------------------------------------------------------------------
	`horizontal scrolling allowed??
	bit	0,(iy+#vars.flags2)
	jp	z,.vert			`skip forward to vertical scroll handling
	
	`has the camera moved left?
	bit	6,(iy+#vars.flags0)
	jr	nz,.horz
	
	ld	b,$00
	ld	c,$08
	jp	._1

	`get the position in the floor layout (in RAM) of the camera:
	
.horz	ld	a,(#RAM_VDPSCROLL_HORIZONTAL)
	and	%00011111		`MOD 32 (i.e. 0-31 looping)
	add	a,8			`add 8 (ergo, 8-39)
	rrca				`divide by 2 ...
	rrca				`... 4
	rrca				`... 8
	rrca				`... 16
	rrca				`... 32
	and	%00000001		`remove everything but bit 0
	ld	b,$00			`load result into BC -- either $0000 or $0001
	ld	c,a

._1	call	:getFloorLayoutRAMPosition
	
	`------------------------------------------------------------------------------
	ld	a,(#RAM_VDPSCROLL_HORIZONTAL)
	
	`has the camera moved left?
	bit	6,(iy+#vars.flags0)
	jr	z,._2
	add	a,8
	
	`which of the four tiles width in a block is on the left-hand side of the
	 `screen - that is, determine which column within a block the camera is on
._2	and	%00011111		`MOD 32 (limit to how many pixels within block)
	srl	a			`divide by 2 ...
	srl	a			`divide by 4 ...
	srl	a			`divide by 8 (determine which tile, 0-3)
	ld	c,a			`copy the tile number (0-3) into BC
	ld	b,$00
	ld	(#RAM_TEMP1),bc		`stash it away for later
	
	exx	
	ld	de,#RAM_OVERSCROLLCACHE_HORZ
	exx	
	ld	de,(#RAM_LEVEL_FLOORWIDTH)
	
	ld	b,7
.loopH	ld	a,(hl)			`read a block index from the Floor Layout
	exx	
	ld	c,a
	ld	b,$00
	ld	hl,(#RAM_TEMP3)		`retrieve the solidity data address
	add	hl,bc			`offset the block index into the solidity data
	
	`multiply the block index by 16
	 `(blocks are each 16 bytes long)
	rlca				`x2 ...
	rlca				`x4 ...
	rlca				`x8 ...
	rlca				`x16
	ld	c,a
	and	%00001111		`MOD 16
	ld	b,a
	ld	a,c			`return to the block index * 16 value
	xor	b
	ld	c,a
	
	ld	a,(hl)			`read the solidity data for the block index
	rrca
	rrca	
	rrca	
	and	%00010000
	
	ld	hl,(#RAM_TEMP1)		`retrieve the column number of the VSP scroll
	add	hl,bc
	ld	bc,(#RAM_BLOCKMAPPINGS)	`get the address of the level's block mappings
	add	hl,bc
	ld	bc,4
	ldi				`copy the first byte
	
	ld	(de),a
	inc	e
	add	hl,bc
	ldi	
	
	ld	(de),a
	inc	e
	inc	c
	add	hl,bc
	ldi	
	
	ld	(de),a
	inc	e
	inc	c
	add	hl,bc
	ldi	
	
	ld	(de),a
	inc	e
	
	exx	
	add	hl,de
	djnz	.loopH
	
	`------------------------------------------------------------------------------
.vert	bit	1,(iy+#vars.flags2)
	jp	z,.exit
	bit	7,(iy+#vars.flags0)	`camera moved up?
	jr	nz,._3
	ld	b,$06
	ld	c,$00
	jp	._4
	
._3	ld	b,$00
	ld	c,b
	
	`------------------------------------------------------------------------------
._4	call	:getFloorLayoutRAMPosition
	ld	a,(#RAM_VDPSCROLL_VERTICAL)
	and	%00011111
	srl	a
	and	%11111100
	ld	c,a
	ld	b,$00
	ld	(#RAM_TEMP1),bc
	exx	
	ld	de,#RAM_OVERSCROLLCACHE_VERT
	exx	
	ld	b,$09

.loopV	ld	a,(hl)
	exx	
	ld	c,a
	ld	b,$00
	ld	hl,(#RAM_TEMP3)
	add	hl,bc
	rlca	
	rlca	
	rlca	
	rlca	
	ld	c,a
	and	%00001111
	ld	b,a
	ld	a,c
	xor	b
	ld	c,a
	ld	a,(hl)
	rrca	
	rrca	
	rrca	
	and	%00010000
	ld	hl,(#RAM_TEMP1)
	add	hl,bc
	ld	bc,(#RAM_BLOCKMAPPINGS)
	add	hl,bc
	ldi	
	ld	(de),a
	inc	e
	ldi	
	ld	(de),a
	inc	e
	ldi	
	ld	(de),a
	inc	e
	ldi	
	ld	(de),a
	inc	e
	exx	
	inc	hl
	djnz	.loopV
	
.exit	ret
}

PROC    :fillScrollTiles                SECTION ::main
        `====================================================================[$07DB]===
        `fill in new tiles when the screen has scrolled
{        
	bit	0, (iy+#vars.flags2)
	jp	z, ._4
	
	exx
	push	hl;stack
	push	de;stack
	push	bc;stack
	
	`------------------------------------------------------------------------------
	`calculate the number of bytes to offset by to get to the correct row in the
	 `screen table
	
	ld	a;scrollVert, (#RAM_VDPSCROLL_VERTICAL)
	and	%11111000		`round the scroll to the nearest 8 pixels
	
	`multiply the vertical scroll offset by 8. since the scroll offset is already
	 `a multiple of 8, this will give you 64 bytes per screen row (32 16-bit tiles)
	ld	b, $00
	add	a, a			`x2
	rl	b
	add	a, a			`x4
	rl	b
	add	a, a			`x8
	rl	b
	ld	c, a
	
	`------------------------------------------------------------------------------
	`calculate the number of bytes to get from the beginning of a row to the 
	 `horizontal scroll position
	
	ld	a;scrollHorz, (#RAM_VDPSCROLL_HORIZONTAL)
	
	bit	6, (iy+#vars.flags0)	`camera moved left?
	jr	z, ._1
	add	a;scrollHorz, 8		`add 8 pixels (left screen border?)
._1	and	%11111000		`and then round to the nearest 8 pixels
	
	srl	a			`divide by 2 ...
	srl	a			`divide by 4
	add	a, c
	ld	c, a
	
	ld	hl, #SMS_VDP_SCREENNAMETABLE
	add	hl, bc			`offset to the top of the column needed
	set	6, h			`add bit 6 to label as a VDP VRAM address
	
	ld	bc, 64			`there are 32 tiles (16-bit) per screen-width
	ld	d, $3F|%01000000	`upper limit of the screen table
					 `(bit 6 is set as it is a VDP VRAM address)
	ld	e, 7
	
	`------------------------------------------------------------------------------
	exx
	ld	hl, #RAM_OVERSCROLLCACHE_HORZ
	
	`find where in a block the scroll offset sits (this is needed to find which
	 `of the 4 tiles width in a block have to be referenced)
	ld	a, (#RAM_VDPSCROLL_VERTICAL)
	and	%00011111		`MOD 32
	srl	a			`divide by 2 ...
	srl	a			`divide by 4 ...
	srl	a			`divide by 8
	ld	c, a			`load this into BC
	ld	b, $00
	add	hl, bc			`add twice to HL
	add	hl, bc
	ld	b, $32			`set BC to $BE32
	ld	c, $BE			 `(purpose unknown)
	
	`set the VDP address calculated earlier
._2	exx
	ld	a, l
	out	(#SMS_VDP_CONTROL), a
	ld	a, h
	out	(#SMS_VDP_CONTROL), a
	
	`move to the next row
	add	hl, bc
	ld	a, h
	cp	d			`don't go outside the screen table
	jp	nc, ._10
	
._3	exx
	outi				`send the tile index
	outi				`send the tile meta
	jp	nz, ._2
	
	exx
	pop	bc
	pop	de
	pop	hl
	exx
	
	`------------------------------------------------------------------------------
._4	bit	1, (iy+#vars.flags2)
	jp	z, .exit		`could  optimise to `ret z`?
	ld	a, (#RAM_VDPSCROLL_VERTICAL)
	ld	b, $00
	srl	a
	srl	a
	srl	a
	bit	7, (iy+#vars.flags0)	`camera moved up?
	jr	nz, ._5
	add	a, $18
._5	cp	$1C
	jr	c, ._6
	sub	$1C
._6	add	a, a
	add	a, a
	add	a, a
	add	a, a
	rl	b
	add	a, a
	rl	b
	add	a, a
	rl	b
	ld	c, a
	ld	a, (#RAM_VDPSCROLL_HORIZONTAL)
	add	a, $08
	and	%11111000
	srl	a
	srl	a
	add	a, c
	ld	c, a
	ld	hl, #SMS_VDP_SCREENNAMETABLE
	add	hl, bc
	set	6, h
	ex	de, hl
	ld	hl, #RAM_OVERSCROLLCACHE_VERT
	ld	a, (#RAM_VDPSCROLL_HORIZONTAL)
	and	%00011111
	add	a, $08
	srl	a
	srl	a
	srl	a
	ld	c, a
	ld	b, $00
	add	hl, bc
	add	hl, bc
	ld	a, e
	and	%11000000
	ld	(#RAM_TEMP1), a
	ld	a, e
	out	(#SMS_VDP_CONTROL), a
	and	$3F
	ld	e, a
	ld	a, d
	out	(#SMS_VDP_CONTROL), a
	ld	b, $3E
	ld	c, $BE

._7	bit	6, e
	jr	nz, ._8
	inc	e
	inc	e
	outi
	outi
	jp	nz, ._7
	ret

._8	ld	a, (#RAM_TEMP1)
	out	(#SMS_VDP_CONTROL), a
	ld	a, d
	out	(#SMS_VDP_CONTROL), a
	
._9	outi
	outi
	jp	nz, ._9

.exit	ret

	`------------------------------------------------------------------------------
._10	sub	e
	ld	h, a
	jp	._3
}

PROC    :getFloorLayoutRAMPosition      SECTION ::main
        `====================================================================[$07D5]===
        `convert block X & Y coords into a location in the Floor Layout in RAM
PARAMS  bc	`a flag, $0000 or $0001 depending on callee
{        
	`get the low-byte of the width of the level in blocks. many levels are 256
	 `blocks wide, ergo have a FloorWidth of $0100, making the low-byte $00
	ld	a,(#RAM_LEVEL_FLOORWIDTH)
	rlca				`double it (x2)
	jr	c,._1			`>128?
	rlca				`double it again (x4)
	jr	c,._2			`>64?
	rlca				`double it again (x8)
	jr	c,._3			`>32?
	rlca				`double it again (x16)
	jr	c,._4			`>16?
	jp	._5			`255...?
	
	`------------------------------------------------------------------------------
._1	ld	a,(#RAM_BLOCK_Y)
	add	a,b
	ld	e,$00
	srl	a			`divide by 2
	rr	e
	ld	d,a
	
	ld	a,(#RAM_BLOCK_X)
	add	a,c
	add	a,e
	ld	e,a
	
	ld	hl,#RAM_FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
._2	ld	a,(#RAM_BLOCK_Y)
	add	a,b
	ld	e,$00
	srl	a
	rr	e
	srl	a
	rr	e
	ld	d,a
	
	ld	a,(#RAM_BLOCK_X)
	add	a,c
	add	a,e
	ld	e,a
	
	ld	hl,#RAM_FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
._3	ld	a,(#RAM_BLOCK_Y)
	add	a,b
	ld	e,$00
	srl	a
	rr	e
	srl	a
	rr	e
	srl	a
	rr	e
	ld	d,a
	ld	a,(#RAM_BLOCK_X)
	add	a,c
	add	a,e
	ld	e,a
	
	ld	hl,#RAM_FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
._4	ld	a,(#RAM_BLOCK_Y)
	add	a,b
	ld	e,$00
	srl	a
	rr	e
	srl	a
	rr	e
	srl	a
	rr	e
	srl	a
	rr	e
	ld	d,a
	ld	a,(#RAM_BLOCK_X)
	add	a,c
	add	a,e
	ld	e,a
	
	ld	hl,#RAM_FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
._5	ld	a,(#RAM_BLOCK_Y)
	add	a,b
	ld	d,a
	ld	a,(#RAM_BLOCK_X)
	add	a,c
	ld	e,a
	
	ld	hl,#RAM_FLOORLAYOUT
	add	hl,de
	ret
}

PROC    :fillScreenWithFloorLayout      SECTION ::main
        `====================================================================[$0966]===
        ``this routine is only called during level loading to populate the screen with
          the visible portion of the Floor Layout. Scrolling fills in the new tiles so
          a full refresh of the screen is not required``
{        
	`page in banks 4 & 5 (containing the block mappings)
	di				`disable interrupts
	ld	a,:S1_BlockMappings#bank
	ld	(#SMS_PAGE_1),a
	ld	(#RAM_PAGE_1),a
	ld	a,:S1_BlockMappings#bank + 1
	ld	(#SMS_PAGE_2),a
	ld	(#RAM_PAGE_2),a
	
	ld	bc,$0000
	call	:getFloorLayoutRAMPosition
	
	`------------------------------------------------------------------------------
	ld	de,#SMS_VDP_SCREENNAMETABLE
	`in 192-line mode, the screen is 6 blocks tall,
	 `in 224-line mode it's 7 blocks tall
	ld	b,#SMS_SCREENHEIGHT_BLOCKS
	
._1	push	bc
	push	hl
	push	de
	ld	b,8			`the screen is 8 blocks wide
	
._2	push	bc
	push	hl
	push	de
	
	`get the block index at the current location in the Floor Layout
	ld	a,(hl)
	
	exx	
	ld	e,a			`copy the block index to E'
	ld	a,(#RAM_LEVEL_SOLIDITY)	`now load A with the level's solidity index
	add	a,a			`double it (i.e. for a 16-bit pointer)
	ld	c,a			`put it into BC'
	ld	b,$00
	ld	hl,:S1_SolidityPointers	`get the address of the solidity pointer list
	add	hl,bc			`offset the solidity index into the list
	ld	a,(hl)			`read the data pointer into HL'
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	d,$00			`DE' is the block index
	add	hl,de			`offset the block index into the solidity data
	ld	a,(hl)			`and get the solidity value
	
	`in the solidity data, bit 7 determines that the tile should appear in front
	 `of sprites. rotate the byte three times to position bit 7 at bit 4. 
	 `this byte will form the high-byte of the 16-bit value for the name table
	 `entry (bit 4 will therefore become bit 12)
	rrca
	rrca
	rrca
	
	`bit 12 of a name table entry specifies if the tile should appear in front of 
	 `sprites. allow just this bit if it's set
	and	%00010000
	ld	c,a
	exx
	
	`return the block index to HL
	ld	l,(hl)
	ld	h,$00
	`block mappings are 16 bytes each
	add	hl,hl			`x2 ...
	add	hl,hl			`x4 ...
	add	hl,hl			`x8 ...
	add	hl,hl			`x16
	ld	bc,(#RAM_BLOCKMAPPINGS)
	add	hl,bc
	
	`DE will be the address of block mapping
	`HL will be an address in the screen name table
	ex	de,hl
	
	`------------------------------------------------------------------------------
	ld	b,4			`4 rows of the block mapping
	
	`set the screen name address
._3	ld	a,l
	out	(#SMS_VDP_CONTROL),a
	ld	a,h
	or	%01000000
	out	(#SMS_VDP_CONTROL),a
	
	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	inc	de
	exx	
	ld	a,c
	exx	
	out	(#SMS_VDP_DATA),a
	nop	
	nop	
	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	inc	de
	exx	
	ld	a,c
	exx	
	out	(#SMS_VDP_DATA),a
	nop	
	nop	
	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	inc	de
	exx	
	ld	a,c
	exx	
	out	(#SMS_VDP_DATA),a
	nop	
	nop	
	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	inc	de
	exx	
	ld	a,c
	exx	
	out	(#SMS_VDP_DATA),a
	ld	a,b
	ld	bc,64
	add	hl,bc
	ld	b,a
	djnz	._3
	
	pop	de
	pop	hl
	inc	hl
	ld	bc,$0008
	ex	de,hl
	add	hl,bc
	ex	de,hl
	pop	bc
	djnz	._2
	
	pop	de
	pop	hl
	ld	bc,(#RAM_LEVEL_FLOORWIDTH)
	add	hl,bc
	ex	de,hl
	ld	bc,$0100
	add	hl,bc
	ex	de,hl
	pop	bc
	dec	b
	jp	nz,._1
	
	ei				`enable interrupts
	ret
}

PROC    :loadFloorLayout                SECTION ::main
        `====================================================================[$0A10]===
PARAMS	hl	`address of Floor Layout data
	bc	`length of compressed data
{        
	ld	de,#RAM_FLOORLAYOUT	`where in RAM the floor layout will go

	`RLE decompress floor layout:
	`------------------------------------------------------------------------------
._1	ld	a,(hl)		`read the first byte of the floor layout
	cpl			`flip it to avoid first byte comparison
	ld	(iy+$01),a	`this is the comparison byte

._2	ld	a,(hl)		`read the current byte
	cp	(iy+$01)	`is it the same as the comparison byte?
	jr	z,._3		`if so, decompress it
	
	`copy byte as normal:
	ld	(de),a		`write it to RAM	
	ld	(iy+$01),a	`update the comparison byte
	inc	hl		`move forward
	inc	de
	dec	bc		`count count of remaining bytes
	ld	a,b		`are there remaining bytes?
	or	c
	jp	nz,._2		`if so continue
	ret 			`otherwise, finish

	`if the last two bytes of the data are duplicates, don't try decompress
	 `further when there is no more data to be read!
._3	dec	bc		`reduce count of remaining bytes
	ld	a,b		`are there remaining bytes?
	or	c
	ret	z		`if not, finish
	
	ld	a,(hl)		`read the value to repeat
	inc	hl		`move to the next byte (the repeat count)
	push	bc		`put BC (length of compressed data) to the side
	ld	b,(hl)		`get the repeat count
	
._4	ld	(de),a		`write value to RAM
	inc	de		`move forward in RAM
	djnz	._4		`continue until repeating is complete
	
	pop	bc		`retrieve the data length
	inc	hl		`move forward in the compressed data
	
	`check if bytes remain
	dec	bc
	ld	a,b
	or	c
	jp	nz,._1
	ret
}

PROC    :fadeOut                        SECTION ::main
        `====================================================================[$0A40]===
{        
	ld	a, 1
	ld	(#SMS_PAGE_1), a
	ld	(#RAM_PAGE_1), a
	ld	a, 2
	ld	(#SMS_PAGE_2), a
	ld	(#RAM_PAGE_2), a
	
	ld	a, (iy+#vars.spriteUpdateCount)
	res	0, (iy+#vars.flags0)	`wait for interrupt to occur
	call	:waitForInterrupt	 `(refresh sprites?)
	
	`after the interrupt, the sprite update count would be cleared,
	 `put it back to its old value
	ld	(iy+#vars.spriteUpdateCount), a
	ld	b, $04
	
._1	push	bc			`put aside the loop counter
		
	`fade out the tile palette one step
	ld	hl, (#RAM_LOADPALETTE_TILE)
	ld	de, #RAM_PALETTE
	ld	b, 16
	call	:darkenPalette
	
	`fade out the sprite palette one step
	ld	hl, (#RAM_LOADPALETTE_SPRITE)
	ld	b, 16
	call	:darkenPalette
	
	`load the darkened palette on the next interrupt
	ld	hl, #RAM_PALETTE
	ld	a, %00000011
	call	:loadPaletteOnInterrupt
	
	`wait 10 frames
	ld	b, $0A
._2 	ld	a, (iy+#vars.spriteUpdateCount)
		
	res	0, (iy+#vars.flags0)
	call	:waitForInterrupt
	
	ld	(iy+#vars.spriteUpdateCount), a
	djnz	._2

	pop	bc			`retrieve the loop counter
	djnz	._1			 `before looping back
	
	ret
}

PROC    :darkenPalette                  SECTION ::main
        `--------------------------------------------------------------------[$0A90]---
        `fades a palette one step darker
        
PARAMS	hl	`source palette address
	de	`destination palette address (RAM)
	b	`length of palette (16)
{     
	`NOTE: SMS colours are in the format: 00BBGGRR
	
	ld	a, (hl)			`read the colour
	and	%00000011		`does it have any red component?
	jr	z, ._1			`if not, skip ahead			
	dec	a			`reduce the red brightness by 1
	
._1	ld	c, a
	ld	a, (hl)
	and	%00001100		`does it have any green component?
	jr	z, ._2			`if not, skip ahead
	sub	%00000100		`reduce the green brightness by 1
	
._2	or	c			`merge the green component back in
	ld	c, a			`put aside the current colour code
	ld	a, (hl)			`fetch the original colour code again
	and	%00110000		`does it have any blue component?
	jr	z, ._3			`if not, skip ahead
	sub	%00010000		`reduce the blue brightness by 1
	
._3	or	c			`merge the blue component back in
	ld	(de), a			`update the palette colour
	
	`move to the next palette colour and repeat
	inc	hl
	inc	de
	djnz	:
	
	ret
}

PROC    :_aae                           SECTION ::main
        `====================================================================[$0AAE]===
PARAMS  hl
{
        ld	(#RAM_TEMP6),hl
	
	`------------------------------------------------------------------------------
	`copy parameter palette into the temporary RAM palette used for fading out
	
	ld	hl,(#RAM_LOADPALETTE_TILE)
	ld	de,#RAM_PALETTE
	ld	bc,32
	ldir	
	
	ld	a,1
	ld	(#SMS_PAGE_1),a
	ld	(#RAM_PAGE_1),a
	ld	a,2
	ld	(#SMS_PAGE_2),a
	ld	(#RAM_PAGE_2),a
	
	`switch to using the temporary palette on screen
	ld	hl,#RAM_PALETTE
	ld	a,%00000011
	call	:loadPaletteOnInterrupt
	
	`------------------------------------------------------------------------------
	ld	c,(iy+#vars.spriteUpdateCount)
	ld	a,(#RAM_VDPREGISTER_1)
	or	%01000000		`enable screen (bit 6 of VDP register 1)
	ld	(#RAM_VDPREGISTER_1),a
	
	`wait for interrupt (refresh screen)
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	
	ld	(iy+#vars.spriteUpdateCount),c
	
	`wait for 9 more frames
	ld	b,$09
._1	ld	a,(iy+#vars.spriteUpdateCount)
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	ld	(iy+#vars.spriteUpdateCount),a
	djnz	._1
	
	`fade palette
	 `(why is this not just calling `darkenPalette`?)
	
	ld	b,4
._2	push	bc
	ld	hl,(#RAM_TEMP6)		`restore the HL parameter
	ld	de,#RAM_PALETTE
	ld	b,32

._3	push	bc
	ld	a,(hl)
	and	%00000011
	ld	b,a
	ld	a,(de)
	and	%00000011
	cp	b
	jr	z,._4
	dec	a
._4	ld	c,a
	ld	a,(hl)
	and	%00001100
	ld	b,a
	ld	a,(de)
	and	%00001100
	cp	b
	jr	z,._5
	sub	%00000100
._5	or	c
	ld	c,a
	ld	a,(hl)
	and	%00110000
	ld	b,a
	ld	a,(de)
	and	%00110000
	cp	b
	jr	z,._6
	sub	%00010000
._6	or	c
	ld	(de),a
	inc	hl
	inc	de
	pop	bc
	djnz	._3
	
	ld	hl,#RAM_PALETTE
	ld	a,%00000011
	call	:loadPaletteOnInterrupt
	
	`wait for 10 frames
	ld	b,$0a
._7	ld	a,(iy+#vars.spriteUpdateCount)
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	ld	(iy+#vars.spriteUpdateCount),a
	djnz	._7
	
	pop	bc
	djnz	._2
	ret
}

PROC    :_b50                           SECTION ::main
        `====================================================================[$0B50]===
        `erase RAM_PALETTE?
{        
	ld	(#RAM_TEMP6),hl
	ld	hl,#RAM_PALETTE
	ld	b,32
	
.loop	ld	(hl),$00
	inc	hl
	djnz	.loop
	
	jp	:_b60._1
}

PROC    :_b60 SECTION ::main
        `--------------------------------------------------------------------[$0B60]---
{                
	ld	(#RAM_TEMP6),hl
	
	ld	hl,(#RAM_LOADPALETTE_TILE)
	ld	de,#RAM_PALETTE
	ld	bc,32
	ldir	
	
._1	ld	a,1
	ld	(#SMS_PAGE_1),a
	ld	(#RAM_PAGE_1),a
	ld	a,2
	ld	(#SMS_PAGE_2),a
	ld	(#RAM_PAGE_2),a
	
	ld	hl,#RAM_PALETTE
	ld	a,%00000011
	call	:loadPaletteOnInterrupt
	
	ld	c,(iy+#vars.spriteUpdateCount)
	ld	a,(#RAM_VDPREGISTER_1)
	or	$40
	ld	(#RAM_VDPREGISTER_1),a
	
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	
	ld	(iy+#vars.spriteUpdateCount),c
	ld	b,$09
	
._2	ld	a,(iy+#vars.spriteUpdateCount)
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	ld	(iy+#vars.spriteUpdateCount),a
	djnz	._2
	
	ld	b,$04
	
._3	push	bc
	ld	hl,(#RAM_TEMP6)
	ld	de,#RAM_PALETTE
	ld	b,32
	
._4	push	bc
	ld	a,(hl)
	and	$03
	ld	b,a
	ld	a,(de)
	and	$03
	cp	b
	jr	nc,._5
	inc	a
._5	ld	c,a
	ld	a,(hl)
	and	$0c
	ld	b,a
	ld	a,(de)
	and	$0c
	cp	b
	jr	nc,._6
	add	a,$04	
._6	or	c
	ld	c,a
	ld	a,(hl)
	and	$30
	ld	b,a
	ld	a,(de)
	and	$30
	cp	b
	jr	nc,._7
	add	a,$10
._7	or	c
	ld	(de),a
	inc	hl
	inc	de
	pop	bc
	djnz	._4
	
	ld	hl,#RAM_PALETTE
	ld	a,%00000011
	call	:loadPaletteOnInterrupt
	
	ld	b,10
._8	ld	a,(iy+#vars.spriteUpdateCount)
	res	0,(iy+#vars.flags0)
	call	:waitForInterrupt
	ld	(iy+#vars.spriteUpdateCount),a
	djnz	._8
	
	pop	bc
	djnz	._3
	ret
}

PROC    :getLevelBitFlag                SECTION ::main
        `====================================================================[$0C02]===
PARAMS  hl	`an address to a series of 19 bits, one for each level
		 `$D305+: set by life monitor
		 `$D30B+: set by emerald
		 `$D311+: set by continue monitor
		 `$D317+: set by switch
{       
	ld	a, (#RAM_CURRENT_LEVEL)
	ld	c, a
	srl	a			`divide by 2 ...
	srl	a			`divide by 4 ...
	srl	a			`divide by 8
	
	`put the result into DE
	ld	e, a
	ld	d, $00
	`add that to the parameter (e.g. $D311)
	add	hl, de
	
	ld	a, c			`return to the current level number
	ld	c, 1
	and	%00000111		`MOD 8
	ret	z			`if level 0, 8, 16, ... then return C = 1
	ld	b, a			`B = 1-7
	ld	a, c			`1
	
	`slide the bit up the byte between 0-7 depending on the level number
.loop	rlca
	djnz	.loop
	ld	c, a			`return via C
	
	`HL : address to the byte where the bit exists
	` C : the bit mask, e.g. 1, 2, 4, 8, 16, 32, 64 or 128
	ret
}

PROC    :loadPowerUpIcon                SECTION ::main
        `====================================================================[$0C1D]===
        `copy power-up icon into sprite VRAM
        
PARAMS	hl	`absolute address to uncompressed art data for the icons,
		`assuming that slot 1 ($4000-$7FFF) is loaded with bank 5
		`($14000-$17FFF)
{        
	di	
	ld	a,5			`temporarily switch to bank 5 for the function
	ld	(#SMS_PAGE_1),a
	
	ld	a,(#RAM_FRAMECOUNT)
	and	%00001111
	add	a,a			`x2
	add	a,a			`x4
	add	a,a			`x8
	ld	e,a			`put it into DE
	ld	d,$00
	add	hl,de			`offset into HL parameter
	
	ex	de,hl
	ld	bc,$2B80
	
	add	hl,bc
	ld	a,l
	out	(#SMS_VDP_CONTROL),a
	ld	a,h
	or	%01000000
	out	(#SMS_VDP_CONTROL),a
	
	ld	b,4
.loop	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	nop	
	nop	
	inc	de
	ld	a,(de)
	out	(#SMS_VDP_DATA),a
	inc	de
	djnz	.loop
	
	`return to the previous bank number
	ld	a,(#RAM_PAGE_1)
	ld	(#SMS_PAGE_1),a
	ei	
	ret
}