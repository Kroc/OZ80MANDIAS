`` Sonic 1 Master System Disassembly
   created by Kroc Camen <kroc@camendesign.com>
   for MaSS1VE: The Master System Sonic 1 Visual Editor <github.com/Kroc/MaSS1VE>
   ================================================================================= ``

TABLE :S1_Object_Pointers                       SECTION ::mobs                  `$2AF6
{
.sonic	
        WORD    :mob_Sonic		        `#00: Sonic
.powerUp_ring
        WORD    :mob_powerUp_ring		`#01: monitor - ring
        WORD    :mob_powerUp_speed              `#02: monitor - speed shoes
        WORD    :mob_powerUp_life		`#03: monitor - life
        WORD    :mob_powerUp_shield	        `#04: monitor - shield
        WORD    :mob_powerUp_invincibility      `#05: monitor - invincibility
        WORD    :mob_powerUp_emerald	        `#06: chaos emerald
        WORD    :mob_boss_endSign	        `#07: end sign
        WORD    :mob_badnick_crabMeat	        `#08: badnick - crabmeat
        WORD    :mob_platform_swinging	        `#09: wooden platform - swinging (Green Hill)
        WORD    :mob_explosion		        `#0A: explosion
        WORD    :mob_platform		        `#0B: wooden platform (Green Hill)
        WORD    :mob_platform_weight	        `#0C: wooden platform - falling (Green Hill)
        WORD    :_6ac1				`#0D: UNKNOWN
        WORD    :mob_badnick_buzzBomber	        `#0E: badnick - buzz bomber
        WORD    :mob_platform_leftRight	        `#0F: wooden platform - moving (Green Hill)
        WORD    :mob_badnick_motobug	        `#10: badnick - motobug
        WORD    :mob_badnick_newtron	        `#11: badnick - newtron
        WORD    :mob_boss_greenHill	        `#12: boss (Green Hill)
        WORD    :_9b75				`#13: UNKNOWN - bullet?
        WORD    :_9be8				`#14: UNKNOWN - fireball right?
        WORD    :_9c70				`#15: UNKNOWN - fireball left?
        WORD    :mob_trap_flameThrower	        `#16: flame thrower (Scrap Brain)
        WORD    :mob_door_left		        `#17: door - one way left (Scrap Brain)
        WORD    :mob_door_right		        `#18: door - one way right (Scrap Brain)
        WORD    :mob_door			`#19: door (Scrap Brain)
        WORD    :mob_trap_electric	        `#1A: electric sphere (Scrap Brain)
        WORD    :mob_badnick_ballHog	        `#1B: badnick - ball hog (Scrap Brain)
        WORD    :_a33c				`#1C: UNKNOWN - ball from ball hog?
        WORD    :mob_switch		        `#1D: switch
        WORD    :mob_door_switchActivated	`#1E: switch door
        WORD    :mob_badnick_caterkiller	`#1F: badnick - caterkiller
        WORD    :_96f8				`#20: UNKNOWN
        WORD    :mob_platform_bumper	        `#21: moving bumper (Special Stage)
        WORD    :mob_boss_scrapBrain	        `#22: boss (Scrap Brain)
        WORD    :mob_boss_freeRabbit	        `#23: free animal - rabbit
        WORD    :mob_boss_freeBird	        `#24: free animal - bird
        WORD    :mob_boss_capsule		`#25: capsule
        WORD    :mob_badnick_chopper	        `#26: badnick - chopper
        WORD    :mob_platform_fallVert	        `#27: log - vertical (Jungle)
        WORD    :mob_platform_fallHoriz	        `#28: log - horizontal (Jungle)
        WORD    :mob_platform_roll	        `#29: log - floating (Jungle)
        WORD    :_96a8				`#2A: UNKNOWN
        WORD    :_8218				`#2B: UNKNOWN
        WORD    :mob_boss_jungle		`#2C: boss (Jungle)
        WORD    :mob_badnick_yadrin	        `#2D: badnick - yadrin (Bridge)
        WORD    :mob_platform_bridge	        `#2E: falling bridge (Bridge)
        WORD    :_94a5				`#2F: UNKNOWN - wave moving projectile?
        WORD    :mob_meta_clouds		`#30: meta - clouds (Sky Base)
        WORD    :mob_trap_propeller	        `#31: propeller (Sky Base)
        WORD    :mob_badnick_bomb		`#32: badnick - bomb (Sky Base)
        WORD    :mob_trap_cannon		`#33: cannon (Sky Base)
        WORD    :mob_trap_cannonBall	        `#34: cannon ball (Sky Base)
        WORD    :mob_badnick_unidos	        `#35: badnick - unidos (Sky Base)
        WORD    :_b0f4				`#36: UNKNOWN - stationary, lethal
        WORD    :mob_trap_turretRotating	`#37: rotating turret (Sky Base)
        WORD    :mob_platform_flyingRight	`#38: flying platform (Sky Base)
        WORD    :_b398				`#39: moving spiked wall (Sky Base)
        WORD    :mob_trap_turretFixed	        `#3A: fixed turret (Sky Base)
.platform_flyingUpDown
        WORD    :mob_platform_flyingUpDown      `#3B: flying platform - up/down (Sky Base)
        WORD    :mob_badnick_jaws		`#3C: badnick - jaws (Labyrinth)
        WORD    :mob_trap_spikeBall	        `#3D: spike ball (Labyrinth)
        WORD    :mob_trap_spear		        `#3E: spear (Labyrinth)
        WORD    :mob_trap_fireball	        `#3F: fire ball head (Labyrinth)
        WORD    :mob_meta_water		        `#40: meta - water line position
        WORD    :mob_powerUp_bubbles	        `#41: bubbles (Labyrinth)
        WORD    :_8eca				`#42: UNKNOWN
        WORD    :mob_null			`#43: NO-CODE
        WORD    :mob_badnick_burrobot	        `#44: badnick - burrobot
        WORD    :mob_platform_float	        `#45: platform - float up (Labyrinth)
        WORD    :mob_boss_electricBeam	        `#46: boss - electric beam (Sky Base)
        WORD    :_bcdf				`#47: UNKNOWN
        WORD    :mob_boss_bridge		`#48: boss (Bridge)
        WORD    :mob_boss_labyrinth	        `#49: boss (Labyrinth)
        WORD    :mob_boss_skyBase		`#4A: boss (Sky Base)
        WORD    :mob_meta_trip		        `#4B: trip zone (Green Hill)
        WORD    :mob_platform_flipper	        `#4C: Flipper (Special Stage)
        WORD    $0000				`#4D: RESET!
        WORD    :mob_platform_balance	        `#4E: balance (Bridge)
        WORD    $0000				`#4F: RESET!
        WORD    :mob_flower		        `#50: flower (Green Hill)
        WORD    :mob_powerUp_checkpoint	        `#51: monitor - checkpoint
        WORD    :mob_powerUp_continue	        `#52: monitor - continue
        WORD    :mob_anim_final		        `#53: final animation
        WORD    :mob_anim_emeralds	        `#54: all emeralds animation
        WORD    :_7b95				`#55: "make sonic blink"
}

`______________________________________________________________________________________

TABLE   :_2ba2                                  SECTION ::mobs                  `$2BA2
{
        BYTE    $00 $01 $00 $02
        BYTE    $00 $01 $00 $02 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $60 $00 $E0 $00 $10 $00 $10 $01
        BYTE    $20 $00 $E0 $00 $A0 $00 $A0 $01 $40 $00 $00 $01 $40 $00 $40 $01
        BYTE    $40 $00 $00 $01 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $30 $00 $F0 $00 $00 $01 $00 $02 $00 $01 $C0 $01 $40 $00 $40 $01
        BYTE    $40 $00 $00 $01 $A0 $00 $A0 $01 $20 $00 $E0 $00 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $10 $00 $10 $01 $10 $00 $D0 $00 $C0 $00 $C0 $01
        BYTE    $80 $00 $40 $01 $20 $00 $20 $01 $20 $00 $E0 $00 $08 $00 $40 $01
        BYTE    $10 $00 $D0 $00 $40 $00 $08 $01 $10 $00 $D0 $00 $10 $00 $10 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $30 $00 $CC $00 $20 $00 $20 $01
        BYTE    $30 $00 $CC $00 $20 $00 $20 $01 $30 $00 $CC $00 $20 $00 $20 $01
        BYTE    $20 $00 $DA $00 $30 $00 $30 $01 $30 $00 $F0 $00 $00 $01 $80 $01
        BYTE    $00 $01 $C0 $01 $10 $00 $10 $01 $10 $00 $D0 $00 $20 $00 $20 $01
        BYTE    $30 $00 $C8 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $80 $00 $40 $01 $10 $00 $10 $01
        BYTE    $80 $00 $F0 $00 $20 $00 $20 $01 $10 $00 $D0 $00 $20 $00 $20 $01
        BYTE    $10 $00 $D0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $10 $00 $10 $01
        BYTE    $60 $00 $00 $01 $28 $00 $28 $01 $00 $01 $C0 $01 $28 $00 $28 $01
        BYTE    $00 $01 $C0 $01 $10 $00 $10 $01 $10 $00 $D0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $10 $00 $10 $01 $10 $00 $D0 $00 $40 $00 $40 $01
        BYTE    $C0 $00 $80 $01 $10 $00 $10 $01 $10 $00 $D0 $00 $80 $00 $80 $01
        BYTE    $40 $00 $C0 $01 $20 $00 $20 $01 $20 $00 $E0 $00 $00 $08 $00 $08
        BYTE    $30 $00 $F0 $00 $10 $00 $10 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $00 $00 $00 $01 $00 $00 $C0 $00 $00 $02 $00 $03
        BYTE    $00 $02 $C0 $02 $10 $00 $10 $01 $10 $00 $D0 $00 $40 $00 $40 $01
        BYTE    $40 $00 $00 $01 $10 $00 $10 $01 $10 $00 $D0 $00 $40 $00 $40 $01
        BYTE    $20 $00 $E0 $00 $80 $00 $80 $01 $50 $00 $D0 $00 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $10 $00 $10 $01 $60 $00 $20 $01 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $60 $00 $60 $01 $60 $00 $20 $01 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $00 $20 $00 $21
        BYTE    $20 $00 $E0 $00 $08 $00 $08 $01 $08 $00 $C8 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $28 $00 $28 $01 $28 $00 $E8 $00 $60 $00 $60 $01
        BYTE    $20 $00 $E0 $00 $00 $01 $00 $02 $00 $01 $C0 $01 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $10 $00 $10 $01 $00 $01 $C0 $01 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $10 $00 $10 $01 $10 $00 $D0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $38 $00 $28 $01
        BYTE    $30 $00 $F0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $10 $00 $10 $01
        BYTE    $10 $00 $D0 $00 $20 $00 $20 $01 $20 $00 $E0 $00 $20 $00 $20 $01
        BYTE    $20 $00 $E0 $00 $00 $01 $E0 $01 $C0 $00 $80 $01 $00 $01 $00 $02
        BYTE    $00 $01 $C0 $01 $00 $08 $00 $09 $00 $08 $C0 $08
}
TABLE   :_2e52                                  SECTION ::mobs                  `$2E52
{
        BYTE    $A6, $A8, $FF
}
TABLE   :_2e55                                  SECTION ::mobs                  `$2E55
{
        BYTE    $A0, $A2, $A4, $00, $FF
}

PROC    :_2e5a                                  SECTION ::mobs                  `$2E5A
        `==============================================================================
        `update HUD?
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	`do not update the Sonic sprite frame
	res	7,[iy+#vars.timeLightningFlags]
	
        ``populate the layout buffer with the bytes in the table above, 
          $A0, $A2, $A4, $00 $FF -- the Sonic icon, x, and placeholder for lives``
        ld	hl,:_2e55
	ld	de,$.LAYOUT_BUFFER
	ld	bc,$0005
	ldir
	
	ld	a,[$.LIVES]
	cp	9			        `9 lives?
	jr	c,._1			        `if more than 9 lives,
	ld	a,9			        `we will display as 9 lives
	
._1	add	a,a			
	add	a,$80			
	ld	[$.LAYOUT_BUFFER+2],a
	
	ld	c;xpos,16
	ld	b;ypos,172	                `Y-position of lives display
	ld	hl,[$.SPRITETABLE_ADDR]
	ld	de,$.LAYOUT_BUFFER
	call	:layoutSpritesHorizontal
	ld	[$.SPRITETABLE_ADDR],hl
	
	`show rings?
	bit	2,[iy+#vars.scrollRingFlags]
	call	nz,:_2ee6
	
	`show time?
	bit	5,[iy+#vars.timeLightningFlags]
	call	nz,:displayTime
	
	ld	de,$0060
	ld	hl,$.D267
	ld	a,[hl]
	inc	hl
	or	[hl]
	call	z,:_311a
	
	inc	hl
	ld	de,$0088
	ld	a,[hl]
	inc	hl
	or	[hl]
	call	z,:_311a
	
	inc	hl
	ld	de,$0060
	ld	a,[hl]
	inc	hl
	or	[hl]
	call	z,:_311a
	
	inc	hl
	ld	de,$0070
	bit	6,[iy+#vars.scrollRingFlags]
	jr	z,._2
	ld	de,$0080
._2	ld	a,[hl]
	inc	hl
	or	[hl]
	call	z,:_311a
	
        `is Sonic alive?
	bit	0,[iy+#vars.scrollRingFlags]
	call	z,:_2f66
	
	ld	HL;zero         $0000
	ld	[$.D267]        HL;zero
	ld	[$.D269]        HL;zero
	ld	[$.D26B]        HL;zero
	ld	[$.D26D]        HL;zero
	call	:_31e6
	
	`run the code for all the different mobs in the level (including the player)
	call	:doObjects
	ret
}

PROC    :_2ee6                                  SECTION ::mobs                  `$2EE6
        `==============================================================================
        `display ring count on screen?
{        
	ld	A;rings         [$.RINGS]
	ld	C;rings         A;rings
	rrca	
	rrca	
	rrca	
	rrca	
	and	$0f
	add	a,a
	add	a,$80
	ld	[$.LAYOUT_BUFFER],a
	ld	a,c
	and	$0f
	add	a,a
	add	a,$80
	ld	[$.LAYOUT_BUFFER+1],a
	ld	a,$ff
	ld	[$.LAYOUT_BUFFER+2],a
        
	ld	c;xpos,20
	ld	b;ypos,0
	ld	hl,[$.SPRITETABLE_ADDR]
	ld	de,:_2e52
	call	:layoutSpritesHorizontal
	
        ld	C;xpos          40
	ld	B;ypos          0
	ld	DE              $.LAYOUT_BUFFER
	call	:layoutSpritesHorizontal
	ld	[$.SPRITETABLE_ADDR],hl
	
        ret
}

PROC    :displayTime                            SECTION ::mobs                  `$2F1F
        `==============================================================================
HELP  ""Draws the level time on the screen
{        
	ld	HL;buffer       $.LAYOUT_BUFFER
        
	ld	A;minutes       [$.TIME_MINUTES]
	and	$0F
	add	A;minutes       A;minutes
	add	A;tileIndex     $80             `numeral 0 tile index
	
        ld	[HL;buffer]     A;tileIndex
	inc	HL;buffer
	ld	[HL;buffer]     $B0             `colon tile index
	inc	HL;buffer
        
	ld	A;seconds       [$.TIME_SECONDS]
	ld	c,a
	srl	a
	srl	a
	srl	a
	srl	a
	add	a,a
	add	a,$80
	ld	[HL;buffer]     A;tileIndex
	inc	HL;buffer
        
	ld	a,c
	and	$0F
	add	a,a
	add	a,$80
	ld	[hl],a
	inc	hl
	ld	[HL;buffer]     $FF             `terminate the buffer
        
	ld	C;xpos          24
	ld	B;ypos          16
        
	ld	A;level         [$.CURRENT_LEVEL]
	cp	28
	jr	c,._1
	
        `TODO: this is inefficient changing the position twice
	ld	C;xpos          112
	ld	B;ypos          56
._1	ld	HL;spriteTable  [$.SPRITETABLE_ADDR]
	ld	DE;buffer       $.LAYOUT_BUFFER
	call	:layoutSpritesHorizontal
	ld	[$.SPRITETABLE_ADDR] HL;spriteTable
        
	ret
}

PROC    :_2f66                                  SECTION ::mobs                  `$2F66
        `==============================================================================
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{
	bit	6,[iy+#vars.timeLightningFlags]
	ret	nz
	
	ld	hl,[$.CAMERA_X_GOTO]
	ld	a,l
	or	h
	call	nz,:scrollCameraTo_horizontal
	
	ld	hl,[$.CAMERA_Y_GOTO]
	ld	a,l
	or	h
	call	nz,:scrollCameraTo_vertical
	
	ld	hl,[$.D267]
	ld	de,[$.D25F]
	and	a
	sbc	hl,de
	call	nz,:_315e
	
	ld	[$.D25F],de
	ld	hl,[$.D269]
	ld	de,[$.D261]
	and	a
	sbc	hl,de
	call	nz,:_315e
	
	ld	[$.D261],de
	ld	hl,[$.D26B]
	ld	de,[$.D263]
	and	a
	sbc	hl,de
	call	nz,:_315e
	
	ld	[$.D263],de
	ld	hl,[$.D26D]
	ld	de,[$D265]
	and	a
	sbc	hl,de
	call	nz,:_315e
	
	ld	[$D265],de
	ld	bc,[$.D25F]
	ld	de,[$.SONIC.X]
	ld	hl,[$.CAMERA_X]
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._4
	
	ld	a,h
	and	a
	jr	nz,._1
	
	ld	a,l
	cp	$09
	jr	c,._2
	
._1	ld	hl,$0008
._2	bit	3,[iy+#vars.scrollRingFlags]
	jr	nz,._
	bit	5,[iy+#vars.scrollRingFlags]
	jr	z,._3
	ld	hl,$0001
._3	ex	de,hl
	ld	hl,[$.CAMERA_X]
	and	a
	sbc	hl,de
	jr	c,._
	ld	[$.CAMERA_X],hl
	jp	._
	
._4	ld	bc,[$.D261]
	ld	hl,[$.CAMERA_X]
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._
	ld	a,l
	cpl	
	ld	l,a
	ld	a,h
	cpl	
	ld	h,a
	inc	hl
	ld	a,h
	and	a
	jr	nz,._5
	ld	a,l
	cp	$09
	jr	c,._6
._5	ld	hl,$0008
._6	bit	3,[iy+#vars.scrollRingFlags]
	jr	nz,._
	bit	5,[iy+#vars.scrollRingFlags]
	jr	z,._7
	ld	hl,$0001
._7	ld	de,[$.CAMERA_X]
	add	hl,de
	jr	c,._
	ld	[$.CAMERA_X],hl
._	ld      hl,[$.CAMERA_X]
	ld	de,[$.LEVEL_LEFT]
	and	a
	sbc	hl,de
	jr	nc,._8
	ld	[$.CAMERA_X],de
	jr	._9
	
._8	ld	hl,[$.CAMERA_X]
	ld	de,[$.LEVEL_RIGHT]
	and	a
	sbc	hl,de
	jr	c,._9
	ld	[$.CAMERA_X],de
._9	bit	6,[iy+#vars.scrollRingFlags]
	call	nz,:_3164
	ld	bc,[$.D263]
	ld	de,[$.SONIC.Y+0]
	ld	hl,[$.CAMERA_Y]
	bit	6,[iy+#vars.scrollRingFlags]
	call	nz,:_31cf
	bit	7,[iy+#vars.scrollRingFlags]
	call	nz,:_31d3
	add	hl,bc
	bit	7,[iy+#vars.scrollRingFlags]
	call	z,:_31db
	and	a
	sbc	hl,de
	jr	c,._13
	ld	c,$09
	ld	a,h
	and	a
	jr	nz,._10
	bit	6,[iy+#vars.scrollRingFlags]
	call	nz,:_311f
	ld	a,l
	cp	c
	jr	c,._11
._10	dec	c
	ld	l,c
	ld	h,$00
._11	bit	7,[iy+#vars.scrollRingFlags]
	jr	z,._12
	srl	h
	rr	l
	bit	1,[iy+#vars.unknown0]
	jr	nz,._12
	ld	hl,$0000
._12	ex	de,hl
	ld	hl,[$.CAMERA_Y]
	and	a
	sbc	hl,de
	jr	c,._16
	ld	[$.CAMERA_Y],hl
	jp	._16
	
._13	ld	bc,[$D265]
	ld	hl,[$.CAMERA_Y]
	add	hl,bc
	bit	7,[iy+#vars.scrollRingFlags]
	call	z,:_31db
	and	a
	sbc	hl,de
	jr	nc,._16
	ld	a,l
	cpl	
	ld	l,a
	ld	a,h
	cpl	
	ld	h,a
	inc	hl
	ld	c,$09
	ld	a,h
	and	a
	jr	nz,._14
	bit	6,[iy+#vars.scrollRingFlags]
	call	nz,:_311f
	ld	a,l
	cp	c
	jr	c,._15
._14	dec	c
	ld	l,c
	ld	h,$00
._15	bit	4,[iy+#vars.scrollRingFlags]
	jr	nz,._16
	ld	de,[$.CAMERA_Y]
	add	hl,de
	jr	c,._16
	ld	[$.CAMERA_Y],hl
._16	ld      hl,[$.CAMERA_Y]
	ld	de,[$.LEVEL_TOP]
	and	a
	sbc	hl,de
	jr	nc,._17
	ld	[$.CAMERA_Y],de
._17	ld	hl,[$.CAMERA_Y]
	ld	de,[$.LEVEL_BOTTOM]
	and	a
	sbc	hl,de
	jr	c,.ret
	ld	[$.CAMERA_Y],de
.ret	ret
}

PROC    :_311a                                  SECTION ::mobs                  `$311A
        `==============================================================================
{        
	ld	[hl],d
	dec	hl
	ld	[hl],e
	inc	hl
	ret
}

PROC    :_311f                                  SECTION ::mobs                  `$311F
        `==============================================================================
{
	ld	c,$08
	ret
}

PROC    :scrollCameraTo_vertical                SECTION ::mobs                  `$3122
        `==============================================================================
        `scroll vertically towards the locked camera position

PARAMS  hl
{
	ld	de;ypos,[$.LEVEL_TOP]
	and	a
	sbc	hl,de;ypos
	ret	z
	jr	c,.up
        
        `scroll downwards
	inc	de;ypos
	ld	[$.LEVEL_TOP],de;ypos
	ld	[$.LEVEL_BOTTOM],de;ypos
	ret
	
        `scroll upwards
.up	dec	de;ypos
	ld	[$.LEVEL_TOP],de;ypos
	ld	[$.LEVEL_BOTTOM],de;ypos
	ret
}

PROC    :scrollCameraTo_horizontal              SECTION ::mobs                  `$3140
        `==============================================================================
        `scroll horizontally towards the locked camera position
        
PARAMS  hl      `$.RAM_CAMERA_X_GOTO
{
	ld	de,[$.LEVEL_LEFT]
	and	a			        `reset carry so it doesn't affect `sbc`
	sbc	hl,de
	ret	z			        `if HL = DE then return -- no change
	jr	c,._1			        `is DE > HL?
	
	inc	de
	ld	[$.LEVEL_LEFT],de
	ld	[$.LEVEL_RIGHT],de
	ret
	
._1	dec	de
	ld	[$.LEVEL_LEFT],de
	ld	[$.LEVEL_RIGHT],de
	ret
}

PROC    :_315e                                  SECTION ::mobs                  `$315E
        `==============================================================================
{
	jr	c,._1
	inc	de
	ret
	
._1	dec	de
	ret
}


PROC    :_3164                                  SECTION ::mobs                  `$3164
        `==============================================================================
{
	ld	hl,[$.D29D]
	ld	de,[$.TIME]
	add	hl,de
	ld	bc,$0200
	ld	a,h
	and	a
	jp	p,._1
	neg	
	ld	bc,$fe00
._1	cp	$02
	jr	c,._2
	ld	l,c
	ld	h,b
._2	ld	[$.D29D],hl
	ld	c,l
	ld	b,h
	ld	hl,[$.D25C]		        `between RAM_CAMERA_X & Y
	ld	a,[$.CAMERA_Y+1]	        `high-byte of RAM_CAMERA_X
	add	hl,bc
	ld	e,$00
	bit	7,b
	jr	z,._3
	ld	e,$ff
._3	adc	a,e
	ld	[$.D25C],hl
	ld	[$.CAMERA_Y+1],a
	ld	hl,[$.D2A1]
	ld	a,[$.D2A3]
	add	hl,bc
	adc	a,e
	ld	[$.D2A1],hl
	ld	[$.D2A3],a
	ld	hl,[$.D2A2]
	bit	7,h
	jr	z,._4
	ld	bc,$ffe0
	and	a
	sbc	hl,bc
	jr	nc,._4
	ld	hl,$0002
	ld	[$.TIME],hl
	ret
	
._4	ld	hl,[$.D2A2]
	ld	bc,$0020
	and	a
	sbc	hl,bc
	ret	c
	ld	hl,$fffe
	ld	[$.TIME],hl
	ret
}

PROC    :_31cf                                  SECTION ::mobs                  `$31CF
        `==============================================================================
{
	ld	bc,$0020
	ret
}

PROC    :_31d3                                  SECTION ::mobs                  `$31D3
        `==============================================================================
{
	ld	bc,$0070
	ret
}

PROC    :unused_31d7                            SECTION ::mobs                  `$31D7
        `==============================================================================
{
	ld	bc,$0070
	ret
}

PROC    :_31db                                  SECTION ::mobs                  `$31DB
        `==============================================================================
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	bit	6,[iy+#vars.scrollRingFlags]
	ret	nz
	ld	bc,[$.D2B7]
	add	hl,bc
	ret
}

PROC    :_31e6                                  SECTION ::mobs                  `$31E6
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{        
	ld	a,[$.FRAMECOUNT]
	and	$07
	ld	c,a
	ld	hl,$0068
	call	:decimalMultiplyBy10
	ld	de,$.SONIC
	add	hl,de
	ex	de,hl
	ld	a,[$.FRAMECOUNT]
	and	$07
	add	a,a
	add	a,a
	add	a,a
	ld	c,a
	ld	b,$00
	ld	hl,$.D37C		        `list of current on-screen objects
	add	hl,bc
	ld	c,b
	ld	b,$04
.loop	ld	a,[de]
	cp	$56
	jp	nc,._4
	push	de
	pop	ix
	exx	
	add	a,a
	ld	l,a
	ld	h,$00
	add	hl,hl
	add	hl,hl
	ld	de,:_2ba2
	add	hl,de
	ld	c,[hl]
	inc	hl
	ld	b,[hl]
	inc	hl
	ld	de,$.TEMP1
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ld	hl,[$.CAMERA_X]
	xor	a;zero
	sbc	hl,bc
	jr	nc,._1
	ld	l,a;zero
	ld	h,a;zero
	xor	a;zero
._1	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	sbc	hl,de
	jp	nc,._3
	ld	hl,[$.TEMP1]
	ld	bc,[$.CAMERA_X]
	add	hl,bc
	xor	a;zero
	sbc	hl,de
	jp	c,._3
	ld	hl,[$.CAMERA_Y]
	ld	bc,[$.TEMP3]
	sbc	hl,bc
	jr	nc,._2
	ld	l,a
	ld	h,a
	xor	a;zero
._2	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	sbc	hl,de
	jp	nc,._3
	ld	hl,[$.TEMP4]
	ld	bc,[$.CAMERA_Y]
	add	hl,bc
	xor	a;zero
	sbc	hl,de
	jp	c,._3
	exx	
	ld	[hl],e
	inc	hl
	ld	[hl],d
	inc	hl
	push	hl
	ld	hl,$001a
	add	hl,de
	ex	de,hl
	pop	hl
	djnz	.loop
	
	ret
	
._3	exx	
	
._4	ld	[hl],c
	inc	hl
	ld	[hl],c
	inc	hl
	push	hl
	ld	hl,$001a
	add	hl,de
	ex	de,hl
	pop	hl
	dec	b
	jp	nz,.loop
	ret
}

PROC    :doObjects                              SECTION ::mobs                  `$392B
        `==============================================================================
        `runs the code for each of the mobs in memory
        
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	``starting from $D37E, read 16-bit numbers until a non-zero one is found,
	  or 31 numbers have been read``
	ld	hl,$.D37C+2
	ld	b,31
	
.loop	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	
	`is the value greater than zero?
	ld	a,e
	or	d
	call	nz,:mob
	
	`keep reading memory until either something non-zero is found or we hit $D3BC
	djnz	.loop
	
	ld	a,[iy+#vars.spriteUpdateCount]
	ld	hl,[$.SPRITETABLE_ADDR]
	
	push	af
	push	hl
	
	`process the player:
	ld	hl,$D024		        `Sonic's sprite table entry
	ld	[$.SPRITETABLE_ADDR],hl
	ld	de,$.SONIC
	call	:mob
	
	pop	hl
	pop	af
	
	ld	[$.SPRITETABLE_ADDR],hl
	ld	[iy+#vars.spriteUpdateCount],a
	ret
}

PROC    :mob                                    SECTION ::mobs                  `$32C8
        `------------------------------------------------------------------------------
PARAMS  de
{        
	ld	a,[de]			        `get mob from the list
	cp	$FF			        `ignore mob #$FF
	ret	z
	
	push	bc, hl
	
	`transfer DE (address of the mob) to IX
	push	de
	pop	ix
	
	`double the index number and put it into DE
	add	a,a
	ld	e,a
	ld	d,$00
	
	`offset into the mob pointers table
	ld	hl,:S1_Object_Pointers
	add	hl,de
	
	`get the mob's pointer address into HL
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	
	`once the mob's own code has been run,
         `handle the common actions for all mobs
	ld	de,:processObject
	push	de
	
	`run the mob's code
	jp	[hl]
}
	
PROC    :processObject                          SECTION ::mobs                  `$32E2
        `------------------------------------------------------------------------------
        ``once an mob has run its personal code, this routine handles things that
          all mobs share, such as moving the mob, and collision with Sonic``
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{       
        `move mob
        `------------------------------------------------------------------------------
        
        `move the mob horizontally 
	ld	e;speed, [ix+#mob.Xspeed.lo]
	ld	d;speed, [ix+#mob.Xspeed.hi]
	ld	c;dir, [ix+#mob.Xdirection]
        
	ld	l;xpos, [ix+#mob.Xsubpixel]
	ld	h;xpos, [ix+#mob.X.lo]
	ld	a;xpos, [ix+#mob.X.hi]
	add	hl;xpos, de;speed
	adc	a;xpos, c;dir
        
	ld	[ix+#mob.Xsubpixel], l;ypos
	ld	[ix+#mob.X.lo], h;ypos
	ld	[ix+#mob.X.hi], a;ypos
        
        `move the mob vertically
	ld	e;speed, [ix+#mob.Yspeed.lo]
	ld	d;speed, [ix+#mob.Yspeed.hi]
	ld	c;dir, [ix+#mob.Ydirection]
	ld	l;ypos, [ix+#mob.Ysubpixel]
	ld	h;ypos, [ix+#mob.Y.lo]
	ld	a;ypos, [ix+#mob.Y.hi]
	add	hl;ypos, de;speed
	adc	a;ypos, c;dir
        
	ld	[ix+#mob.Ysubpixel], l;ypos
	ld	[ix+#mob.Y.lo], h;ypos
	ld	[ix+#mob.Y.hi], a;ypos
        
        `------------------------------------------------------------------------------
        
	bit	5, [ix+#mob.flags]
	jp	nz, :_34e6
	ld	b, $00
	ld	d, b
	ld	e, [ix+#mob.height]
	srl	e
	bit	7, [ix+#mob.Xspeed.hi]
	jr	nz, ._1
	ld	c, [ix+#mob.width]
	ld	hl, $411E
	jp	._2

._1	ld	c, $00
	ld	hl, $4020
._2	ld	[$.TEMP3], bc
	res	6,[ix+#mob.flags]
	push	de
	push	hl
	call	:getFloorLayoutRAMAddressForMob
	ld	e,[hl]
	ld	d,$00
	ld	a,[$.LEVEL_SOLIDITY]
	add	a,a
	ld	c,a
	ld	b,d
	ld	hl,:S1_Solidity_Blocks
	add	hl,bc
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	add	hl,de
	ld	a,[hl]
	and	$3f
	ld	[$.TEMP6],a
	pop	hl
	pop	de
	and	$3f
	jp	z,._7
	ld	a,[$.TEMP6]
	add	a,a
	ld	c,a
	ld	b,$00
	ld	d,b
	add	hl,bc
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	ld	a,[ix+#mob.Y.lo]
	add	a,e
	and	$1f
	ld	e,a
	add	hl,de
	ld	a,[hl]
	cp	$80
	jp	z,._7
	ld	e,a
	and	a
	jp	p,._3
	ld	d,$ff
._3	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	bc,[$.TEMP3]
	add	hl,bc
	bit	7,[ix+#mob.Xdirection]
	jr	nz,._4
	and	a
	jp	m,._5
	ld	a,l
	and	$1f
	cp	e
	jr	nc,._5
	jp	._7
	
._4	and	a
	jp	m,._5
	ld	a,l
	and	$1f
	cp	e
	jr	nc,._7
._5	set	6,[ix+#mob.flags]
	ld	a,l
	and	$e0
	ld	l,a
	add	hl,de
	and	a
	sbc	hl,bc
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	a,[$.TEMP6]
	ld	e,a
	ld	d,$00
	ld	hl,$3fbf		        `data?
	add	hl,de
	ld	c,[hl]
	ld	[ix+#mob.Xspeed.lo],d
	ld	[ix+#mob.Xspeed.hi],d
	ld	[ix+#mob.Xdirection],d
	ld	a,d
	ld	b,d
	bit	7,c
	jr	z,._6
	dec	a
	dec	b
._6	ld	l,[ix+#mob.Yspeed.lo]
	ld	h,[ix+#mob.Yspeed.hi]
	add	hl,bc
	adc	a,[ix+#mob.Ydirection]
	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],a
._7	ld	b,$00
	ld	d,b
	bit	7,[ix+#mob.Yspeed.hi]
	jr	nz,._8
	ld	c,[ix+#mob.width]
	srl	c
	ld	e,[ix+#mob.height]
	ld	hl,$448a		        `data?
	jp	._9
	
._8	ld	c,[ix+#mob.width]
	srl	c
	ld	e,$00
	ld	hl,$41ec		        `data?
._9	ld	[$.TEMP3],de
	res	7,[ix+#mob.flags]
	push	bc
	push	hl
	call	:getFloorLayoutRAMAddressForMob
	ld	e,[hl]
	ld	d,$00
	ld	a,[$.LEVEL_SOLIDITY]
	add	a,a
	ld	c,a
	ld	b,d
	ld	hl,:S1_Solidity_Blocks
	add	hl,bc
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	add	hl,de
	ld	a,[hl]
	and	$3f
	ld	[$.TEMP6],a
	pop	hl
	pop	bc
	and	$3f
	jp	z,._34e6
	ld	a,[$.TEMP6]
	add	a,a
	ld	e,a
	ld	d,$00
	ld	b,d
	add	hl,de
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	ld	a,[ix+#mob.X.lo]
	add	a,c
	and	$1f
	ld	c,a
	add	hl,bc
	ld	a,[hl]
	cp	$80
	jp	z,._34e6
	ld	c,a
	and	a
	jp	p,._10
	ld	b,$ff
._10	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,[$.TEMP3]
	add	hl,de
	bit	7,[ix+#mob.Ydirection]
	jr	nz,._11
	and	a
	jp	m,._12
	ld	a,l
	and	$1f
	exx	
	ld	hl,[$.TEMP6]
	ld	h,$00
	ld	de,$3ff0		        `data?
	add	hl,de
	add	a,[hl]
	exx	
	cp	c
	jr	c,._34e6
	set	7,[ix+#mob.flags]
	jp	._12
	
._11	and	a
	jp	m,._12
	ld	a,l
	and	$1f
	exx	
	ld	hl,[$.TEMP6]
	ld	h,$00
	ld	de,$3ff0		        `data?
	add	hl,de
	add	a,[hl]
	exx	
	cp	c
	jr	nc,._34e6
._12	ld	a,l
	and	$e0
	ld	l,a
	add	hl,bc
	and	a
	sbc	hl,de
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	a,[$.TEMP6]
	ld	e,a
	ld	d,$00
	ld	hl,$3f90		        `data?
	add	hl,de
	ld	c,[hl]
	ld	[ix+#mob.Yspeed.lo],d
	ld	[ix+#mob.Yspeed.hi],d
	ld	[ix+#mob.Ydirection],d
	ld	a,d
	ld	b,d
	bit	7,c
	jr	z,._13
	dec	a
	dec	b
._13	ld	l,[ix+#mob.Xspeed.lo]
	ld	h,[ix+#mob.Xspeed.hi]
	add	hl,bc
	adc	a,[ix+#mob.Xdirection]
	ld	[ix+#mob.Xspeed.lo],l
	ld	[ix+#mob.Xspeed.hi],h
	ld	[ix+#mob.Xdirection],a
._34e6
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,[$.CAMERA_Y]
	and	a
	sbc	hl,bc
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	bc,[$.CAMERA_X]
	and	a
	sbc	hl,bc
	ld	c,[ix+#mob.spriteLayout.lo]
	ld	b,[ix+#mob.spriteLayout.hi]
	ld	a,c
	or	b
	call	nz,:processSpriteLayout
	
	pop	hl, bc
	ret
}

PROC    :processSpriteLayout                    SECTION ::mobs                  `$350F
        `==============================================================================
HELP """Puts a mob on the screen, combining multiple sprites using a Sprite Layout -
        a list of sprites to arrange in a maximum 6x4 layout
        """
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
        hl	        HELP ""X-position to place sprite layout on screen
	d	        `?? (some kind of control flag)
	e;ypos	        HELP ""Y-position to place sprite layout on screen
	bc;layout       HELP ""Address of a sprite layout
{
	`store the X-position of the sprite for aligning the rows
	ld	[$.TEMP6], hl;xpos
	
	`copy BC (address of a sprite layout) to its shadow value BC'
	push	bc;layout
	exx
	pop	bc'layout
	exx
	
	`--- rows ---------------------------------------------------------------------
	`there will be 3 rows of double-high (16px) sprites
	ld	b;rows, $00
	ld	c;rows, $03
	
._1	exx				        `switch to BC/DE/HL shadow values
	
	ld	hl;xpos, [$.TEMP6]	        `get the starting X-position
                                                 `(original HL parameter)
	
	`if a row begins with $FF, the data ends early
	 `begin a row with $FE to provide a space without ending the data early
	
	ld	a, [bc;layout]  	        `get a byte from the sprite layout data
	exx				        `switch to original BC/DE/HL values
	cp	$FF			        `is the byte $FF?
	ret	z			        `if so leave
	
	`DE is the Y-position, but if D is $FF then something else unknown happens
	
	ld	a, d			        `check the D parameter
	cp	$FF			        `if D is not $FF
	jr	nz, ._2			        `then skip ahead a little
	
	ld	a, e			        `check the E parameter
	cp	$F0			        `if it's less than $F0,
	jr	c, ._5			        `then skip ahead
	jp	._3
	
._2	and	a			        `is the sprite byte 0?
	jr	nz, ._5
	
	`exit if the row Y-position is below the screen
	ld	a, e
	cp	192
	ret	nc
	
	`--- columns ------------------------------------------------------------------
._3	`begin 6 columns of single-width (8px) sprites
	ld	b, $06
	
.loop	exx				        `switch to BC/DE/HL shadow values
	
	`has the X-position gone over 255?
	ld	a, h			        `check the H parameter
	and	a			        `is it >0? i.e. HL = $0100
	jr	nz, ._4			        `if so skip
	
	ld	a, [bc]			        `check the current byte of the layout data
	cp	$FE			        `is it >= than $FE?
	jr	nc, ._4			        `if so, skip
	
	`get the address of the sprite table entry
	ld	de, [$.SPRITETABLE_ADDR]	
	ld	a, l			        `take the current X-position
	ld	[de], a			        `and set the sprite's X-position
	inc	e				
	exx
	ld	a, e			        `get the current Y-position
	exx
	ld	[de], a			        `set the sprite's Y-position 
	inc	e
	ld	a, [bc]			        `read the layout byte
	ld	[de], a			        `set the sprite index number
	
	`move to the next sprite table entry
	inc	e
	ld	[$.SPRITETABLE_ADDR], de	
	inc	[iy+#vars.spriteUpdateCount]
	
	`move across 8 pixels
._4	inc	bc
	ld	de, $0008
	add	hl, de
	
	`return B to the column count and decrement
	exx
	djnz	.loop
	
	`move down 16-pixels
	ld	a, c
	ex	de, hl
	ld	c, 16
	add	hl, bc
	ex	de, hl
	
	`any rows remaining?
	ld	c, a
	dec	c
	jr	nz, ._1
	ret
	
	`------------------------------------------------------------------------------
	`need to work this out (when D is $FF)
._5	exx
	ex	de, hl
	ld	hl, $0006
	add	hl, bc
	ld	c, l
	ld	b, h
	ex	de, hl
	exx
	ld	a, c
	ex	de, hl
	ld	c, $10
	add	hl, bc
	ex	de, hl
	ld	c, a
	dec	c
	jr	nz, ._1
	
	ret
}

PROC    :_3581                                  SECTION ::mobs                  `$3581
        `==============================================================================
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	ld	hl,[$.TEMP3]
	ld	bc,[$.TEMP6]
	add	hl,bc
	ld	bc,[$.CAMERA_Y]
	and	a
	sbc	hl,bc
	ex	de,hl
	ld	hl,[$.TEMP1]
	ld	bc,[$.TEMP4]
	add	hl,bc
	ld	bc,[$.CAMERA_X]
	and	a
	sbc	hl,bc
	ld	c,a
	ld	a,h
	and	a
	ret	nz
	ld	a,d
	cp	$ff
	jr	nz,._1
	ld	a,e
	cp	$f0
	ret	c
	jp	._2
	
._1	and	a
	ret	nz
	ld	a,e
	cp	$c0
	ret	nc
._2	ld	h,c
	ld	bc,[$.SPRITETABLE_ADDR]
	ld	a,l
	ld	[bc],a
	inc	c
	ld	a,e
	ld	[bc],a
	inc	c
	ld	a,h
	ld	[bc],a
	inc	c
	ld	[$.SPRITETABLE_ADDR],bc
	inc	[iy+#vars.spriteUpdateCount]
	ret
}

PROC    :layoutSpritesHorizontal                SECTION ::mobs                  `$35CC
        `==============================================================================
HELP """Places a set of sprites next to each other, dictated by a small data stream of
        indexes, with $FE to leave a blank space and $FF to terminate. This routine is
        typically used to place text and numbers on screen.
        """
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
        B;ypos
        C;xpos
        HL;addr         `($.SPRITETABLE_ADDR)  
        DE;data         `$.LAYOUT_BUFFER	: $A0, $A2, $A4, ($80 + $.LIVES * 2), $FF
{       
	ld	a, [de;data]                    `check the current byte in the list
	cp	$FF                             `is it an end marker? ($FF)
	ret	z                               `if so, return
	
	cp	$FE                             `special case for $FE command
	jr	z, .skip                        `(skip ahead)
	
	ld	[hl;addr], c;xpos
	inc	l;addr
	ld	[hl;addr], b;ypos
	inc	l;addr
	ld	[hl;addr], a
	inc	l;addr
	inc	[iy+#vars.spriteUpdateCount]
        
.skip	inc	de;data
	ld	a;xpos, c;xpos
	add	a;xpos, 8                       `move right 8 pixels
	ld	c;xpos, a;xpos
	jp	:                               `process more sprites in the list
}

PROC    :_35e5                                  SECTION ::mobs                  `$35E5
        `==============================================================================
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{
	bit	0,[iy+#vars.scrollRingFlags]    `is the player already dead?
	ret	nz                              `if so, leave now
        
	bit	0,[iy+#vars.unknown0]
	jp	nz,:_36be
	
        ld	a,[$.SONIC.flags]
	rrca	
	jp	c,:_36be
	
        and	$02
	jp	nz,:_36be
        
        `WARNING: potential fall through to the routine below
}

PROC    :_35fd                                  SECTION ::mobs                  `$35FD
        `------------------------------------------------------------------------------
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	bit	0,[iy+#vars.flags9]
	ret	nz
        
	bit	6,[iy+#vars.flags6]             `is player in damage-state?
	ret	nz                              `if so, do not continue
        
	bit	0,[iy+#vars.unknown0]
	ret	nz
        
	bit	5,[iy+#vars.flags6]
	jr	nz,:3644._367e
        
	ld	a,[$.RINGS]
	and	a
	jr	nz,:_3644
        
        `WARNING: potential fall-through to the procedure below
}

PROC    :killPlayer                             SECTION ::mobs                  `$3618
        `------------------------------------------------------------------------------
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{
        `kill the player!
	set	0,[iy+#vars.scrollRingFlags]
        
        `set flag 7 on the mob (mob death state?)
	ld	HL              $.SONIC.flags
	set	7               [HL]
        
	ld	HL              $FFFA
	xor	A;zero                          `set A to zero
	ld	[$.SONIC.Yspeed.lo]             A;zero
	ld	[$.SONIC.Yspeed.hi]             HL
	ld	a,$60
	ld	[$.D287],a
	res	6,[iy+#vars.flags6]             `turn off damage-state flag
	res	5,[iy+#vars.flags6]             `remove shield
	res	6,[iy+#vars.flags6]             `TODO: bug or oversight?
	res	0,[iy+#vars.unknown0]           `the 0 byte from the level header
	
        `play the death sound effect
	ld	A;sfx           #index_music_death
	rst	:playMusic
	
	ret
}

PROC    :_3644                                  SECTION ::mobs                  `$3644
        `------------------------------------------------------------------------------
        `lose rings!
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        IY;vars         HELP ""Address of the common variables (used throughout)
{       
	xor	A;zero
	ld	[$.RINGS]       A;zero
	
        call	:findEmptyMob
	jr	c,._367e
	
        push	ix
	push	hl
	pop	ix
	ld	[ix+#mob.type],$55	        `"make Sonic blink"?
	ld	[ix+#mob.unknown11],$06
	ld	[ix+$12],$00
	ld	hl,[$.SONIC.X]
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	hl,[$.SONIC.Y]
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$fc
	ld	[ix+#mob.Ydirection],$ff
	pop	ix
        
._367e	ld	hl,$.SONIC.flags
	ld	de,$fffc
	xor	a;zero
	bit	4,[hl]
	jr	z,._1
	ld	de,$fffe
._1	ld	[$.SONIC.Yspeed+0],a
	ld	[$.SONIC.Yspeed+1],de
	bit	1,[hl]
	jr	z,._2
	ld	a,[hl]
	or	$12
	ld	[hl],a
	xor	a;zero
	ld	de,$0002
	jr	._3
	
._2	res	1,[hl]
	xor	a;zero
	ld	de,$fffe
._3	ld	[$.SONIC.Xspeed+0],a
	ld	[$.SONIC.Xspeed+1],de
	res	5,[iy+#vars.flags6]
	set	6,[iy+#vars.flags6]
	ld	[iy+#vars.joypad],$ff
	ld	a,$11
	rst	:playSFX
	ret
}

PROC    :_36be                                  SECTION ::mobs                  `$36BE
        `------------------------------------------------------------------------------
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        `TODO: we could use BC/DE as parameters instead of RAM addresses
        $.TEMP1         HELP ""An X-offset to place the explosion in the right place
        $.TEMP2         HELP ""A Y-offset to place the explosion in the right place
{        
	ld	[IX+#mob.type]  $0A	        `change mob to explosion
	
        `get the X-offset given in the parameter
        ld	A;x_offset      [$.TEMP1]
	ld	E;x_offset      A;x_offset
	ld	D;x_offset      $00
        
	ld	L;mob_xpos      [IX+#mob.X.lo]
	ld	H;mob_xpos      [IX+#mob.X.hi]
	add	HL;mob_xpos     DE;x_offset
        
	ld	[IX+#mob.X.lo]  L;mob_xpos
	ld	[IX+#mob.X.hi]  H;mob_xpos
	
        `get the Y-offset given in the parameter
        ld	A;x_offset      [$.TEMP2]
	ld	E;x_offset      A;x_offset      `note that D is still zero
	
        ld	L;mob_ypos      [IX+#mob.Y.lo]
	ld	H;mob_ypos      [IX+#mob.Y.hi]
	add	HL;mob_ypos     DE;y_offset
	ld	[IX+#mob.Y.lo]  L;mob_ypos
	ld	[IX+#mob.Y.hi]  H;mob_ypos
        
	xor	A;zero
	ld	[IX+#mob.spriteLayout.lo],A;zero
	ld	[IX+#mob.spriteLayout.hi],A;zero
	
        `play the explosion sound
        ld	A;sfx           $01
	rst	:playSFX
        
        `give the player 100 points
	ld	DE;hundreds     $0100
	ld	C;thousands     $00
	call	:increaseScore
        
	ret
}

PROC    :getFloorLayoutRAMAddressForMob         SECTION ::mobs                  `$36F9
        `==============================================================================
HELP """Retrieves a location in the Floor Layout in RAM based on the current mob
        """
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        BC;xOffset      HELP ""Horizontal pixel offset to add to the mob's X position
                             ""before locating tile
	DE;yOffset      HELP ""Vertical pixel offset to add to the mob's Y position
                             ""before locating tile
RETURN  HL;addr         HELP ""An address within the floor layout in RAM
{
	`how wide is the floor layout?
	ld	A;floorWidth    [$.LEVEL_FLOORWIDTH]
	cp	128
	jr	z,.width128
	cp	64
	jr	z,.width64
	cp	32
	jr	z,.width32
	cp	16
	jr	z,.width16
        
	jp	.width256
	
	`------------------------------------------------------------------------------
	`128 block wide level:
	
.width128
        ld	L;mob_ypos      [IX+#mob.Y.lo]
	ld	H;mob_ypos      [IX+#mob.Y.hi]
	add	HL;mob_ypos     DE;yOffset
	ld	a,l
	add	a,a
	rl	h
	add	a,a
	rl	h
	and	%10000000
	ld	l,a
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,bc
	ld	a,l
	add	a,a
	rl	h
	add	a,a
	rl	h
	add	a,a
	rl	h
	ld	l,h
	ld	h,$00
	add	hl,de
	ld	de,$.FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
	`64 block wide level:
	
.width64
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,de
	ld	a,l
	add	a,a
	rl	h
	and	%11000000
	ld	l,a
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,bc
	ld	a,l
	add	a,a
	rl	h
	add	a,a
	rl	h
	add	a,a
	rl	h
	ld	l,h
	ld	h,$00
	add	hl,de
	ld	de,$.FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
	`32 block wide level:
	
.width32
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,de
	ld	a,l
	and	%11100000
	ld	l,a
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,bc
	ld	a,l
	add	a,a
	rl	h
	add	a,a
	rl	h
	add	a,a
	rl	h
	ld	l,h
	ld	h,$00
	add	hl,de
	ld	de,$.FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
	`16 block wide level:
	
.width16
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,de
	ld	a,l
	srl	h
	rra	
	and	%11110000
	ld	l,a
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,bc
	ld	a,l
	add	a,a
	rl	h
	add	a,a
	rl	h
	add	a,a
	rl	h
	ld	l,h
	ld	h,$00
	add	hl,de
	ld	de,$.FLOORLAYOUT
	add	hl,de
	ret
	
	`------------------------------------------------------------------------------
	`256 block wide level?
	
.width256
	ld	L;mob_ypos      [IX+#mob.Y.lo]
	ld	H;mob_ypos      [IX+#mob.Y.hi]
	add	HL;mob_ypos     DE;yOffset
	ld	A;ypos          L;mob_ypos
	rlca				        `x2 ...
	rl	H;ypos
	rlca				        `x4 ...
	rl	H;ypos
	rlca				        `x8
	rl	H;ypos
	
        `put Y-position aside into DE
        ex	DE;ypos         HL;yOffset
	
	ld	L;mob_xpos      [IX+#mob.X.lo]
	ld	H;mob_xpos      [IX+#mob.X.hi]
	add	HL;mob_xpos     BC;xOffset
	ld	A;xpos          L;mob_xpos
	rlca				        `x2 ...
	rl	H;xpos
	rlca				        `x4 ...
	rl	H;xpos
	rlca				        `x8
	rl	H;xpos
	ld	L;xpos          H;xpos
        
	ld	h,$00
	ld	e,h
	add	hl,de
	ld	DE;floorLayout  $.FLOORLAYOUT
	add	hl              DE;floorLayout
	ret
}

PROC    :updateSonicSpriteFrame                 SECTION ::mobs                  `$37E0
        `==============================================================================
HELP """Copy the current Sonic animation frame into the sprite data
        """
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
	ld	DE;frameCurrent [$.SONIC_CURRENT_FRAME]
	ld	HL;framePrev    [$.SONIC_PREVIOUS_FRAME]
	
        `has the animation advanced a frame?
	and	A;flags                         `ANDing A with itself resets the flags
	sbc	HL;framePrev    DE;frameCurrent `check the difference in frame counts
	ret	z                               `exit if no progress
	
	ld	HL;vram         $3680           `location in VRAM of the Sonic sprite
	ex	DE;vram         HL;discarded    `TODO: make this dynamic, somehow
	
	``I can't find an instance where bit 0 of IY+$06 is set,
	  this may be dead code``
	bit	0, [iy+#vars.flags6]
	jp	nz, ._2
	
	`------------------------------------------------------------------------------
	ld	A;low           E;vram	        `$80
	out	[$.VDP.CONTROL] A;low
	ld	A;hi            D;vram	        `$36
	or	%01000000                       `set bit 6 to specify a VDP address
	out	[$.VDP.CONTROL] A;hi
	
	xor	A;zero			        `set A to 0
	ld	c, $.VDP.DATA
	ld	e, 24
	
	``by nature of the way the VDP stores image colours across bit-planes, and
          that the Sonic sprite only uses palette indexes <8, the fourth byte for a
          tile row is always 0. this is used as a very simple form of compression on
          the Sonic sprites in the ROM as the fourth byte is excluded from the data``
._1	outi
	outi
	outi
	out	[$.VDP.DATA], a
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	
	dec	e
	jp	nz, ._1
	
	ld	hl, [$.SONIC_CURRENT_FRAME]
	ld	[$.SONIC_PREVIOUS_FRAME], hl
	ret
	
	`------------------------------------------------------------------------------
	`adds 285 to the frame address. purpose unknown...
._2	ld	bc, $011D
	add	hl, bc
	
	ld	a, e
	out	[$.VDP.CONTROL], a
	ld	a, d
	or	%01000000
	out	[$.VDP.CONTROL], a
	
	exx
	push	bc
	ld	b, $18
	exx
	ld	de, $FFFA
	ld	c, $BE
	xor	a;zero
	
._3	outi
	outi
	outi
	out	[$.VDP.DATA], a
	add	hl, de
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	add	hl, de
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	add	hl, de
	outi
	outi
	outi
	out	[$.VDP.DATA], a
	add	hl, de
	exx
	dec	b
	exx
	jp	nz, ._3
	
	exx
	pop	bc
	exx
	ld	hl, [$.SONIC_CURRENT_FRAME]
	ld	[$.SONIC_PREVIOUS_FRAME], hl
	ret
}

PROC    :updateRingFrame                        SECTION ::mobs                  `$3879
        `==============================================================================
{        
	ld	de,[$.RING_CURRENT_FRAME]
	ld	hl,[$.RING_PREVIOUS_FRAME]
	
	and	a
	sbc	hl,de
	ret	z
	
	ld	hl,$1f80		        `location in VRAM of the ring graphics
	ex	de,hl
	di	
	ld	a,e
	out	[$.VDP.CONTROL],a
	ld	a,d
	or	%01000000
	out	[$.VDP.CONTROL],a
	ld	b,$20
	
.loop	ld	a,[hl]
	out	[$.VDP.DATA],a
	nop	
	inc	hl
	ld	a,[hl]
	out	[$.VDP.DATA],a
	nop	
	inc	hl
	ld	a,[hl]
	out	[$.VDP.DATA],a
	nop	
	inc	hl
	ld	a,[hl]
	out	[$.VDP.DATA],a
	inc	hl
	djnz	.loop
	
	ei	
	ld	hl,[$.RING_CURRENT_FRAME]
	ld	[$.RING_PREVIOUS_FRAME],hl
	ret
}

PROC    :_LABEL_38B0_51                         SECTION ::mobs                  `$38B0
        `==============================================================================
{        
	ld	hl, [$.D2AB]
	ld	a, l
	and	%11111000
	ld	l, a
	
	ld	de, [$.CAMERA_X]
	ld	a, e
	and	%11111000
	ld	e, a
	
	xor	a;zero			        `set A to 0
	sbc	hl, de			        `is DE > HL?
	ret	c
	
	or	h			        `is H > 0?
	ret	nz
	
	ld	a, l
	cp	$08			        `is L < 8?
	ret	c
	
	ld	d, a
	ld	a, [$.VDPSCROLL_HORZ]
	and	%11111000
	ld	e, a
	add	hl, de
	srl	h
	rr	l
	srl	h
	rr	l
	srl	h
	rr	l
	ld	a, l
	and	$1F
	add	a, a
	ld	c, a
	ld	hl, [$.D2AD]
	ld	a, l
	and	$F8
	ld	l, a
	ld	de, [$.CAMERA_Y]
	ld	a, e
	and	$F8
	ld	e, a
	xor	a;zero
	sbc	hl, de
	ret	c
	or	h
	ret	nz
	ld	a, l
	cp	$C0
	ret	nc
	ld	d, $00
	ld	a, [$.VDPSCROLL_VERT]
	and	$F8
	ld	e, a
	add	hl, de
	srl	h
	rr	l
	srl	h
	rr	l
	srl	h
	rr	l
	ld	a, l
	cp	$1C
	jr	c, ._1
	sub	$1C
._1	ld	l, a
	ld	h, $00
	ld	b, h
	rrca
	rrca
	ld	h, a
	and	$C0
	ld	l, a
	ld	a, h
	xor	l
	ld	h, a
	add	hl, bc
	ld	bc, $.VDP.SCREENNAMETABLE
	add	hl, bc
	ld	de, [$.D2AF]
	ld	b, $02

.loop	ld	a, l
	out	[$.VDP.CONTROL], a
	ld	a, h
	or	%01000000
	out	[$.VDP.CONTROL], a
	
	ld	a, [de]
	out	[$.VDP.DATA], a
	inc	de
	nop
	nop
	ld	a, [de]
	out	[$.VDP.DATA], a
	inc	de
	nop
	nop
	ld	a, [de]
	out	[$.VDP.DATA], a
	inc	de
	nop
	nop
	ld	a, [de]
	out	[$.VDP.DATA], a
	inc	de
	
	ld	a, b
	ld	bc, $0040
	add	hl, bc
	ld	b, a
	djnz	.loop
	
	ret
}

PROC    :detectCollisionWithSonic               SECTION ::mobs                  `$3956
        `==============================================================================
HELP """Tests to see if the given mob has collided with Sonic
        """
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        IY;vars         HELP ""Address of the common variables (used throughout)
        $.TEMP6         HELP ""Left indent of the mob, in pixels
        $.TEMP7         HELP ""Top indent of the mob, in pixels
RETURN  F;carry         HELP ""Carry flag is clear if collision, otherwise set
{
        `is Sonic dead? (no collision detection)
	bit	0,[IY+#vars.scrollRingFlags]
	scf                                     `return carry flag set (no-collision)
	ret	nz                              `if Sonic-dead flag on, leave now
	
        `------------------------------------------------------------------------------
        
        `calculate the right-hand edge of the mob
         `(mob X-position + mob width)
	ld	L;mob_xpos      [IX+#mob.X.lo]
	ld	H;mob_xpos      [IX+#mob.X.hi]
	ld	C;mob_width     [IX+#mob.width]
	ld	B;mob_width     $00
	add	HL;mob_xpos     BC;mob_width
        
	ld	DE;sonic_xpos   [$.SONIC.X]
	
        `is Sonic to the right of the mob?
	xor	A;zero			        `set A to 0, clearing the carry flag
	sbc	HL;xpos         DE;sonic_xpos
	ret	c                               `return carry-set for no-collision
        
        `------------------------------------------------------------------------------
	
        `calculate the mob's left edge:
         `note that the mob provides an 'indent'. the sprite may well begin at
         `a certain X-position but the graphic within may be indented a little
	ld	L;mob_xpos      [IX+#mob.X.lo]
	ld	H;mob_xpos      [IX+#mob.X.hi]
	ld	A;mob_left      [$.TEMP6]       `get the mob's left indent
	ld	C;mob_left      A;zero
	add	HL;mob_xpos     BC;mob_left     `combine the two
	
        ``now swap the mob's X-position with the previous calculation of Sonic's
          X-position. HL will be Sonic's X-position and DE will be the mob's``
        ex	DE;mob_xpos     HL;sonic_xpos
	
        `calculate Sonic's right edge:
	ld	A;sonic_width   [$.SONIC.width]
	ld	C;sonic_width   A;sonic_width   `note that B is still 0
	add	HL;sonic_xpos   BC;sonic_width
        
        `is Sonic to the left of the mob?
	xor	A;zero			        `set A to 0, clearing the carry flag
	sbc	HL;sonic_xpos, DE;mob_xpos
	ret	c                               `return carry-set for no-collision
	
        `------------------------------------------------------------------------------
        
        `calculate the mob's bottom edge
	ld	L;mob_ypos      [IX+#mob.Y.lo]
	ld	H;mob_ypos      [IX+#mob.Y.hi]
	ld	C;mob_height    [IX+#mob.height]
	add	HL;mob_ypos     BC;mob_height
	
        ld	DE;sonic_ypos   [$.SONIC.Y]
        xor	A;zero			        `set A to 0, clearing the carry flag
	sbc	HL;ypos         DE;sonic_ypos
	ret	c                               `return carry-set for no-collision
	
        `calculate the mob's top edge (including the indent)
	ld	L;mob_ypos      [IX+#mob.Y.lo]
	ld	H;mob_ypos      [IX+#mob.Y.hi]
	ld	A;mob_top       [$.TEMP7]
	ld	C;mob_top       A;mob_top
	add	HL;mob_ypos     BC;mob_top
	
        ex	DE              HL
	
	ld	A               [$.SONIC.height]
	ld	C               A
	add	HL              BC
	xor	A;zero                          `set A to 0, clearing the carry flag
	sbc	HL              DE
	
        ret                                     `return carry-set for no-collision
}

PROC    :increaseRings                          SECTION ::mobs                  `$39AC
        `==============================================================================
        `NOTE: why does this not just use DAA?
PARAMS  A;count         HELP ""Number of rings to add
{
        `add the given number to the total ring count
	ld	C;count         A;count
	ld	A;rings         [$.RINGS]
	add	A;rings         C;count
	ld	C;rings         A;rings         `move the new total to C
	
        and	%00001111                       `look at the last digit $0-$F
	cp	10                              `is it above $A? (11-16)
	jr	c,.is100rings                           
	
        ld	A;rings         C;rings
	add	A;rings         $06             `TODO: WHY????
	ld	C;rings         A;rings
        
        `------------------------------------------------------------------------------
        
.is100rings
        ld	A;rings         C;rings
	cp	100
	jr	c,.pickupRing                   `if not yet 100, keep going
	
        `subtract 100 rings
        sub	100
	ld	[$.RINGS]       A;rings
        
        `add 1 to the lives count
	ld	A;lives         [$.LIVES]
	inc	A;lives
	ld	[$.LIVES]       A;lives
        
        `play the 1-up sound effect
	ld	A;sfx           $09
	rst	:playSFX
	
        ret
	
        `------------------------------------------------------------------------------
        
.pickupRing
        `update the ring total
        ld	[$.RINGS]       A;rings
	`play the pickup-ring sound
        ld	A;sfx           $02
	rst	:playSFX
	
        ret
}

PROC    :increaseScore                          SECTION ::mobs                  `$39D8
        `==============================================================================
PARAMS  C;thousands     HELP ""Thousands to add to the score
        D;hundreds      HELP ""Hundreds to add to the score
        E;tens          HELP ""Tens to add to the score 
{
	ld	HL;score        $.SCORE_TENS    `read the tens unit of the score
	ld	A;tens          E;tens          `handle the amount to add
	add	A;tens          [HL;score]      `add the tens to the score
	daa	                                `adjust to binary-coded-decimal
	ld	[HL;score]      A;tens          `save the new tens value
        
	dec	HL;score                        `move down to hundreds units
	ld	A;hundreds      D;hundreds      `handle the amount to add
	adc	A;hundreds      [HL;score]      `add the hundreds to the score
	daa	                                `adjust to binary-coded-decimal
	ld	[HL;score]      A;hundreds      `save the new hundreds value
	
        dec	HL;score                        `move down to thousands units
        ld	A;thousands     C;thousands     `handle the amount to add
	adc	A;thousands     [HL;score]      `add the thousands to the score
	daa	                                `adjust to binary-coded-decimal
	ld	[HL;score]      A;thousands     `save the new thousands value
	
        `push the current thousands value to the side
        ld	C;thousands     A;thousands
        
	dec	HL;score                        `move down to millions units
	ld	A;millions      $00
	adc	A;millions      [HL;score]
	daa	
	ld	[HL;score]      A;millions
        
        `------------------------------------------------------------------------------
        
        `check if current score qualifies for an extra life
	ld	HL;score_1up    $.SCORE_1UP
	ld	A;thousands     C;thousands
	cp	[HL;score_1up]
	ret	c
	
        `increase the score requirement for an extra life to the next multiple
	ld	A;score_1up     !SCORE_1UP
	add	A;score_1up     [HL;score_1up]
	daa	                                `adjust to binary-coded-decimal
	ld	[HL;score_1up]  A;score_1up
        
        `add an extra life
	ld	HL;lives        $.LIVES
	inc	[HL;lives]
        `play extra life sound effect
	ld	A;sfx           $09
	rst	:playSFX
	
        ret
}

PROC    :updateTime                             SECTION ::mobs                  `$3A03
        `==============================================================================
PARAMS  IY;vars         HELP ""Address of the common variables (used throughout)
{        
        `is Sonic dead? if so, exit now
	bit	0,[IY+#vars.scrollRingFlags]
	ret	nz
        
        `address of level time?
	ld	HL,$.TIME_FRAMES
        
        `is the time counting down? (special stages)
	bit	0,[IY+#vars.timeLightningFlags]
	jr	nz,.countdown
	
        `time is counting up:
        `------------------------------------------------------------------------------
        
        `wait 60 frames for a second
         `(TODO: detect PAL/NTSC and use the correct frame rate)
        ld	A;frames        [HL;time]       `load the current frame-count
	inc	A;frames                        `add another frame
	cp	60                              `is it 60 or less?
	jr	c,._1                           `if so, keep going
	xor	A;zero                          `otherwise, set frame-count to 0
._1	ld	[HL;time]       A;frames        `update the frame counter
        
        `increase seconds counter:
	dec	HL;time                         `move down to the seconds counter
	ccf	                                `flip the carry flag
	ld	A;seconds       [HL;time]       `read the number of seconds
	adc	A;seconds       $00             `if frame count hit 60, add a second
	daa	                                `adjust up to binary-coded-decimal
	cp	$60                             `60 seconds? (BCD)
	jr	c,._2                           `if not, keep going
	xor	A;zero                          `otherwise, set A to 0
._2	ld	[HL;time]       A;seconds       `update the seconds counter
        
        `increase minutes counter:
	dec	HL;time                         `move down to the minute counter
	ccf	                                `flip the carry flag
	ld	A;minutes       [HL;time]       `read the number of minutes
	adc	A;minutes       $00             `if seconds hit 60, add a minute
	daa	                                `adjust up to binary-coded-decimal
	cp	$10                             `10 minutes?
	jr	c,._3                           `if not, keep going
	
        push	HL;time                         `put the minute counter addr aside
	call	:killPlayer                          `go do out-of-time
	pop	HL;time                         `go back to the minute counter addr
	xor	A;zero                          `reset to 0
        
._3	ld	[HL;time]       A;minutes       `update the minute counter
	ret                                     `exit!
	
        `time is counting down:
        `------------------------------------------------------------------------------
.countdown
        `wait 60 frames for a second
         `(TODO: this is a repeat of above, so could be re-organised to share)
	ld	A;frames        [HL;time]       `load the current frame-count
	inc	A;frames                        `add another frame
	cp	60                              `is it 60 or less?
	jr	c,._5                           `if so, keep going
	xor	A;zero                          `otherwise, set frame-count to 0
._5	ld	[HL;time]       A;frames        `update the frame counter
        
	dec	HL;time                         `move down to the seconds counter
	ccf	                                `flip the carry flag
	ld	A;seconds       [HL;time]       `read the number of seconds
	sbc	A;seconds       $00             `if frame count hit 60 remove a second
	daa	                                `adjust up to binary-coded-decimal
	cp	$60                             `when seconds hit zero, no carry
	jr	c,._6                           `above 0 seconds, keep going
	ld	A;seconds       $59             `otherwise, loop around to 59 seconds
._6	ld	[HL;time]       A;seconds       `update the seconds counter
        
	dec	HL;time                         `move down to the minutes counter
	ccf	                                `flip the carry flag
	ld	A;minutes       [HL;time]       `read the number of minutes
	sbc	A;minutes       $00             `if seconds hit 0, remove a minute
	daa	                                `adjust up to binary-coded-decimal
	cp	$60                             `when minutes hit zero, no carry
	jr	c,._7                           `above 0 minutes, keep going
	
        `set some flags?
        ld	A               $01
	ld	[$.D289]        A
	set	2,[IY+#vars.flags9]
        
	xor	A;zero
._7	ld	[HL;time]       A;zero
	
        ret
}

        `seemingly unused?
TABLE   :_3a62                                  SECTION ::mobs                  `$3A62
{
        BYTE    $01, $30, $00
}

`solidity pointer table
TABLE   :S1_Solidity_Blocks                    SECTION ::mobs                  `$3A65
{
        WORD    .greenHill      .bridge         .jungle
        WORD    .labyrinth      .scrapBrain     .skyBaseInterior
        WORD    .specialStage   .skyBaseExterior

INDEX   .greenHill		                                                `$3A75
        BYTE    $00 $16 $10 $10 $10 $00 $00 $08 $09 $0A $05 $06 $07 $03 $04 $01
        BYTE    $02 $10 $00 $00 $00 $10 $10 $00 $00 $00 $10 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $10 $10 $0C
        BYTE    $0D $0E $0F $0B $10 $10 $10 $10 $00 $10 $10 $10 $00 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $16 $16 $12 $10 $15 $00 $00 $10 $16 $1E $16
        BYTE    $11 $10 $00 $10 $10 $1E $1E $1E $10 $1E $00 $00 $16 $1E $16 $1E
        BYTE    $00 $27 $1E $00 $27 $27 $27 $27 $27 $16 $27 $27 $00 $00 $00 $00
        BYTE    $00 $00 $00 $14 $00 $00 $05 $0A $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $80 $80 $90 $80 $96 $90 $80 $90 $80 $80 $80 $A7 $A7 $A7 $A7 $A7
        BYTE    $A7 $A7 $A7 $A7 $A7 $00 $00 $00 $00 $90 $9E $80 $80 $80 $80 $80
        BYTE    $90 $00 $00 $00 $00 $00 $00 $00
        
 INDEX  .bridge                                                                 `$3B2D
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $13 $10 $12 $12 $13 $00 $00 $00 $00 $00 $00 $10 $10 $00 $00 $00
        BYTE    $12 $13 $10 $13 $12 $00 $00 $00 $07 $2B $00 $00 $08 $00 $09 $06
        BYTE    $05 $29 $10 $2A $0A $00 $00 $00 $10 $10 $2E $00 $2D $00 $00 $00
        BYTE    $00 $00 $80 $80 $80 $00 $80 $80 $80 $80 $00 $00 $80 $00 $00 $80
        BYTE    $2C $27 $10 $00 $00 $00 $80 $80 $10 $16 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $12 $10 $13 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $13 $16 $16 $12 $00 $00 $00 $00 $10 $2D $2E $00 $00 $00 $00 $00
        
INDEX .jungle                                                                   `$3BBD
        BYTE    $00 $10 $00 $00 $00 $00 $00 $00 $10 $10 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $10 $10 $10 $10 $10 $10 $10 $16 $16 $16 $16 $27 $16
        BYTE    $1E $10 $10 $00 $00 $00 $00 $00 $00 $10 $00 $00 $10 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $27 $00 $00 $10
        BYTE    $11 $00 $01 $00 $00 $10 $10 $00 $04 $01 $02 $03 $06 $07 $05 $08
        BYTE    $09 $0A $10 $0E $0F $05 $0A $04 $01 $10 $10 $17 $00 $0B $05 $14
        BYTE    $0A $00 $10 $27 $10 $00 $00 $00 $10 $1E $00 $10 $10 $00 $00 $10
        BYTE    $10 $10 $00 $00 $00 $1E $00 $27 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $80 $80 $80 $80 $80 $A7 $80 $27 $A7 $A7 $A7 $A7 $A7 $A7 $A7
        BYTE    $A7 $A7 $80 $80 $10 $10 $96 $96 $16 $16 $16 $16 $00 $00 $00 $00

INDEX   .labyrinth                                                              `$35CD
        BYTE    $00 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16
        BYTE    $16 $16 $16 $16 $16 $16 $16 $16 $00 $00 $00 $00 $00 $00 $80 $27
        BYTE    $00 $00 $00 $00 $00 $00 $80 $27 $00 $00 $00 $00 $00 $27 $A7 $16
        BYTE    $00 $00 $1E $27 $00 $1E $00 $27 $00 $27 $00 $16 $27 $27 $9E $80
        BYTE    $1E $1E $1E $16 $16 $16 $16 $16 $27 $1E $1E $16 $16 $16 $16 $16
        BYTE    $06 $07 $00 $00 $08 $09 $02 $01 $12 $05 $14 $15 $0A $13 $04 $03
        BYTE    $04 $00 $04 $03 $08 $09 $06 $07 $03 $01 $02 $01 $0A $06 $09 $05
        BYTE    $00 $00 $04 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $16 $16 $10 $16 $16 $16 $16 $16 $00 $27 $16 $16 $16 $16 $00
        BYTE    $1E $00 $27 $1E $00 $1E $00 $00 $01 $04 $01 $04 $09 $06 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $A8 $00 $00 $00 $00 $00 $00 $00

INDEX   .scrapBrain                                                             `$3D0D
        BYTE    $00 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $1E $1E $1E $1A
        BYTE    $1B $1C $1D $1F $20 $21 $22 $23 $24 $1B $1C $16 $1E $1E $1E $1E
        BYTE    $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $27
        BYTE    $27 $27 $04 $03 $02 $01 $08 $09 $0A $05 $06 $07 $0A $05 $03 $02
        BYTE    $15 $14 $16 $16 $13 $12 $10 $10 $10 $10 $10 $10 $10 $10 $16 $27
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $1E $00 $1E $1E $1E $00 $00 $10 $80 $80 $27 $27 $27
        BYTE    $16 $16 $27 $27 $27 $1E $1E $16 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $02 $03 $90 $80 $9E $16 $16 $02 $03 $1B $1C $16 $16 $19 $18
        BYTE    $25 $26 $00 $00 $00 $27 $27 $1E $1E $27 $1E $00 $00 $00 $00 $1E
        BYTE    $27 $1E $27 $9E $9E $16 $16 $00 $00 $1E $16 $1E $1E $90 $90 $90
        BYTE    $16 $16 $16 $16 $00 $00 $00 $00 $A7 $9E $00
        
INDEX   .SkyBaseInterior                                                        `$3DC8
        BYTE    $00 $10 $16 $16 $10 $10 $10 $10 $10 $00 $00 $16 $16 $1E $00 $00
        BYTE    $00 $00 $10 $10 $10 $00 $90 $80 $1E $00 $00 $00 $10 $10 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $03 $04 $00 $00 $08 $09 $0A $16 $13
        BYTE    $15 $02 $01 $00 $07 $06 $05 $16 $14 $12 $0A $05 $10 $10 $00 $00
        BYTE    $03 $02 $10 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00 $10 $10
        BYTE    $10 $00 $00 $10 $00 $10 $00 $00 $00 $10 $10 $10 $10 $16 $16 $04
        BYTE    $03 $03 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $10 $10 $16 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $16 $00 $00 $00 $00 $00 $00 $00 $00 $10 $00 $00 $00 $00 $00 $00
        BYTE    $00 $1E $00 $00 $00 $1E $1E $10 $00 $00 $10 $10 $1E $1E $16 $16
        BYTE    $1E $1E $1E $1E $1E $00 $10 $1E $1E $10 $10 $1E $00 $02 $0A $16
        BYTE    $00 $00 $00 $00 $00 $00 $10 $1E $16 $1E $00 $10 $10 $10 $10 $10
        BYTE    $1E $00 $10 $00 $00 $10 $10 $10 $10 $1E $90 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $9E $1E $00 $00 $00 $00 $00 $00 $00 $00 $00
        
INDEX   .specialStage                                                           `$3EA8 
        BYTE    $00 $27 $27 $27 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $1E $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $27 $00 $00 $00 $00 $00 $27 $27 $16 $00 $00 $00
        BYTE    $27 $1E $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        
INDEX   .skyBaseExterior                                                        `$3F28 
        BYTE    $00 $27 $27 $16 $1E $1E $16 $27 $27 $1E $1E $00 $00 $16 $27 $27
        BYTE    $16 $1E $1E $16 $16 $16 $16 $01 $02 $04 $03 $1D $1C $1A $1B $01
        BYTE    $02 $04 $03 $1D $1C $1A $1B $00 $00 $00 $00 $00 $00 $00 $16 $9E
        BYTE    $9E $80 $1E $27 $A7 $A7 $80 $80 $16 $16 $80 $1E $1E $27 $27 $27
        BYTE    $16 $1E $16 $16 $16 $16 $16 $16 $27 $00 $1E $00 $00 $00 $00 $00
        BYTE    $00 $00 $16 $16 $16 $16 $16 $16 $16 $16 $A7 $A7 $9E $9E $16 $00
        BYTE    $9E $A7 $80 $9E $A7 $80 $00 $00 $00 $1C $1C $E4 $E4 $12 $12 $12
        BYTE    $EE $EE $EE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $12 $EE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $08 $08 $08 $08 $06 $06 $06
        BYTE    $06 $06 $06 $03 $03 $03 $03 $03
}

`======================================================================================

TABLE   :Unknown                                SECTION ::mobs   
{
`UNKNOWN DATA -- could possibly be part of solidity data on the previous bank?
        BYTE    $03 $08 $03 $03 $03 $03 $03 $03 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $03 $03 $04 $04 $03 $03 $03 $03 $00
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $9E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $BE $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $DE $40
        BYTE    $FE $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $1C $1C
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $1C $1C
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C
        BYTE    $1C $1C $1C $1C $1C $1C $80 $80 $80 $80 $80 $80 $80 $80 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7C $41 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $8C $41 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $AC $41 $CC $41
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $04 $04 $04 $04
        BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04
        BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $04 $04 $04 $04
        BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04
        BYTE    $04 $04 $04 $04 $80 $80 $80 $80 $80 $80 $80 $80 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $4A $42 $7E $40 $6A $42 $8A $42
        BYTE    $AA $42 $CA $42 $EA $42 $0A $43 $2A $43 $4A $43 $6A $43 $8A $43
        BYTE    $AA $43 $CA $43 $EA $43 $0A $44 $2A $44 $4A $44 $6A $44 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $1F $1F $1F $1F $1F $1F
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $18 $18 $17 $17 $16 $16
        BYTE    $15 $15 $14 $14 $13 $13 $12 $12 $11 $11 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $11 $11 $12 $12 $13 $13
        BYTE    $14 $14 $15 $15 $16 $16 $17 $17 $18 $18 $0F $0E $0D $0C $0B $0A
        BYTE    $09 $08 $07 $06 $05 $04 $03 $02 $01 $00 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $2F $2E $2D $2C $2B $2A
        BYTE    $29 $28 $27 $26 $25 $24 $23 $22 $21 $20 $1F $1E $1D $1C $1B $1A
        BYTE    $19 $18 $17 $16 $15 $14 $13 $12 $11 $10 $10 $11 $12 $13 $14 $15
        BYTE    $16 $17 $18 $19 $1A $1B $1C $1D $1E $1F $20 $21 $22 $23 $24 $25
        BYTE    $26 $27 $28 $29 $2A $2B $2C $2D $2E $2F $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $00 $01 $02 $03 $04 $05
        BYTE    $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F $0F $0F $0F $0F $0F $0F
        BYTE    $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F
        BYTE    $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $00 $00 $01 $01 $02 $02
        BYTE    $03 $03 $04 $04 $05 $05 $06 $06 $07 $07 $08 $08 $09 $09 $0A $0A
        BYTE    $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F $10 $10 $11 $11 $12 $12
        BYTE    $13 $13 $14 $14 $15 $15 $16 $16 $17 $17 $18 $18 $19 $19 $1A $1A
        BYTE    $1B $1B $1C $1C $1D $1D $1E $1E $1F $1F $20 $20 $21 $21 $22 $22
        BYTE    $23 $23 $24 $24 $25 $25 $26 $26 $27 $27 $27 $27 $26 $26 $25 $25
        BYTE    $24 $24 $23 $23 $22 $22 $21 $21 $20 $20 $1F $1F $1E $1E $1D $1D
        BYTE    $1C $1C $1B $1B $1A $1A $19 $19 $18 $18 $17 $17 $16 $16 $15 $15
        BYTE    $14 $14 $13 $13 $12 $12 $11 $11 $10 $10 $0F $0F $0E $0E $0D $0D
        BYTE    $0C $0C $0B $0B $0A $0A $09 $09 $08 $08 $07 $07 $06 $06 $05 $05
        BYTE    $04 $04 $03 $03 $02 $02 $01 $01 $00 $00 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $08 $08 $09 $09 $0A $0A
        BYTE    $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $0F $0F $0E $0E $0D $0D
        BYTE    $0C $0C $0B $0B $0A $0A $09 $09 $08 $08 $1F $1F $1F $1F $1F $1F
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $17 $17 $17 $17 $17 $17
        BYTE    $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17
        BYTE    $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $7E $40 $E8 $44 $08 $45
        BYTE    $28 $45 $48 $45 $68 $45 $88 $45 $A8 $45 $C8 $45 $E8 $45 $08 $46
        BYTE    $28 $46 $48 $46 $68 $46 $88 $46 $A8 $46 $C8 $46 $E8 $46 $08 $47
        BYTE    $28 $47 $48 $47 $68 $47 $88 $47 $A8 $47 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40 $7E $40
        BYTE    $7E $40 $7E $40 $7E $40 $7E $40 $C8 $47 $E8 $47 $08 $48 $28 $48
        BYTE    $48 $48 $68 $48 $88 $48 $A8 $48 $10 $11 $12 $13 $14 $15 $16 $17
        BYTE    $18 $19 $1A $1B $1C $1D $1E $1F $20 $21 $22 $23 $24 $25 $26 $27
        BYTE    $28 $29 $2A $2B $2C $2D $2E $2F $F0 $F1 $F2 $F3 $F4 $F5 $F6 $F7
        BYTE    $F8 $F9 $FA $FB $FC $FD $FE $FF $00 $01 $02 $03 $04 $05 $06 $07
        BYTE    $08 $09 $0A $0B $0C $0D $0E $0F $0F $0E $0D $0C $0B $0A $09 $08
        BYTE    $07 $06 $05 $04 $03 $02 $01 $00 $FF $FE $FD $FC $FB $FA $F9 $F8
        BYTE    $F7 $F6 $F5 $F4 $F3 $F2 $F1 $F0 $2F $2E $2D $2C $2B $2A $29 $28
        BYTE    $27 $26 $25 $24 $23 $22 $21 $20 $1F $1E $1D $1C $1B $1A $19 $18
        BYTE    $17 $16 $15 $14 $13 $12 $11 $10 $F8 $F8 $F9 $F9 $FA $FA $FB $FB
        BYTE    $FC $FC $FD $FD $FE $FE $FF $FF $00 $00 $01 $01 $02 $02 $03 $03
        BYTE    $04 $04 $05 $05 $06 $06 $07 $07 $08 $08 $09 $09 $0A $0A $0B $0B
        BYTE    $0C $0C $0D $0D $0E $0E $0F $0F $10 $10 $11 $11 $12 $12 $13 $13
        BYTE    $14 $14 $15 $15 $16 $16 $17 $17 $18 $18 $19 $19 $1A $1A $1B $1B
        BYTE    $1C $1C $1D $1D $1E $1E $1F $1F $20 $20 $21 $21 $22 $22 $23 $23
        BYTE    $24 $24 $25 $25 $26 $26 $27 $27 $27 $27 $26 $26 $25 $25 $24 $24
        BYTE    $23 $23 $22 $22 $21 $21 $20 $20 $1F $1F $1E $1E $1D $1D $1C $1C
        BYTE    $1B $1B $1A $1A $19 $19 $18 $18 $17 $17 $16 $16 $15 $15 $14 $14
        BYTE    $13 $13 $12 $12 $11 $11 $10 $10 $0F $0F $0E $0E $0D $0D $0C $0C
        BYTE    $0B $0B $0A $0A $09 $09 $08 $08 $07 $07 $06 $06 $05 $05 $04 $04
        BYTE    $03 $03 $02 $02 $01 $01 $00 $00 $FF $FF $FE $FE $FD $FD $FC $FC
        BYTE    $FB $FB $FA $FA $F9 $F9 $F8 $F8 $10 $10 $10 $10 $10 $10 $10 $11
        BYTE    $11 $11 $11 $11 $12 $12 $12 $12 $12 $12 $12 $12 $12 $11 $11 $11
        BYTE    $11 $11 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $11
        BYTE    $11 $11 $11 $11 $12 $12 $12 $12 $13 $13 $13 $14 $14 $15 $15 $15
        BYTE    $16 $16 $16 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $16 $16 $16
        BYTE    $15 $15 $15 $14 $14 $13 $13 $13 $12 $12 $12 $12 $11 $11 $11 $11
        BYTE    $11 $10 $10 $10 $10 $10 $10 $10 $08 $08 $08 $08 $08 $08 $08 $09
        BYTE    $09 $09 $09 $09 $0A $0A $0A $0A $0B $0B $0B $0C $0C $0D $0D $0D
        BYTE    $0E $0E $0E $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0E $0E $0E
        BYTE    $0D $0D $0D $0C $0C $0B $0B $0B $0A $0A $0A $0A $09 $09 $09 $09
        BYTE    $09 $08 $08 $08 $08 $08 $08 $08 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $11 $12 $13 $14 $15 $16 $17
        BYTE    $18 $19 $19 $1A $1A $1A $1B $1B $1B $1B $1B $1A $1A $1A $19 $19
        BYTE    $18 $17 $16 $14 $11 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $11 $11 $12 $12 $13 $13 $14 $14
        BYTE    $15 $15 $16 $16 $17 $17 $18 $18 $18 $18 $17 $17 $16 $16 $15 $15
        BYTE    $14 $14 $13 $13 $12 $12 $11 $11 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $08 $08 $09 $09 $0A $0A $0B $0B
        BYTE    $0C $0C $0D $0D $0E $0E $0F $0F $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $0F $0F $0E $0E $0D $0D $0C $0C
        BYTE    $0B $0B $0A $0A $09 $09 $08 $08 $FF $FF $FF $FF $FF $FF $FF $FF
        BYTE    $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF
        BYTE    $FF $FF $FF $FF $FF $FF $FF $FF $08 $08 $08 $08 $09 $09 $09 $09
        BYTE    $0A $0A $0A $0A $0B $0B $0B $0B $0B $0B $0B $0B $0A $0A $0A $0A
        BYTE    $09 $09 $09 $09 $08 $08 $08 $08 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $08 $08 $08 $08 $08 $08 $08 $08
        BYTE    $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
        BYTE    $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $09 $09 $09 $09
        BYTE    $0A $0A $0A $0A $0B $0B $0B $0B $0C $0C $0C $0C $0D $0D $0D $0D
        BYTE    $0E $0E $0E $0E $0F $0F $0F $0F $0F $0F $0F $0F $0E $0E $0E $0E
        BYTE    $0D $0D $0D $0D $0C $0C $0C $0C $0B $0B $0B $0B $0A $0A $0A $0A
        BYTE    $09 $09 $09 $09 $08 $08 $08 $08 $07 $07 $06 $06 $05 $05 $04 $04
        BYTE    $03 $03 $02 $02 $01 $01 $00 $00 $00 $00 $01 $01 $02 $02 $03 $03
        BYTE    $04 $04 $05 $05 $06 $06 $07 $07 $08 $08 $08 $08 $09 $09 $09 $09
        BYTE    $0A $0A $0A $0A $0B $0B $0C $0C $0C $0C $0B $0B $0A $0A $0A $0A
        BYTE    $09 $09 $09 $09 $08 $08 $08 $08 $80 $80 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $80 $80 $80 $80 $80 $80 $80 $80
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80
}

INCLUDE "mobs\sonic.oz80"

INCLUDE "mobs\powerups_common.oz80"
INCLUDE "mobs\boss_endSign.oz80"

`--------------------------------------------------------------------------------------
`and for whatever reason, the original ROM wedges the level palettes right here!

INCLUDE "palettes.oz80"

`--------------------------------------------------------------------------------------

INCLUDE "mobs\badnick_crabmeat.oz80"
INCLUDE "mobs\platform_swinging.oz80"
INCLUDE "mobs\explosion.oz80"
INCLUDE "mobs\platform.oz80"
INCLUDE "mobs\platform_falling.oz80"
INCLUDE "mobs\unknown_6ac1.oz80"
INCLUDE "mobs\badnick_buzzbomber.oz80"
INCLUDE "mobs\platform_moving.oz80"
INCLUDE "mobs\badnick_motobug.oz80"
INCLUDE "mobs\badnick_newtron.oz80"
INCLUDE "mobs\boss_greenHill.oz80"

TABLE   :S1_BossPalette				SECTION ::mobs                  `$731C
{
        BYTE $38 $20 $35 $1B $16 $2A $00 $3F $15 $3A $0F $03 $01 $02 $3E $00 
}

INCLUDE "mobs\boss_capsule.oz80"
INCLUDE "mobs\boss_animals.oz80"


PROC    :_77be                                  SECTION ::mobs                  `$77BE
        `==============================================================================
        `called by the boss mob code -- probably the exploded egg ship

PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	a,[$.D2EC]
	cp	$08
	jr	nc,._4
	ld	a,[$.D2B1]
	and	a
	jp	nz,._2
	ld	hl,$0c08
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ret	c
	bit	0,[iy+#vars.scrollRingFlags]
	ret	nz
	ld	a,[$.SONIC.flags]
	rrca	
	jr	c,._1
	and	$02
	jp	z,:_35fd
._1	ld	de,$0001
	ld	hl,[$.SONIC.Yspeed]
	ld	a,l
	cpl	
	ld	l,a
	ld	a,h
	cpl	
	ld	h,a
	ld	a,[$.SONIC.Ydirection]
	cpl	
	add	hl,de
	adc	a,$00
	ld	[$.SONIC.Yspeed],hl
	ld	[$.SONIC.Ydirection],a
	
        `stop Sonic's movement (reset speed and direction)
	xor	a;zero			        `set A to 0
	ld	l;zero,a;zero
	ld	h;zero,a;zero
	ld	[$.SONIC.Xspeed],hl;zero
	ld	[$.SONIC.Xdirection],a;zero
        
        ld	a,$18
	ld	[$.D2B1],a
	ld	a,$8f
	ld	[$.D2B1+1],a
	ld	a,$3f
	ld	[$.D2B3],a
        
	ld	a,$01
	rst	:rst_playSFX
	
        ld	a,[$.D2EC]
	inc	a
	ld	[$.D2EC],a
        
._2	ld	hl,[$.D216]
	ld	de,._7922
	add	hl,de
	bit	1,[ix+#mob.flags]
	jr	z,._3
	ld	de,$0012
	add	hl,de
._3	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	
        ld	hl,$.D2ED
	ld	[hl],$18
	inc	hl
	ld	[hl],$00
	ret
	
._4	xor	a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
        
	ld	de,$0024
	ld	hl,[$.D216]
	bit	1,[ix+#mob.flags]
	jr	z,._5
	ld	de,$0036
._5	add	hl,de
	ld	de,._7922
	add	hl,de
	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	ld	hl,$.D2ED+1                     `lo-addr of $.D2ED
	ld	a,[hl]
	cp	$0a
	jp	nc,._6
	dec	hl
	dec	[hl]
	ret	nz
	ld	[hl],$18
	inc	hl
	inc	[hl]
	call	:_7a3a
	ret
	
._6	ld	a,[$.D2ED+1]                    `lo-addr of $.D2ED
	cp	$3a
	jr	nc,._7
	ld	l,[ix+#mob.Ysubpixel]
	ld	h,[ix+#mob.Y.lo]
	ld	a,[ix+#mob.Y.hi]
	ld	de,$0020
	add	hl,de
	adc	a,$00
	ld	[ix+#mob.Ysubpixel],l
	ld	[ix+#mob.Y.lo],h
	ld	[ix+#mob.Y.hi],a
._7	ld	hl,$.D2ED+1                     `lo-addr of $.D2ED
	ld	a,[hl]
	cp	$5a
	jr	nc,._8
	inc	[hl]
	ret
	
._8	jr	nz,._9
	ld	[hl],$5b
	
	ld	a,[$.LEVEL_MUSIC]
	rst	:rst_playMusic
	
	ld	a,[iy+#vars.spriteUpdateCount]
	res	0,[iy+#vars.flags0]
	call	:waitForInterrupt
	ld	[iy+#vars.spriteUpdateCount],a
._9	ld	[ix+#mob.Xspeed.lo],$00
	ld	[ix+#mob.Xspeed.hi],$03
	ld	[ix+#mob.Xdirection],$00
	ld	[ix+#mob.Yspeed.lo],$60
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
	ld	[ix+#mob.spriteLayout.lo],._7922.lo
	ld	[ix+#mob.spriteLayout.hi],._7922.hi
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,[$.CAMERA_X]
	inc	d
	and	a
	sbc	hl,de
	ret	c
	
	`unlocks the screen?
	ld	[ix+#mob.type],$FF	        `remove mob?
	ld	hl,$2000		        `8192 -- max width of a level in pixels
	ld	[$.LEVEL_RIGHT],hl
	ld	hl,$0000
	ld	[$.CAMERA_X_GOTO],hl
	
	set	5,[iy+#vars.flags0]
	set	0,[iy+#vars.flags2]
	res	1,[iy+#vars.flags2]
	
	ld	a,[$.CURRENT_LEVEL]
	cp	$0b
	jr	nz,._10
	
	set	1,[iy+#vars.flags9]
	
._11	`UNKNOWN
	ld	hl,$DA28
	ld	de,$2000
	ld	a,12
	call	:decompressArt
	ret

`sprite layout
._7922  BYTE $2A, $2C, $2E, $30, $32, $FF
        BYTE $4A, $4C, $4E, $50, $52, $FF
        BYTE $6A, $6C, $6E, $70, $72, $FF
        
        BYTE $20, $10, $12, $14, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
        
        BYTE $2A, $16, $18, $1A, $32, $FF
        BYTE $4A, $4C, $4E, $50, $52, $FF
        BYTE $6A, $6C, $6E, $70, $72, $FF
        
        BYTE $20, $3A, $3C, $3E, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
        
        BYTE $2A, $34, $36, $38, $32, $FF
        BYTE $4A, $4C, $4E, $50, $52, $FF
        BYTE $6A, $6C, $6E, $70, $72, $FF
        
        BYTE $20, $10, $12, $14, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $54, $56, $66, $68, $FF
        
        BYTE $2A, $16, $18, $1A, $32, $FF
        BYTE $4A, $4C, $4E, $50, $52, $FF
        BYTE $6A, $5A, $5C, $70, $72, $FF
        
        BYTE $20, $3A, $3C, $3E, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $54, $56, $66, $68, $FF
        
        BYTE $2A, $34, $36, $38, $32, $FF
        BYTE $4A, $4C, $4E, $50, $52, $FF
        BYTE $6A, $5A, $5C, $70, $72, $FF
        
        BYTE $20, $06, $08, $0A, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
        
        BYTE $20, $06, $08, $0A, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
        
        BYTE $0E, $10, $12, $14, $16, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
}

PROC    :_79fa                                  SECTION ::mobs                  `$79FA
        `==============================================================================
        `called by green hill boss, jungle boss and final animation
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	a,[ix+#mob.Xspeed.lo]
	or	[ix+#mob.Xspeed.hi]
	ret	z
	ld	a,[$.FRAMECOUNT]
	bit	0,a
	ret	nz
	and	$02
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ld	hl,$fff8
	ld	de,$0010
	ld	c,$04
	bit	7,[ix+#mob.Xdirection]
	jr	z,._1
	ld	hl,$0028
	ld	c,$00
._1	ld	[$.TEMP4],hl
	ld	[$.TEMP6],de
	add	a,c
	call	:_3581
	ret
}

PROC    :_7a3a                                  SECTION ::mobs                  `$7A3A
        `==============================================================================
        `called by `:_77be`, capsule and final animation
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	call	:findEmptyMob
	ret	c
	push	hl
	call	:_LABEL_625_57
	and	$1f
	ld	l,a
	ld	h,$00
	ld	[$.TEMP1],hl
	call	:_LABEL_625_57
	and	$1f
	ld	l,a
	ld	h,$00
	ld	[$.TEMP3],hl
	pop	hl
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	c,[ix+#mob.Y.lo]
	ld	b,[ix+#mob.Y.hi]
	push	ix
	push	hl
	pop	ix
	xor	a;zero  			`set A to 0
	ld	[ix+#mob.type],$0A	        `explosion
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	hl,[$.TEMP1]
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	hl,[$.TEMP3]
	add	hl,bc
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	
        pop	ix
	ld	a,$01
	rst	:rst_playSFX
	ret
}

INCLUDE "mobs\meta_trip.oz80"
INCLUDE "mobs\flower.oz80"
INCLUDE "mobs\meta_blink.oz80"

PROC    :_7c41                                  SECTION ::mobs                  `$7C41
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        de              `e.g. $7DE1
        bc              `e.g. $7DDC
{
	ld	l,[ix+#mob.unknown17]

._1	ld	h,$00
	add	hl,bc
	ld	a,[hl]
	cp	$ff
	jr	nz,._2
	ld	l,$00
	ld	[ix+#mob.unknown17],l
	jp	._1
	
._2	inc	hl
	push	hl
	ld	l,a
	ld	h,$00
	add	hl,hl
	ld	c,l
	ld	b,h
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,bc
	add	hl,de
	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	pop	hl
	inc	[ix+#mob.unknown16]
	ld	a,[hl]
	cp	[ix+#mob.unknown16]
	ret	nc
	ld	[ix+#mob.unknown16],$00
	inc	[ix+#mob.unknown17]
	inc	[ix+#mob.unknown17]
	ret
}	

PROC    :findEmptyMob                           SECTION ::mobs                  `$7C7B
        `==============================================================================
        `search through the mob storage and find the first empty mob available
        `(this is used for spawning new mobs, such as bullets)
{
	ld	hl,$.MOBS
	ld	de,#mob.size
	ld	b, 31
        
.loop	ld	a,[hl]
	cp	$FF                             `"No Mob" number
	ret	z                               `if = $FF then exit, empty slot found
	add	hl,de
	djnz	.loop
	
        `no free mob place found!
	scf	                                `set the carry as a return flag
	ret
}

PROC    :_7c8c                                  SECTION ::mobs                  `$7C8C
        `==============================================================================
        `used by bosses to lock the screen?
        
PARAMS  hl, de
{
	ld	[$.CAMERA_X_GOTO],hl
	ld	[$.CAMERA_Y_GOTO],de
	
	ld	hl,[$.CAMERA_X]
	ld	[$.LEVEL_LEFT],hl
	ld	[$.LEVEL_RIGHT],hl
	
	ld	hl,[$.CAMERA_Y]
	ld	[$.LEVEL_TOP],hl
	ld	[$.LEVEL_BOTTOM],hl
	ret
}

PROC    :_7ca6                                  SECTION ::mobs                  `$7CA6
        `==============================================================================
{
	ld	hl,[$.CAMERA_X_GOTO]
	ld	de,[$.CAMERA_X]
	and	a
	sbc	hl,de
	ret	nz
	ld	hl,[$.CAMERA_Y_GOTO]
	ld	de,[$.CAMERA_Y]
	and	a
	sbc	hl,de
	ret	nz
	res	5,[iy+#vars.flags0]
	ret
}

PROC    :_LABEL_7CC1_12                         SECTION ::mobs                  `$7CC1
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
        D               `bit 7 sets A to $FF instead of 0 -- direction?
{
	bit	6, [iy+#vars.flags6]
	ret	nz
	
	ld	l, [ix+#mob.Ysubpixel]
	ld	h, [ix+#mob.Y.lo]
	
	xor	a;zero			        `set A to 0
	
	bit	7, d
	jr	z, ._1
	dec	a
._1	add	hl, de
	adc	a, [ix+#mob.Y.hi]
	ld	l, h
	ld	h, a
	add	hl, bc
	ld	a, [$.SONIC.width]
	ld	c, a
	xor	a;zero
	ld	b, a;zero
	sbc	hl, bc
	ld	[$.SONIC.Y], hl
	ld	a, [$.D2E8]
	ld	hl, [$.D2E6]
	ld	[$.SONIC.Yspeed], hl
	ld	[$.SONIC.Ydirection], a
	
	ld	hl, $.SONIC.flags
	set	7, [hl]
	
	ret
}

INCLUDE "mobs\badnick_chopper.oz80"

PROC    :mob_platform_fallVert                  SECTION ::mobs                  `$7E02
        `==============================================================================
        `log - vertical (Jungle)
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	hl,$0030
	ld	[$.D267],hl
	ld	hl,$0058
	ld	[$.D269],hl
	ld	[ix+#mob.width],$0c
	ld	[ix+#mob.height],$10
	ld	[ix+#mob.spriteLayout.lo],._7e89.lo
	ld	[ix+#mob.spriteLayout.hi],._7e89.hi
	bit	0,[ix+#mob.flags]
	jr	nz,._7e3c
	ld	a,[ix+#mob.Y.lo]
	ld	[ix+$12],a
	ld	a,[ix+#mob.Y.hi]
	ld	[ix+#mob.unknown13],a
	ld	[ix+#mob.unknown14],$c0
	set	0,[ix+#mob.flags]
._7e3c
	ld	[ix+#mob.Yspeed.lo],$80
	xor	a;zero
	ld	[ix+#mob.Yspeed.hi], a;zero
	ld	[ix+#mob.Ydirection], a;zero
	
	ld	a, [$.SONIC.Ydirection]
	and	a
	jp	m, ._1
	
	ld	hl, $0806
	ld	[$.TEMP6], hl
	call	:detectCollisionWithSonic
	jr	c, ._1
	ld	bc, $0010
	ld	e, [ix+#mob.Yspeed.lo]
	ld	d, [ix+#mob.Yspeed.hi]
	call	:_LABEL_7CC1_12
._1	ld	a, [$.FRAMECOUNT]
	and	$03
	ret	nz
	inc	[ix+#mob.unknown11]
	ld	a, [ix+#mob.unknown11]
	cp	[ix+#mob.unknown14]
	ret	c
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.unknown11], a;zero
	ld	[ix+#mob.Ysubpixel], a;zero
	ld	a, [ix+$12]
	ld	[ix+#mob.Y.lo], a
	ld	a, [ix+#mob.unknown13]
	ld	[ix+#mob.Y.hi], a
	ret

        `sprite layout
._7e89  BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $18, $1A, $FF, $FF, $FF, $FF
        BYTE $28, $2E, $FF, $FF, $FF, $FF
}

PROC    :mob_platform_fallHoriz                 SECTION ::mobs                  `$7E9B
        `==============================================================================
        `log - horizontal (Jungle)
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	hl,$0030
	ld	[$.D267],hl
	ld	hl,$0058
	ld	[$.D269],hl
	ld	[ix+#mob.width],$1a
	ld	[ix+#mob.height],$10
	ld	[ix+#mob.spriteLayout.lo],.layout.lo
	ld	[ix+#mob.spriteLayout.hi],.layout.hi
	bit	0,[ix+#mob.flags]
	jp	nz,:mob_platform_fallVert._7e3c
	ld	a,[ix+#mob.Y.lo]
	ld	[ix+$12],a
	ld	a,[ix+#mob.Y.hi]
	ld	[ix+#mob.unknown13],a
	ld	[ix+#mob.unknown14],$c6
	set	0,[ix+#mob.flags]
	jp	:mob_platform_fallVert._7e3c
        
        `sprite layout
.layout BYTE $FE, $FF, $FF, $FF, $FF, $FF                                       `$7ED9
        BYTE $6C, $6E, $6E, $48, $FF, $FF
        BYTE $FF
}

PROC    :mob_platform_roll                      SECTION ::mobs                  `$7EE6
        `==============================================================================
        `log - floating (Jungle)
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	[ix+#mob.width],$0a
	ld	[ix+#mob.height],$10
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$ffe8
	add	hl,de
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	set	0,[ix+#mob.flags]
._1	ld	[ix+#mob.Yspeed.lo],$40
	xor	a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	ld	a,[ix+#mob.unknown11]
	cp	$14
	jr	c,._2
	ld	[ix+#mob.Yspeed.lo],$c0
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
	
._2	ld	a,[$.SONIC.Ydirection]
	and	a
	jp	m,._8003
	
	ld	hl,$0806
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jp	c,:_8003
	ld	bc,$0010
	ld	e,[ix+#mob.Yspeed.lo]
	ld	d,[ix+#mob.Yspeed.hi]
	call	:_LABEL_7CC1_12
	ld	hl,[$.SONIC.Xspeed]
	ld	a,l
	or	h
	jr	z,._4
	ld	bc,$0012
	bit	7,h
	jr	z,._3
	ld	bc,$fffe
._3	ld	de,$0000
	call	:getFloorLayoutRAMAddressForMob
	ld	e,[hl]
	ld	d,$00
	ld	a,[$.LEVEL_SOLIDITY]
	add	a,a
	ld	c,a
	ld	b,d
	ld	hl,:S1_Solidity_Blocks
	add	hl,bc
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	add	hl,de
	ld	a,[hl]
	and	$3f
	ld	a,d
	ld	e,d
	jr	nz,._5
._4	ld	a,[$.SONIC.Xspeed.lo]
	ld	de,[$.SONIC.Xspeed.hi]
	sra	d
	rr	e
	rra	
._5	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	a,[ix+#mob.Xsubpixel]
	adc	hl,de
	ld	[ix+#mob.Xsubpixel],a
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[$.SONIC.Xsubpixel],a
	ld	de,$fffc
	add	hl,de
	ld	[$.SONIC.X],hl
	ld	de,[$.SONIC.Xspeed]
	bit	7,d
	jr	z,._6
	ld	a,e
	cpl	
	ld	e,a
	ld	a,d
	cpl	
	ld	d,a
	inc	de
+._6	ld	l,[ix+$12]
	ld	h,[ix+#mob.unknown13]
	add	hl,de
	ld	a,h
	cp	$09
	jr	c,._7
	sub	$09
	ld	h,a
._7	ld	[ix+$12],l
	ld	[ix+#mob.unknown13],h
	ld	e,a
	ld	d,$00
	ld	hl,._8019
	add	hl,de
	ld	e,[hl]
	ld	hl,._8022
	add	hl,de
	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	jr	._800b

`======================================================================================

        `ROM Header:
        
        BYTE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE $00 $0, $00 $00 $00
        
        BYTE "TMR SEGA"
        
        BYTE $59, $59
        BYTE $1B, $A5
        BYTE $76, $70, $00
        BYTE $40

`======================================================================================
        
        BYTE $00, $00, $00

        `jumped to by `doObjectCode_platform_roll`, OBJECT: log - floating (Jungle)
._8003  ld	[ix+#mob.spriteLayout.lo],._8022.lo
	ld	[ix+#mob.spriteLayout.hi],._8022.hi
._800b	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$28
	ret	c
	ld	[ix+#mob.unknown11],$00
	ret

._8019  BYTE $00, $00, $00, $12, $12, $12, $24, $24, $24

        `sprite layout
._8022  BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $3A, $3C, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $38, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $4C, $4E, $FF, $FF, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\boss_jungle.oz80"
INCLUDE "mobs\unknown_8128.oz80"
INCLUDE "mobs\badnick_yadrin.oz80"
INCLUDE "mobs\platform_bridge.oz80"

PROC    :mob_boss_bridge                        SECTION ::mobs                  `$8496
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	[ix+#mob.width], 30
	ld	[ix+#mob.height],28
	call	:_7ca6
	ld	[ix+#mob.spriteLayout.lo],:_865a.lo
	ld	[ix+#mob.spriteLayout.hi],:_865a.hi
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	
	ld	hl,$03a0
	ld	de,$0300
	call	:_7c8c
	
	`UNKNOWN
	ld	hl,$e508
	ld	de,$2000
	ld	a,12
	call	:decompressArt
	
	ld	hl,:S1_BossPalette
	ld	a,%00000010
	call	:loadPaletteOnInterrupt
	xor	a;zero
	ld	[$.D2EC],a;zero
	
	ld	a,#index_music_boss1
	rst	:rst_playMusic
	
	set	0,[ix+#mob.flags]
._1	ld	a,[ix+#mob.unknown11]
	and	a
	jr	nz,._2
	call	:_LABEL_625_57
	and	$01
	add	a,a
	add	a,a
	ld	e,a
	ld	d,$00
	ld	hl,:_8632
	add	hl,de
	ld	a,[hl]
	ld	[ix+#mob.X.lo],a
	inc	hl
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.X.hi],a
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.Y.lo],a
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.Y.hi],a
	inc	[ix+#mob.unknown11]
	jp	._6
	
._2	dec	a
	jr	nz,._3
	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
	ld	hl,$0380
	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	xor	a;zero
	sbc	hl,de
	jp	c,._6
	inc	[ix+#mob.unknown11]
	ld	[ix+$12],a;zero
	jp	._6
	
._3	dec	a
	jr	nz,._5
	xor	a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	inc	[ix+$12]
	ld	a,[ix+$12]
	cp	$64
	jp	nz,._6
	inc	[ix+#mob.unknown11]
	ld	a,[$.D2EC]
	cp	$08
	jr	nc,._6
	ld	hl,[$.SONIC.X]
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	and	a
	sbc	hl,de
	ld	hl,:_863a
	jr	c,._4
	ld	hl,:_864a
._4	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	c,[hl]
	inc	hl
	ld	b,[hl]
	inc	hl
	push	hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,bc
	ld	[$.TEMP3],hl
	pop	hl
	ld	b,$03
	
.loop	push	bc
	ld	a,[hl]
	ld	[$.TEMP4],a
	inc	hl
	ld	a,[hl]
	ld	[$.TEMP5],a
	inc	hl
	ld	a,[hl]
	ld	[$.TEMP6],a
	inc	hl
	ld	a,[hl]
	ld	[$.TEMP7],a
	inc	hl
	push	hl
	ld	c,$10
	call	:_85d1
	pop	hl
	pop	bc
	djnz	.loop
	
	ld	a,$01
	rst	:rst_playSFX
	jp	._6
	
._5	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$00
	ld	[ix+#mob.Ydirection],$00
	ld	hl,$03c0
	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	xor	a;zero
	sbc	hl,de
	jr	nc,._6
	ld	[ix+#mob.unknown11],a;zero
	
._6	ld	hl,$00a2
	ld	[$.D216],hl
	call	:_77be
	ret
}

PROC    :_85d1                                  SECTION ::mobs                  `$85D1
        `==============================================================================
        `called by bridge & labyrinth boss
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	push	bc
	call	:findEmptyMob
	pop	bc
	ret	c
	push	ix
	push	hl
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$0D	        `unknown mob
	ld	hl,[$.TEMP1]
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	hl,[$.TEMP3]
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown13],c
	ld	[ix+#mob.unknown14],a;zero
	ld	[ix+#mob.unknown15],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	hl,[$.TEMP4]
	xor	a;zero
	bit	7,h
	jr	z,._1
	dec	a
._1	ld	[ix+#mob.Xspeed.lo],l
	ld	[ix+#mob.Xspeed.hi],h
	ld	[ix+#mob.Xdirection],a
	ld	hl,[$.TEMP6]
	xor	a
	bit	7,h
	jr	z,._2
	dec	a
._2	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],a
	pop	ix
	ret
}

TABLE   :_8632                                  SECTION ::mobs                  `$8632
{
        BYTE $D4 $03 $C0 $03 $44 $04 $C0 $03
}
TABLE   :_863a                                  SECTION ::mobs                  `$863A
{
        BYTE $00 $00 $F6 $FF $C0 $FE $00 $FC $60 $FE $80 $FD $C0 $FD $00 $FF
}
TABLE   :_864a                                  SECTION ::mobs                  `$864A
{
        BYTE $20 $00 $F6 $FF $40 $01 $00 $FC $A0 $01 $80 $FD $40 $02 $00 $FF
}

`sprite layout
TABLE   :_865a                                  SECTION ::mobs                  `$865A
{
        BYTE $20, $22, $24, $26, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
}

INCLUDE "mobs\platform_balance.oz80"
INCLUDE "mobs\badnick_jaws.oz80"
INCLUDE "mobs\trap_spikeball.oz80"
INCLUDE "mobs\trap_spear.oz80"
INCLUDE "mobs\trap_fireball.oz80"
INCLUDE "mobs\meta_water.oz80"
INCLUDE "mobs\powerup_bubbles.oz80"

PROC    :_8eca                                  SECTION ::mobs                  `$8ECA
        `==============================================================================
        `unknown mob
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5, [ix+#mob.flags]
	xor	a;zero
	ld	[ix+#mob.spriteLayout.lo],a;zero
	ld	[ix+#mob.spriteLayout.hi],a;zero
	ld	a,[ix+#mob.unknown11]
	and	$0f
	jr	nz,._2
	call	:_LABEL_625_57
	ld	bc,$0020
	ld	d,$00
	and	$3f
	cp	$20
	jr	c,._1
	ld	bc,$ffe0
	ld	d,$ff
._1	ld	[ix+#mob.Xspeed.lo],c
	ld	[ix+#mob.Xspeed.hi],b
	ld	[ix+#mob.Xdirection],d
._2	ld	[ix+#mob.Yspeed.lo],$a0
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ex	de,hl
	ld	hl,[$.CAMERA_X]
	ld	bc,$0008
	xor	a;zero
	sbc	hl,bc
	jr	nc,._3
	ld	l,a;zero
	ld	h,a;zero
._3	and	a
	sbc	hl,de
	jr	nc,._4
	ld	hl,[$.CAMERA_X]
	ld	bc,$0100
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._4
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ex	de,hl
	ld	hl,[$.D2DC]
	and	a
	sbc	hl,de
	jr	nc,._4
	ld	hl,[$.CAMERA_Y]
	ld	bc,$fff0
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._4
	ld	hl,[$.CAMERA_Y]
	ld	bc,$00c0
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._5
._4	ld	[ix+#mob.type],$FF	        `remove mob?
._5	ld	hl,$0000
	ld	[$.TEMP4],hl
	ld	[$.TEMP6],hl
	ld	a,$0c
	call	:_3581
	inc	[ix+#mob.unknown11]
	ret
}

INCLUDE "mobs\null.oz80"
INCLUDE "mobs\badnick_burrobot.oz80"
INCLUDE "mobs\platform_float.oz80"

PROC    :_91eb                                  SECTION ::mobs                  `$91EB
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	call	:findEmptyMob
	ret	c
	ld	c,$42
	ld	a,[ix+#mob.type]
	cp	$41
	jr	nz,._1
	push	hl
	call	:_LABEL_625_57
	and	$0f
	ld	e,a
	ld	d,$00
	ld	hl,._9257
	add	hl,de
	ld	c,[hl]
	pop	hl
._1	ld	a,c
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	c,[ix+#mob.Y.lo]
	ld	b,[ix+#mob.Y.hi]
	push	ix
	push	hl
	pop	ix
	ld	[ix+#mob.type],a
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.Xsubpixel],a;zero
	call	:_LABEL_625_57
	and	$0f
	ld	l,a
	ld	h,$00
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.Ysubpixel],$00
	call	:_LABEL_625_57
	and	$0f
	ld	l,a
	xor	a;zero
	ld	h,a;zero
	add	hl,bc
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+$12],a;zero
	ld	[ix+#mob.flags],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	pop	ix
	ret

._9257  BYTE $42 $20 $20 $20 $42 $20 $20 $20 $42 $20 $20 $20 $42 $20 $20 $20

}

PROC    :mob_boss_labyrinth                     SECTION ::mobs                  `$9267
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5, [ix+#mob.flags]
	ld	[ix+#mob.width],  32
	ld	[ix+#mob.height], 28
	call	:_7ca6
	ld	[ix+#mob.spriteLayout.lo],._9493.lo
	ld	[ix+#mob.spriteLayout.hi],._9493.hi
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	
	ld	hl,$02d0
	ld	de,$0290
	call	:_7c8c
	
	set	1,[iy+#vars.flags9]
	
	`UNKNOWN
	ld	hl,$e508
	ld	de,$2000
	ld	a,12
	call	:decompressArt
	
	ld	hl,:S1_BossPalette
	ld	a,%00000010
	call	:loadPaletteOnInterrupt
	xor	a;zero
	ld	[$.D2EC],a;zero
	
	ld	a,#index_music_boss1
	rst	:rst_playMusic
	
	set	0,[ix+#mob.flags]
._1	ld	a,[ix+#mob.unknown11]
	and	a
	jr	nz,._2
	ld	a,[ix+#mob.unknown13]
	add	a,a
	add	a,a
	ld	e,a
	ld	d,$00
	ld	hl,._947b
	add	hl,de
	ld	a,[hl]
	ld	[ix+#mob.X.lo],a
	inc	hl
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.X.hi],a
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.Y.lo],a
	ld	a,[hl]
	inc	hl
	ld	[ix+#mob.Y.hi],a
	inc	[ix+#mob.unknown11]
	jp	._
	
._2	dec	a
	jr	nz,._5
	ld	a,[ix+#mob.unknown13]
	and	a
	jr	nz,._3
	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
	jp	._4
	
._3	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$00
	ld	[ix+#mob.Ydirection],$00
._4	ld	hl,._9487
	ld	a,[ix+#mob.unknown13]
	add	a,a
	ld	e,a
	ld	d,$00
	add	hl,de
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	and	a
	sbc	hl,de
	jp	nz,._
	inc	[ix+#mob.unknown11]
	ld	[ix+$12],$00
	jp	._
	
._5	dec	a
	jp	nz,._6
	xor	a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	inc	[ix+$12]
	ld	a,[ix+$12]
	cp	$64
	jp	nz,._
	inc	[ix+#mob.unknown11]
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$000f
	add	hl,de
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,$0022
	add	hl,bc
	ld	[$.TEMP3],hl
	ld	a,[ix+#mob.unknown13]
	and	a
	jp	z,._9432
	ld	a,[$.D2EC]
	cp	$08
	jp	nc,._
	call	:findEmptyMob
	jp	c,._
	push	ix
	push	hl
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$2F	        `unknown mob
	ld	hl,[$.TEMP1]
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	hl,[$.TEMP3]
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.flags],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	pop	ix
	jp	._
	
._6	ld	a,[ix+#mob.unknown13]
	and	a
	jr	nz,._7
	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$00
	ld	[ix+#mob.Ydirection],$00
	jp	._8
	
._7	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
._8	ld	hl,$948d
	ld	a,[ix+#mob.unknown13]
	add	a,a
	ld	e,a
	ld	d,$00
	add	hl,de
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	xor	a;zero
	sbc	hl,de
	jr	nz,._
	ld	[ix+#mob.unknown11],a;zero
	inc	[ix+#mob.unknown13]
	ld	a,[ix+#mob.unknown13]
	cp	$03
	jr	c,._
	ld	[ix+#mob.unknown13],$00
._	ld      hl,$00a2
	ld	[$.D216],hl
	call	:_77be
	ld	a,[$.D2EC]
	cp	$08
	ret	nc
	bit	7,[ix+#mob.Ydirection]
	ret	z
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ld	hl,$0010
	ld	[$.TEMP4],hl
	ld	hl,$0030
	ld	[$.TEMP6],hl
	ld	a,[$.FRAMECOUNT]
	and	$02
	call	:_3581
	ret
	
._9432	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$0004
	add	hl,de
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$fffa
	add	hl,de
	ld	[$.TEMP3],hl
	ld	hl,$ff00
	ld	[$.TEMP4],hl
	ld	hl,$ff00
	ld	[$.TEMP6],hl
	ld	c,$04
	call	:_85d1
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$0020
	add	hl,de
	ld	[$.TEMP1],hl
	ld	hl,$0100
	ld	[$.TEMP4],hl
	ld	c,$04
	call	:_85d1
	ld	a,$01
	rst	:rst_playSFX
	jp	._
        
._947b  BYTE $3C, $03, $60, $03, $EC, $02, $60, $02, $8C, $03, $60, $02
._9487  BYTE $28, $03, $B0, $02, $B0
._948c  BYTE $02, $60, $03, $60, $02, $60, $02

        `sprite layout
._9493  BYTE $20, $22, $24, $26, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
}

INCLUDE "mobs\unknown_94a5.oz80"
INCLUDE "mobs\unknown_96a8.oz80"
INCLUDE "mobs\unknown_96f8.oz80"
INCLUDE "mobs\platform_flipper.oz80"
INCLUDE "mobs\platform_bumper.oz80"
INCLUDE "mobs\unknown_9b75.oz80"
INCLUDE "mobs\unknown_9be8.oz80"

PROC    :_9c70                                  SECTION ::mobs                  `$9C70
        `==============================================================================
        `unknown mob
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.Xspeed.lo],$80
	ld	[ix+#mob.Xspeed.hi],$fe
	ld	[ix+#mob.Xdirection],$ff
	ld	[ix+#mob.spriteLayout.lo],._9c87.lo
	ld	[ix+#mob.spriteLayout.hi],._9c87.hi
	jp	:_9be8._9bfc

        `sprite layout
._9c87  BYTE $2C, $2E, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_trap_flameThrower                  SECTION ::mobs                  `$9C8E
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$000c
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$0012
	add	hl,de
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	call	:_LABEL_625_57
	ld	[ix+#mob.unknown11],a
	set	0,[ix+#mob.flags]
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ld	hl,$0000
	ld	[$.TEMP4],hl
	ld	a,[ix+#mob.unknown11]
	srl	a
	srl	a
	srl	a
	srl	a
	ld	c,a
	ld	b,$00
	add	a,a
	ld	e,a
	ld	d,$00
	ld	hl,:_9d6a
	add	hl,bc
	ld	a,[hl]
	ld	[ix+#mob.height],a
	ld	[ix+#mob.width],$06
	ld	hl,:_9d4a
	add	hl,de
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	or	h
	jr	z,._2
	ld	a,[ix+#mob.unknown11]
	add	a,a
	add	a,a
	add	a,a
	and	$1f
	ld	e,a
	ld	d,$00
	add	hl,de
	ld	b,$04
	
.loop	push	bc
	ld	a,[hl]
	inc	hl
	ld	e,[hl]
	inc	hl
	ld	d,$00
	push	hl
	ld	[$.TEMP6],de
	call	:_3581
	pop	hl
	pop	bc
	djnz	.loop
	
	ld	a,[ix+#mob.height]
	and	a
	jr	z,._2
	ld	hl,$0202
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	call	nc,:_35fd
._2	inc	[ix+#mob.unknown11]
	xor	a;zero
	ld	[ix+#mob.spriteLayout.lo],a;zero
	ld	[ix+#mob.spriteLayout.hi],a;zero
	ld	a,[ix+#mob.unknown11]
	cp	$70
	ret	nz
	ld	a,$17
	rst	:rst_playSFX
	ret
}

TABLE   :_9d4a                                  SECTION ::mobs                  `$9D4A
{
        BYTE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $9A $9D
        BYTE $BA $9D $DA $9D $7A $9D $7A $9D $7A $9D $DA $9D $BA $9D $9A $9D
}

TABLE   :_9d6a                                  SECTION ::mobs                  `$9D6A
{
        BYTE $00 $00 $00 $00 $00 $00 $00 $1B $1F $22 $25 $25 $25 $22 $1F $1B
        BYTE $00 $15 $1E $0E $1E $07 $1E $00 $00 $17 $1E $10 $1E $09 $1E $02
        BYTE $00 $19 $1E $12 $1E $0B $1E $04 $00 $1B $1E $14 $1E $0D $1E $06
        BYTE $00 $0C $1E $08 $1E $04 $1E $00 $00 $0E $1E $0A $1E $06 $1E $02
        BYTE $00 $10 $1E $0C $1E $08 $1E $04 $00 $11 $1E $0E $1E $0A $1E $06
        BYTE $00 $0F $1E $0A $1E $05 $1E $00 $00 $11 $1E $0C $1E $07 $1E $02
        BYTE $00 $13 $1E $0E $1E $09 $1E $04 $00 $15 $1E $10 $1E $0B $1E $06
        BYTE $00 $12 $1E $0C $1E $06 $1E $00 $00 $14 $1E $0E $1E $08 $1E $02
        BYTE $00 $16 $1E $10 $1E $0A $1E $04 $00 $18 $1E $12 $1E $0C $1E $06
}

PROC    :mob_door_left                          SECTION ::mobs                  `$9DFA
        `==============================================================================
        `door - one way left (Scrap Brain)
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	call	:_9ed4
	ld	a,[ix+#mob.unknown11]
	cp	$28
	jr	nc,._2
	ld	hl,$0005
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._2
	ld	de,$0005
	ld	a,[$.SONIC.Xdirection]
	and	a
	jp	m,._1
	ld	de,$ffec
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[$.SONIC.X],hl
	xor	a;zero
	ld	l;zero,a;zero
	ld	h;zero,a;zero
	ld	[$.SONIC.Xspeed],hl;zero
	ld	[$.SONIC.Xdirection],a;zero
._2	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$ffc8
	add	hl,de
	ld	de,[$.SONIC.X]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	and	a
	sbc	hl,de
	jr	c,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$ffe0
	add	hl,de
	ld	de,[$.SONIC.Y]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,$0050
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._3
	call	:_9eb4
	jr	._4
	
._3	call	:_9ec4
._4	ld	de,:_9f2b
._9e7e	ld	a,[ix+#mob.unknown11]
	and	$0f
	ld	c,a
	ld	b,$00
	ld	l,[ix+$12]
	ld	h,[ix+#mob.unknown13]
	and	a
	sbc	hl,bc
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	a,[ix+#mob.unknown11]
	srl	a
	srl	a
	srl	a
	srl	a
	and	$03
	add	a,a
	ld	c,a
	add	a,a
	add	a,a
	add	a,a
	add	a,c
	ld	c,a
	ld	b,$00
	ex	de,hl
	add	hl,bc
	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	ret
}

PROC    :_9eb4                                  SECTION ::mobs                  `$9EB4
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	a,[ix+#mob.unknown11]
	cp	$30
	ret	nc
	inc	a
	ld	[ix+#mob.unknown11],a
	dec	a
	ret	nz
	ld	a,$19
	rst	:rst_playSFX
	ret
}

`____________________________________________________________________________[$9EC4]___

PROC    :_9ec4                                  SECTION ::mobs   
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	a,[ix+#mob.unknown11]
	and	a
	ret	z
	dec	a
	ld	[ix+#mob.unknown11],a
	cp	$2f
	ret	nz
	ld	a,$19
	rst	:rst_playSFX
	ret
}

PROC    :_9ed4                                  SECTION ::mobs                  `$9ED4
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$04
	ld	a,[ix+#mob.unknown11]
	srl	a
	srl	a
	srl	a
	srl	a
	and	$03
	ld	e,a
	ld	a,$03
	sub	e
	add	a,a
	add	a,a
	add	a,a
	add	a,a
	ld	[ix+#mob.height],a
	bit	0,[ix+#mob.flags]
	ret	nz
	ld	bc,$0000
	ld	de,$fff0
	call	:getFloorLayoutRAMAddressForMob
	ld	de,$0014
	ld	a,[hl]
	cp	$a3
	jr	z,._1
	ld	de,$0004
	set	1,[ix+#mob.flags]
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	a,[ix+#mob.Y.lo]
	ld	[ix+$12],a
	ld	a,[ix+#mob.Y.hi]
	ld	[ix+#mob.unknown13],a
	set	0,[ix+#mob.flags]
	ret
}

`sprite layout
TABLE   :_9f2b                                  SECTION ::mobs                  `$9F2B
{
        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $0A, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_door_right                         SECTION ::mobs                  `$9F62
        `==============================================================================
        `door - one way right (Scrap Brain)
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	call	:_9ed4
	ld	a,[ix+#mob.unknown11]
	cp	$28
	jr	nc,._2
	ld	hl,$0005
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._2
	ld	de,$0005
	ld	a,[$.SONIC.Xdirection]
	and	a
	jp	m,._1
	ld	de,$ffec
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[$.SONIC.X],hl
        
	xor	a;zero
	ld	[$.SONIC.Xspeed.lo],a;zero
	ld	[$.SONIC.Xspeed.hi],a;zero
	ld	[$.SONIC.Xdirection],a;zero
        
._2	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$fff0
	add	hl,de
	ld	de,[$.SONIC.X]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	bc,$0024
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$ffe0
	add	hl,de
	ld	de,[$.SONIC.Y]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,$0050
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._3
	call	:_9eb4
	jr	._4
._3	call	:_9ec4
._4	ld	de,:_9fee
	jp	:mob_door_left._9e7e
}

`sprite layout
TABLE   :_9fee                                  SECTION ::mobs                  `$9FEE
{
        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_door                               SECTION ::mobs                  `$A025
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	call	:_9ed4
	ld	a,[ix+#mob.unknown11]
	cp	$28
	jr	nc,._2
	ld	hl,$0005
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._2
	ld	de,$0005
	ld	a,[$.SONIC.Xdirection]
	and	a
	jp	m,._1
	ld	de,$ffec
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[$.SONIC.X],hl
        
	xor	a;zero
	ld	[$.SONIC.Xspeed.lo],a;zero
	ld	[$.SONIC.Xspeed.hi],a;zero
	ld	[$.SONIC.Xdirection],a;zero
        
._2	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$ffc8
	add	hl,de
	ld	de,[$.SONIC.X]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	bc,$0024
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$ffe0
	add	hl,de
	ld	de,[$.SONIC.Y]
	xor	a;zero
	sbc	hl,de
	jr	nc,._3
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,$0050
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._3
	call	:_9eb4
	jr	._4
	
._3	call	:_9ec4
._4	ld	de,:_a0b1
	jp	:mob_door_left._9e7e
}

`sprite layout
TABLE   :_a0b1                                  SECTION ::mobs                  `$A0B1
{
        BYTE $38, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF

        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\trap_electic.oz80"

PROC    :mob_badnick_ballHog                    SECTION ::mobs                  `$A1AA
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$0a
	ld	[ix+#mob.height],$20
	ld	hl,$0803
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ld	hl,$0e00
	ld	[$.TEMP1],hl
	call	nc,:_35e5
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$01
	ld	[ix+#mob.Ydirection],$00
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$000a
	add	hl,de
	ex	de,hl
	ld	hl,[$.SONIC.X]
	ld	bc,$000c
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._3
	ld	bc,:_a2d2
	ld	a,[ix+#mob.unknown11]
	cp	$eb
	jr	c,._2
	jr	nz,._1
	ld	[ix+#mob.unknown16],$00
._1	ld	bc,:_a2d7
._2	ld	de,:_a2da
	call	:_7c41
	ld	a,[ix+#mob.unknown11]
	cp	$ed
	jp	nz,._6
	call	:findEmptyMob
	jp	c,._6
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	c,[ix+#mob.Y.lo]
	ld	b,[ix+#mob.Y.hi]
	push	ix
	push	hl
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$1C	        `ball from the Ball Hog
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],e
	ld	[ix+#mob.X.hi],d
	ld	hl,$0006
	add	hl,bc
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],$ff
	ld	[ix+#mob.Xdirection],$ff
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],$01
	ld	[ix+#mob.Ydirection],a;zero
	pop	ix
	jp	._6
	
._3	ld	bc,:_a2d2
	ld	a,[ix+#mob.unknown11]
	cp	$eb
	jr	c,._5
	jr	nz,._4
	ld	[ix+#mob.unknown16],$00
._4	ld	bc,:_a2d7
._5	ld	de,:_a30b
	call	:_7c41
	ld	a,[ix+#mob.unknown11]
	cp	$ed
	jr	nz,._6
	call	:findEmptyMob
	jp	c,._6
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	c,[ix+#mob.Y.lo]
	ld	b,[ix+#mob.Y.hi]
	push	ix
	push	hl
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$1C	        `ball from the Ball Hog
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],e
	ld	[ix+#mob.X.hi],d
	ld	hl,$0006
	add	hl,bc
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],$01
	ld	[ix+#mob.Xdirection],a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],$01
	ld	[ix+#mob.Ydirection],a;zero
	pop	ix
._6	inc	[ix+#mob.unknown11]
	ret
}

TABLE   :_a2d2                                  SECTION ::mobs                  `$A2D2
{
        BYTE $00, $1C, $01, $06, $FF
}
TABLE   :_a2d7                                  SECTION ::mobs                  `$A2D7
{
        BYTE $02, $18, $FF
}

`sprite layout
TABLE   :_a2da                                  SECTION ::mobs                  `$A2DA
{
        BYTE $40, $42, $FF, $FF, $FF, $FF
        BYTE $60, $62, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $44, $46, $FF, $FF, $FF, $FF
        BYTE $64, $66, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $40, $42, $FF, $FF, $FF, $FF
        BYTE $68, $6A, $FF, $FF, $FF, $FF
        BYTE $FF
}

TABLE   :_a30b                                  SECTION ::mobs                  `$A30B
{
        BYTE $50, $52, $FF, $FF, $FF, $FF
        BYTE $70, $72, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $4C, $4E, $FF, $FF, $FF, $FF
        BYTE $6C, $6E, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $50, $52, $FF, $FF, $FF, $FF
        BYTE $48, $4A, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :_a33c                                  SECTION ::mobs                  `$A33C
        `==============================================================================
        `mob: UNKNOWN (ball from Ball Hog?)
        
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	res	5,[ix+#mob.flags]
	ld	[ix+#mob.width],$0a
	ld	[ix+#mob.height],$0f
	ld	hl,$0101
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	call	nc,:_35fd
	bit	7,[ix+#mob.flags]
	jr	z,._1
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$fd
	ld	[ix+#mob.Ydirection],$ff
._1	ld	l,[ix+#mob.Yspeed.lo]
	ld	h,[ix+#mob.Yspeed.hi]
	ld	a,[ix+#mob.Ydirection]
	ld	de,$001f
	add	hl,de
	adc	a,$00
	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],a
	ld	a,[ix+#mob.unknown11]
	cp	$82
	jr	nc,._2
	ld	bc,:_a3b1
	ld	de,:_a3bb
	call	:_7c41
	jp	._4
	
._2	jr	nz,._3
	ld	[ix+#mob.unknown16],$00
	ld	a,$01
	rst	:rst_playSFX
._3	ld	bc,:_a3b4
	ld	de,:_a3bb
	call	:_7c41
._4	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$a5
	ret	c
	ld	[ix+#mob.type],$FF	`remove mob?
	ret
}

TABLE   :_a3b1                                  SECTION ::mobs                  `$A3B1
{
        BYTE $00, $08, $FF
}
TABLE   :_a3b4                                  SECTION ::mobs                  `$A3B4
{
        BYTE $01, $0C, $02, $0C, $03, $0C, $FF
}

`sprite layout
TABLE   :_a3bb                                  SECTION ::mobs                  `$A3BB
{
        BYTE $20, $22, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $74, $76, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $78, $7A, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $7C, $7E, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_switch                             SECTION ::mobs                  `$A3F8
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$0a
	ld	[ix+#mob.height],$11
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$0008
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	set	0,[ix+#mob.flags]
._1	ld	hl,$0001
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._3
	
	ld	a,[$.SONIC.Ydirection]
	and	a
	jp	m,._3
	
	ld	[ix+#mob.spriteLayout.lo],:_a48b.lo
	ld	[ix+#mob.spriteLayout.hi],:_a48b.hi
	ld	a,[$.LEVEL_SOLIDITY]
	cp	$03
	jr	nz,._2
	ld	[ix+#mob.spriteLayout.lo],:_a49b.lo
	ld	[ix+#mob.spriteLayout.hi],:_a49b.hi
._2	ld	bc,$0006
	ld	de,$0000
	call	:_LABEL_7CC1_12
	bit	1,[ix+#mob.flags]
	jr	nz,._4
	set	1,[ix+#mob.flags]
	ld	hl,$.D317
	call	:getLevelBitFlag
	ld	a,[hl]
	xor	c
	ld	[hl],a
	ld	a,$1a
	rst	:rst_playSFX
	jr	._4
	
._3	res	1,[ix+#mob.flags]
	ld	[ix+#mob.spriteLayout.lo],:_a493.lo
	ld	[ix+#mob.spriteLayout.hi],:_a493.hi
	ld	a,[$.LEVEL_SOLIDITY]
	cp	$03
	jr	nz,._4
	ld	[ix+#mob.spriteLayout.lo],$a3
	ld	[ix+#mob.spriteLayout.hi],$a4
._4	xor	a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],$02
	ld	[ix+#mob.Ydirection],a;zero
	ret
}

`sprite layout
TABLE   :_a48b                                  SECTION ::mobs                  `$A48B
{
        BYTE $1A, $1C, $FF, $FF, $FF, $FF
        BYTE $FF, $FF
}
TABLE   :_a493                                  SECTION ::mobs                  `$A493
{
        BYTE $3A, $3C, $FF, $FF, $FF, $FF
        BYTE $FF, $FF
}
TABLE   :_a49b                                  SECTION ::mobs                  `$A49B
{
        BYTE $38, $3A, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $34, $36, $FF, $FF
        BYTE $FF, $FF, $FF, $FF
}

PROC    :mob_door_switchActivated               SECTION ::mobs                  `$A4AB
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	call	:_9ed4
	ld	a,[ix+#mob.unknown11]
	cp	$28
	jr	nc,._2
	ld	hl,$0005
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._2
	ld	de,$0005
	ld	a,[$.SONIC.Xdirection]
	and	a
	jp	m,._1
	ld	de,$ffec
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ld	[$.SONIC.X],hl
        
	xor	a;zero
	ld	[$.SONIC.Xspeed.lo],a;zero
	ld	[$.SONIC.Xspeed.hi],a;zero
	ld	[$.SONIC.Xdirection],a;zero
	
._2	ld	hl,$.D317
	call	:getLevelBitFlag
	bit	1,[ix+#mob.flags]
	jr	z,._3
	ld	a,[hl]
	and	c
	jr	nz,._5
	jr	._4
	
._3	ld	a,[hl]
	and	c
	jr	z,._5
._4	ld	a,[ix+#mob.unknown11]
	cp	$30
	jr	nc,._6
	inc	a
	inc	a
	ld	[ix+#mob.unknown11],a
	jr	._6
	
._5	ld	a,[ix+#mob.unknown11]
	and	a
	jr	z,._6
	dec	a
	dec	a
	ld	[ix+#mob.unknown11],a
._6	ld	de,:_a51a
	jp	:mob_door_left._9e7e
}

`sprite layout
TABLE   :_a51a                                  SECTION ::mobs                  `$A51A
{
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $38, $FF, $FF, $FF, $FF, $FF
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $38, $FF, $FF, $FF, $FF, $FF
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF
}

PROC    :mob_badnick_caterkiller                SECTION ::mobs                  `$A551
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$06
	ld	[ix+#mob.height],$10
	ld	a,[$.FRAMECOUNT]
	and	$01
	jr	nz,._5
	ld	hl,:_a6b9
	bit	1,[ix+#mob.flags]
	jr	z,._1
	ld	hl,:_a769
._1	ld	e,[ix+#mob.unknown11]
	sla	e
	ld	d,$00
	add	hl,de
	ld	c,[hl]
	inc	hl
	ld	b,[hl]
	ld	l,[ix+#mob.Xsubpixel]
	ld	h,[ix+#mob.X.lo]
	ld	a,[ix+#mob.X.hi]
	add	hl,bc
	bit	7,b
	jr	z,._2
	adc	a,$ff
	jr	._3
	
._2	adc	a,$00
._3	ld	[ix+#mob.Xsubpixel],l
	ld	[ix+#mob.X.lo],h
	ld	[ix+#mob.X.hi],a
	ld	hl,:_a6e5
	add	hl,de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	ld	l,[ix+$12]
	ld	h,[ix+#mob.unknown13]
	add	hl,de
	ld	[ix+$12],l
	ld	[ix+#mob.unknown13],h
	ld	c,$00
	bit	7,h
	jr	z,._4
	ld	c,$ff
._4	ld	[ix+#mob.unknown14],c
._5	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	bit	1,[ix+#mob.flags]
	jr	nz,._7
	ld	hl,:_a711
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	add	hl,de
	ld	a,$24
	call	:_a688
	ld	a,$26
	call	:_a6a2
	ld	a,$26
	call	:_a688
	ld	a,$26
	call	:_a6a2
	ld	[ix+#mob.width],$06
	ld	hl,$0802
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ld	hl,$0000
	ld	[$.TEMP1],hl
	jr	c,._6
	call	:_35e5
	jr	._9
	
._6	ld	[ix+#mob.width],$16
	ld	hl,$0806
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	call	nc,:_35fd
	jr	._9
	
._7	ld	hl,:_a795
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	add	hl,de
	ld	a,$2a
	call	:_a688
	ld	a,$28
	call	:_a6a2
	ld	a,$28
	call	:_a688
	ld	a,$28
	call	:_a6a2
	ld	[ix+#mob.width],$10
	ld	hl,$0401
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._8
	call	:_35fd
	jr	._9
	
._8	ld	[ix+#mob.width],$16
	ld	hl,$0410
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ld	hl,$0000
	ld	[$.TEMP1],hl
	call	nc,:_35e5
._9	ld	[ix+#mob.Yspeed.hi],$01
	ld	a,[$.FRAMECOUNT]
	and	$01
	ret	nz
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$16
	ret	c
	ld	[ix+#mob.unknown11],$00
	inc	[ix+#mob.unknown15]
	ld	a,[ix+#mob.unknown15]
	cp	$14
	ret	c
	ld	[ix+#mob.unknown15],$00
	ld	a,[ix+#mob.flags]
	xor	$02
	ld	[ix+#mob.flags],a
	ret
}

PROC    :_a688                                  SECTION ::mobs                  `$A688
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	push	hl
	ld	e,[hl]
	ld	d,$00
	ld	[$.TEMP4],de
	ld	l,[ix+#mob.unknown13]
	ld	h,[ix+#mob.unknown14]
	ld	[$.TEMP6],hl
	call	:_3581
	pop	hl
	ld	de,$0016
	add	hl,de
	ret
}

PROC    :_a6a2                                  SECTION ::mobs                  `$A6A2
{
	push	hl
	ld	e,[hl]
	ld	d,$00
	ld	[$.TEMP4],de
	ld	hl,$0000
	ld	[$.TEMP6],hl
	call	:_3581
	pop	hl
	ld	de,$0016
	add	hl,de
	ret
}

TABLE   :_a6b9                                  SECTION ::mobs                  `$A6B9
{
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $E0 $FF $E0 $FF $E0 $FF $E0 $FF $C0 $FF
        BYTE    $C0 $FF $80 $FF $80 $FF $00 $FF $00 $FF $00 $FE
}
TABLE   :_a6e5                                  SECTION ::mobs                  `$A6E5
{
        BYTE    $00 $FF $80 $FF $80 $FF $C0 $FF $C0 $FF $E0 $FF $E0 $FF $F0 $FF
        BYTE    $F0 $FF $F0 $FF $F0 $FF $10 $00 $10 $00 $10 $00 $10 $00 $20 $00
        BYTE    $20 $00 $40 $00 $40 $00 $80 $00 $80 $00 $00 $01
}
TABLE   :_a711                                  SECTION ::mobs                  `$A711
{
        BYTE    $00 $01 $02 $02 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03
        BYTE    $03 $03 $02 $02 $01 $00 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
        BYTE    $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $0E $0D $0C $0C
        BYTE    $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0C $0C
        BYTE    $0D $0E $15 $13 $12 $11 $10 $10 $0F $0F $0F $0F $0F $0F $0F $0F
        BYTE    $0F $0F $10 $10 $11 $12 $13 $15
}
TABLE   :_a769                                  SECTION ::mobs                  `$A769
{
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $20 $00 $20 $00 $20 $00 $20 $00 $40 $00
        BYTE    $40 $00 $80 $00 $80 $00 $00 $01 $00 $01 $00 $02
}
TABLE   :_a795                                  SECTION ::mobs                  `$A795
{
        BYTE    $15 $14 $13 $13 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12
        BYTE    $12 $12 $13 $13 $14 $15 $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E
        BYTE    $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $07 $08 $09 $09
        BYTE    $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $09 $09
        BYTE    $08 $07 $00 $02 $03 $04 $05 $05 $06 $06 $06 $06 $06 $06 $06 $06
        BYTE    $06 $06 $05 $05 $04 $03 $02 $00
}

PROC    :mob_boss_scrapBrain                    SECTION ::mobs                  `$A7ED
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$1e
	ld	[ix+#mob.height],$2f
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	hl,$0340
	ld	[$.LEVEL_LEFT],hl
	
	`lock the screen at 1344 pixels, 42 blocks
	 `(near the boss lift in Scrap Brain Act 3)
	ld	hl,$0540
	ld	[$.LEVEL_RIGHT],hl
	
	ld	hl,[$.CAMERA_Y]
	ld	[$.LEVEL_TOP],hl
	ld	[$.LEVEL_BOTTOM],hl
	ld	hl,$0220
	ld	[$.CAMERA_Y_GOTO],hl

	`UNKNOWN
	ld	hl,$ef3f
	ld	de,$2000
	ld	a,12
	call	:decompressArt

	ld	hl,:S1_BossPalette
	ld	a,%00000010
	call	:loadPaletteOnInterrupt
	
	ld	a,#index_music_boss1
	rst	:rst_playMusic
	
	set	0,[ix+#mob.flags]
._1	bit	1,[ix+#mob.flags]
	jr	nz,._4
	ld	hl,[$.CAMERA_X]
	ld	[$.LEVEL_LEFT],hl
	ld	de,:_baf9
	ld	bc,:_a9b7
	call	:_7c41
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,[$.SONIC.X]
	xor	a;zero
	sbc	hl,de
	ld	de,$0040
	xor	a;zero
	ld	bc,[$.SONIC.Xspeed]
	bit	7,b
	jr	nz,._2
	sbc	hl,de
	jr	c,._3
._2	ld	bc,$ff80
._3	inc	b
	ld	[ix+#mob.Xspeed.lo],c
	ld	[ix+#mob.Xspeed.hi],b
	ld	[ix+#mob.Xdirection],a
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$05a0
	xor	a;zero
	sbc	hl,de
	jp	c,._9
	ld	l,a
	ld	h,a
	ld	[ix+#mob.Xspeed.lo],a
	ld	[ix+#mob.Xspeed.hi],a
	ld	[$.SONIC.Xspeed],hl
	ld	[$.SONIC.Xdirection],a
	set	1,[ix+#mob.flags]
	jp	._9
	
._4	bit	2,[ix+#mob.flags]
	jr	nz,._5
	
	ld	hl,$0530
	ld	de,$0220
	call	:_7c8c
	
	ld	[iy+#vars.joypad],$ff
	ld	hl,$05a0
	ld	[ix+#mob.Xsubpixel],$00
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.spriteLayout.lo],:_baf9.lo
	ld	[ix+#mob.spriteLayout.hi],:_baf9.hi
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$c0
	jp	c,._9
	set	2,[ix+#mob.flags]
	jp	._9
	
._5	bit	3,[ix+#mob.flags]
	jr	nz,._6
	ld	[iy+#vars.joypad],$ff
	xor	a;zero
	ld	[ix+#mob.spriteLayout.lo],a;zero
	ld	[ix+#mob.spriteLayout.hi],a;zero
	dec	[ix+#mob.unknown11]
	jp	nz,._9
	set	3,[ix+#mob.flags]
	jp	._9
	
._6	bit	4,[ix+#mob.flags]
	jr	nz,._8
	ld	de,[$.SONIC.X]
	ld	hl,$0596
	and	a
	sbc	hl,de
	jr	nc,._9
	ld	hl,$05c0
	xor	a;zero
	sbc	hl,de
	jr	c,._9
	or	[ix+#mob.unknown11]
	jr	nz,._7
	ld	hl,[$.SONIC.Y]
	ld	de,$028d
	xor	a;zero
	sbc	hl,de
	jr	c,._9
	ld	l;zero,a;zero
	ld	h;zero,a;zero
	ld	[$.SONIC.Xspeed],hl;zero
	ld	[$.SONIC.Xdirection],a;zero
._7	ld	a,$80
	ld	[$.SONIC.flags],a
	ld	hl,$05a0
	ld	[$.SONIC.X],hl
	ld	[iy+#vars.joypad],$ff
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	ld	hl,$028e
	xor	a;zero			        `set A to 0
	sbc	hl,de
	ld	[$.SONIC.Ysubpixel],a;zero
	ld	[$.SONIC.Y],hl
	ld	a,[$.D2E8]
	ld	hl,[$.D2E6]
	ld	[$.SONIC.Yspeed],hl
	ld	[$.SONIC.Ydirection],a
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$c0
	jr	nz,._9
	ld	hl,[$.CAMERA_X]
	inc	h
	ld	[$.SONIC.X],hl
	set	4,[ix+#mob.flags]
	
	ld	a,#index_music_actComplete
	rst	:rst_playMusic
	
	ld	a,$a0
	ld	[$.D289],a
	set	1,[iy+#vars.flags6]
	ret
	
._8	ld	a,[ix+#mob.unknown11]
	and	a
	jr	z,._9
	dec	[ix+#mob.unknown11]
._9	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	ld	hl,$0280
	xor	a;zero
	sbc	hl,de
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	ld	hl,$02af
	and	a
	sbc	hl,de
	ld	bc,[$.CAMERA_Y]
	and	a
	sbc	hl,bc
	ex	de,hl
	ld	hl,$05a0
	ld	bc,[$.CAMERA_X]
	and	a
	sbc	hl,bc
	ld	bc,:_a9c0		`address of sprite layout
	call	:processSpriteLayout
	ld	a,[ix+#mob.unknown11]
	and	$1f
	cp	$0f
	ret	nz
	ld	a,$19
	rst	:rst_playSFX
	ret
}

TABLE   :_a9b7                                  SECTION ::mobs                  `$A9B7
{
        BYTE    $03, $08, $04, $07, $05, $08, $04, $07, $FF
}

`sprite layout
TABLE   :_a9c0                                  SECTION ::mobs                  `$A9C0
{
        BYTE    $74, $76, $76, $78, $FF, $FF
        BYTE    $FF
}

PROC    :mob_meta_clouds                        SECTION ::mobs                  `$A9C7
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	a,[iy+#vars.spriteUpdateCount]
	ld	hl,[$.SPRITETABLE_ADDR]
	push	af
	push	hl
	ld	a,[$.D2DE]
	cp	$24
	jr	nc,._1
	ld	e,a
	ld	d,$00
	ld	hl,$.SPRITETABLE
	add	hl,de
	ld	[$.SPRITETABLE_ADDR],hl
	ld	a,[$.D2A3]
	ld	c,a
	ld	de,[$.D2A1]
	ld	l,[ix+#mob.Ysubpixel]
	ld	h,[ix+#mob.Y.lo]
	ld	a,[ix+#mob.Y.hi]
	add	hl,de
	adc	a,c
	ld	l,h
	ld	h,a
	ld	bc,[$.CAMERA_Y]
	and	a
	sbc	hl,bc
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	bc,[$.CAMERA_X]
	and	a
	sbc	hl,bc
	ld	bc,:_aa63		`address of sprite layout
	call	:processSpriteLayout
	ld	a,[$.D2DE]
	add	a,$0c
	ld	[$.D2DE],a
._1	pop	hl
	pop	af
	ld	[$.SPRITETABLE_ADDR],hl
	ld	[iy+#vars.spriteUpdateCount],a
	ld	hl,[$.CAMERA_X]
	ld	de,$ffe0
	add	hl,de
	ex	de,hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	and	a
	sbc	hl,de
	jr	nc,._2
	call	:_LABEL_625_57
	ld	b,$00
	add	a,a
	ld	c,a
	rl	b
	ld	hl,[$.CAMERA_X]
	ld	de,$01b4
	add	hl,de
	add	hl,bc
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
._2	ld	[ix+#mob.Xspeed.lo],$00
	ld	[ix+#mob.Xspeed.hi],$fd
	ld	[ix+#mob.Xdirection],$ff
	ld	[ix+#mob.spriteLayout.lo],$00
	ld	[ix+#mob.spriteLayout.hi],$00
	ret
}

`sprite layout
TABLE   :_aa63                                  SECTION ::mobs                  `$AA63
{
        BYTE $40, $42, $44, $46, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\trap_propeller.oz80"

PROC    :mob_badnick_bomb                       SECTION ::mobs                  `$AB21
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$0c
	ld	[ix+#mob.height],$10
	ld	a,[ix+#mob.unknown11]
	cp	$64
	jr	nc,._1
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$ffc8
	add	hl,de
	ex	de,hl
	ld	hl,[$.SONIC.X]
	and	a
	sbc	hl,de
	jr	c,._1
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$002c
	add	hl,de
	ex	de,hl
	ld	hl,[$.SONIC.X]
	and	a
	sbc	hl,de
	jr	nc,._1
	ld	[ix+#mob.unknown11],$64
._1	ld	a,[ix+#mob.unknown11]
	cp	$1e
	jr	nc,._2
	ld	[ix+#mob.Xspeed.lo],$f8
	ld	[ix+#mob.Xspeed.hi],$ff
	ld	[ix+#mob.Xdirection],$ff
	ld	de,:_ad0b
	ld	bc,:_acf1
	call	:_7c41
	jp	._7
	
._2	ld	a,[ix+#mob.unknown11]
	cp	$64
	jp	c,._4
	ld	[ix+#mob.Xspeed.lo],$00
	ld	[ix+#mob.Xspeed.hi],$00
	ld	[ix+#mob.Xdirection],$00
	cp	$66
	jr	nc,._3
	ld	de,:_ad0b
	ld	bc,:_ad01
	call	:_7c41
	jp	._7
	
._3	ld	[ix+#mob.spriteLayout.lo],:_ad53.lo
	ld	[ix+#mob.spriteLayout.hi],:_ad53.hi
	cp	$67
	jp	nz,._7
	ld	hl,$fffe
	ld	[$.TEMP4],hl
	ld	hl,$fffc
	ld	[$.TEMP6],hl
	call	:findEmptyMob
	jp	c,._8
	ld	de,$0000
	ld	c,e
	ld	b,d
	call	:_ac96
	ld	hl,$0003
	ld	[$.TEMP4],hl
	ld	hl,$fffc
	ld	[$.TEMP6],hl
	call	:findEmptyMob
	jp	c,._8
	ld	de,$0008
	ld	bc,$0000
	call	:_ac96
	ld	hl,$fffe
	ld	[$.TEMP4],hl
	ld	hl,$fffe
	ld	[$.TEMP6],hl
	call	:findEmptyMob
	jp	c,._8
	ld	de,$0000
	ld	bc,$0008
	call	:_ac96
	ld	hl,$0003
	ld	[$.TEMP4],hl
	ld	hl,$fffe
	ld	[$.TEMP6],hl
	call	:findEmptyMob
	jp	c,._8
	ld	de,$0008
	ld	bc,$0008
	call	:_ac96
	ld	[ix+#mob.type],$FF	        `remove mob?
	ld	a,$1b
	rst	:rst_playSFX
	jr	._8
	
._4	cp	$23
	jr	nc,._5
	xor	a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	ld	de,:_ad0b
	ld	bc,:_acf6
	call	:_7c41
	jr	._7
	
._5	ld	a,[ix+#mob.unknown11]
	cp	$41
	jr	nc,._6
	ld	[ix+#mob.Xspeed.lo],$08
	ld	[ix+#mob.Xspeed.hi],$00
	ld	[ix+#mob.Xdirection],$00
	ld	de,:_ad0b
	ld	bc,:_acf9
	call	:_7c41
	jr	._7
	
._6	ld	[ix+#mob.Xspeed.lo],$00
	ld	[ix+#mob.Xspeed.hi],$00
	ld	[ix+#mob.Xdirection],$00
	ld	de,:_ad0b
	ld	bc,:_acfe
	call	:_7c41
._7	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$00
	ld	[ix+#mob.Ydirection],$00
._8	ld	hl,$0202
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	call	nc,:_35fd
	ld	a,[$.FRAMECOUNT]
	and	$3f
	ret	nz
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$46
	ret	nz
	ld	[ix+#mob.unknown11],$00
	ret
}

PROC    :_ac96                                  SECTION ::mobs                  `$AC96
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	push	ix
	push	hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ex	de,hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,bc
	ld	c,l
	ld	b,h
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$0D	        `unknown mob
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],e
	ld	[ix+#mob.X.hi],d
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],c
	ld	[ix+#mob.Y.hi],b
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown13],$24
	ld	[ix+#mob.unknown14],a;zero
	ld	[ix+#mob.unknown15],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	hl,[$.TEMP4]
	ld	[ix+#mob.Xspeed.hi],l
	ld	[ix+#mob.Xdirection],h
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	hl,[$.TEMP6]
	ld	[ix+#mob.Yspeed.hi],l
	ld	[ix+#mob.Ydirection],h
	pop	ix
	ret
}

TABLE   :_acf1                                  SECTION ::mobs                  `$ACF1
{
        BYTE    $00, $20, $01, $20, $FF
}
TABLE   :_acf6                                  SECTION ::mobs                  `$ACF6
{       
        BYTE    $01, $20, $FF
}
TABLE   :_acf9                                  SECTION ::mobs                  `$ACF9
{
        BYTE    $02, $20, $03, $20, $FF
}
TABLE   :_acfe                                  SECTION ::mobs                  `$ACFE
{
        BYTE    $03, $20, $FF
}
TABLE   :_ad01                                  SECTION ::mobs                  `$AD01
{
        BYTE    $01, $02, $04, $02, $FF, $03, $02, $05, $02, $FF
}

`sprite layout
TABLE   :_ad0b                                  SECTION ::mobs                  `$AD0B
{
        BYTE    $0A, $0C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $0E, $10, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $2A, $2C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $2E, $30, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
}

TABLE   :_ad53                                  SECTION ::mobs                  `$AD53
{
        BYTE    $12, $14, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $32, $34, $FF, $FF, $FF, $FF
        BYTE    $FF
}

INCLUDE "mobs\trap_cannon.oz80"

PROC    :mob_badnick_unidos                     SECTION ::mobs                  `$AE88
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	[ix+#mob.unknown11],$00
	ld	[ix+$12],$2a
	ld	[ix+#mob.unknown13],$52
	ld	[ix+#mob.unknown14],$7c
	set	0,[ix+#mob.flags]
._1	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,[$.SONIC.X]
	and	a
	sbc	hl,de
	jr	c,._2
	ld	[ix+#mob.Xspeed.lo],$f8
	ld	[ix+#mob.Xspeed.hi],$ff
	ld	[ix+#mob.Xdirection],$ff
	ld	[ix+#mob.spriteLayout.lo],:_b0d5.lo
	ld	[ix+#mob.spriteLayout.hi],:_b0d5.hi
	ld	hl,$ff80
	ld	[$.D216],hl
	call	:_af98
	ld	[ix+#mob.unknown16],$01
	jr	._3
	
._2	ld	[ix+#mob.Xspeed.lo],$08
	ld	[ix+#mob.Xspeed.hi],$00
	ld	[ix+#mob.Xdirection],$00
	ld	[ix+#mob.spriteLayout.lo],:_b0e7.lo
	ld	[ix+#mob.spriteLayout.hi],:_b0e7.hi
	ld	hl,$0080
	ld	[$.D216],hl
	call	:_af98
	ld	[ix+#mob.unknown16],$ff
._3	ld	[ix+#mob.width],$1c
	ld	[ix+#mob.height],$1c
	ld	hl,$1212
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ld	hl,$1010
	ld	[$.TEMP1],hl
	call	nc,:_35e5
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	push	ix
	pop	hl
	ld	de,$0011
	add	hl,de
	
	ld	b,$04
.loop	push	bc
	push	hl
	ld	a,[hl]
	cp	$fe
	jr	z,._4
	and	$fe
	ld	e,a
	ld	d,$00
	ld	hl,:_b031
	add	hl,de
	push	hl
	ld	e,[hl]
	ld	[$.TEMP4],de
	inc	hl
	ld	e,[hl]
	ld	[$.TEMP6],de
	ld	a,$24
	call	:_3581
	pop	hl
	ld	a,[hl]
	inc	a
	inc	a
	ld	[$.TEMP6],a
	add	a,$04
	ld	[ix+#mob.width],a
	inc	hl
	ld	a,[hl]
	inc	a
	inc	a
	ld	[$.TEMP7],a
	add	a,$04
	ld	[ix+#mob.height],a
	call	:detectCollisionWithSonic
	call	nc,:_35fd
._4	pop	hl
	pop	bc
	ld	a,[hl]
	cp	$fe
	jr	z,._6
	add	a,[ix+#mob.unknown16]
	cp	$ff
	jr	nz,._5
	ld	a,$a3
	jr	._6
	
._5	cp	$a4
	jr	nz,._6
	xor	a;zero
._6	ld	[hl],a;zero
	inc	hl
	djnz	.loop
	
	ld	a,[$.FRAMECOUNT]
	and	$07
	ret	z
	ld	a,[ix+#mob.unknown15]
	cp	$c8
	ret	nc
	inc	[ix+#mob.unknown15]
	ret
}

PROC    :_af98                                  SECTION ::mobs                  `$AF98
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	a,[ix+#mob.unknown15]
	cp	$c8
	ret	nz
	ld	a,[$.LEVEL_SOLIDITY]
	cp	$03
	ret	nz
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$ffd0
	add	hl,de
	ld	de,[$.SONIC.Y]
	and	a
	sbc	hl,de
	ret	nc
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	bc,$002c
	add	hl,bc
	and	a
	sbc	hl,de
	ret	c
	push	ix
	pop	hl
	ld	de,$0011
	add	hl,de
	ld	b,$04
	
.loop	push	bc
	push	hl
	ld	a,[hl]
	cp	$4a
	call	z,:_afdb
	pop	hl
	pop	bc
	inc	hl
	djnz	.loop
	
	ret
}

PROC    :_afdb                                  SECTION ::mobs                  `$AFDB
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[hl],$fe
	call	:findEmptyMob
	ret	c
	push	ix
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	c,[ix+#mob.Y.lo]
	ld	b,[ix+#mob.Y.hi]
	push	hl
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$36	        `unknown mob
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	hl,$0012
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	hl,$001e
	add	hl,bc
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	hl,[$.D216]
	ld	[ix+#mob.Xspeed.lo],l
	ld	[ix+#mob.Xspeed.hi],h
	xor	a;zero
	bit	7,h
	jr	z,._1
	ld	a,$ff
._1	ld	[ix+#mob.Xdirection],a
	xor	a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	pop	ix
	ret
}

TABLE   :_b031                                  SECTION ::mobs                  `$B031
{
        BYTE    $0C $03 $0D $03 $0E $03 $0E $04 $0F $04 $10 $04 $10 $05 $11 $05
        BYTE    $11 $06 $12 $06 $12 $07 $13 $07 $13 $08 $13 $09 $14 $09 $14 $0A
        BYTE    $14 $0B $15 $0B $15 $0C $15 $0D $15 $0E $15 $0F $15 $10 $15 $11
        BYTE    $14 $11 $14 $12 $14 $13 $13 $13 $13 $14 $13 $15 $12 $15 $12 $16
        BYTE    $11 $16 $11 $17 $10 $17 $10 $18 $0F $18 $0E $18 $0E $19 $0D $19
        BYTE    $0C $19 $0B $19 $0A $19 $09 $19 $09 $18 $08 $18 $07 $18 $07 $17
        BYTE    $06 $17 $06 $16 $05 $16 $05 $15 $04 $15 $04 $14 $04 $13 $03 $13
        BYTE    $03 $12 $03 $11 $02 $11 $02 $10 $02 $0F $02
}
TABLE   :_b0ac                                  SECTION ::mobs                  `$B0AC
{
        BYTE    $0E $02 $0D $02 $0C $02 $0B $03 $0B $03 $0A $03 $09 $04 $09 $04
        BYTE    $08 $04 $07 $05 $07 $05 $06 $06 $06 $06 $05 $07 $05 $07 $04 $08
        BYTE    $04 $09 $04 $09 $03 $0A $03 $0B $03
}

`sprite layout
TABLE   :_b0d5                                  SECTION ::mobs                  `$B0D5
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $FE, $26, $28, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
}
TABLE   :_b0e7                                  SECTION ::mobs                  `$B0E7
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $FE, $20, $22, $FF, $FF, $FF
        BYTE    $FF
}

PROC    :_b0f4                                  SECTION ::mobs                  `$B0F4
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	[ix+#mob.spriteLayout.lo],$00
	ld	[ix+#mob.spriteLayout.hi],$00
	ld	[ix+#mob.width],$04
	ld	[ix+#mob.height],$0a
	ld	hl,$0602
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	call	nc,:_35fd
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ex	de,hl
	ld	hl,[$.CAMERA_X]
	ld	bc,$fff0
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._1
	ld	hl,[$.CAMERA_X]
	ld	bc,$0110
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._1
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ex	de,hl
	ld	hl,[$.CAMERA_Y]
	ld	bc,$fff0
	add	hl,bc
	and	a
	sbc	hl,de
	jr	nc,._1
	ld	hl,[$.CAMERA_Y]
	ld	bc,$00d0
	add	hl,bc
	and	a
	sbc	hl,de
	jr	c,._1
	ld	hl,$0000
	ld	[$.TEMP4],hl
	ld	[$.TEMP6],hl
	ld	a,$24
	call	:_3581
	ret
	
._1	ld	[ix+#mob.type],$FF	`remove mob?
	ret
}

PROC    :mob_trap_turretRotating                SECTION ::mobs                  `$B16C
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	call	:_LABEL_625_57
	and	$07
	ld	[ix+#mob.unknown11],a
	set	0,[ix+#mob.flags]
._1	ld	[ix+#mob.spriteLayout.lo],$00
	ld	[ix+#mob.spriteLayout.hi],$00
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ld	a,[ix+#mob.unknown11]
	add	a,a
	add	a,a
	add	a,a
	ld	e,a
	ld	d,$00
	ld	hl,:_b227
	add	hl,de
	ld	b,$02
	
.loop	push	bc
	ld	d,$00
	ld	e,[hl]
	bit	7,e
	jr	z,._2
	ld	d,$ff
._2	ld	[$.TEMP4],de
	inc	hl
	ld	d,$00
	ld	e,[hl]
	bit	7,e
	jr	z,._3
	ld	d,$ff
._3	ld	[$.TEMP6],de
	inc	hl
	ld	a,[hl]
	inc	hl
	inc	hl
	cp	$ff
	jr	z,._4
	push	hl
	call	:_3581
	pop	hl
._4	pop	bc
	djnz	.loop
	
	ld	a,[$.FRAMECOUNT]
	and	$3f
	jr	nz,._5
	ld	a,[ix+#mob.unknown11]
	inc	a
	and	$07
	ld	[ix+#mob.unknown11],a
._5	inc	[ix+$12]
	ld	a,[ix+$12]
	cp	$1a
	ret	nz
	ld	[ix+$12],$00
	ld	a,[ix+#mob.unknown11]
	add	a,a
	ld	e,a
	add	a,a
	add	a,e
	ld	e,a
	ld	d,$00
	ld	hl,:_b267
	add	hl,de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	[$.TEMP4],de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	ld	[$.TEMP6],de
	inc	hl
	ld	e,[hl]
	ld	d,$00
	bit	7,e
	jr	z,._6
	dec	d
._6	inc	hl
	ld	c,[hl]
	ld	b,$00
	bit	7,c
	jr	z,._7
	dec	b
._7	call	:_b5c2
	ret
}

TABLE   :_b227                                  SECTION ::mobs                  `$B227
{
        BYTE    $08 $F8 $66 $00 $00 $00 $FF $00 $0C $FA $70 $00 $14 $FA $72 $00
        BYTE    $0F $07 $4C $00 $17 $07 $4E $00 $0D $0C $6C $00 $15 $0C $6E $00
        BYTE    $08 $0F $64 $00 $00 $00 $FF $00 $FC $0C $68 $00 $04 $0C $6A $00
        BYTE    $F9 $07 $48 $00 $01 $07 $4A $00 $FB $F9 $50 $00 $03 $F9 $52 $00   
}
TABLE   :_b267                                  SECTION ::mobs                  `$B267
{
        BYTE    $00 $00 $00 $FE $08 $F0 $00 $01 $00 $FF $18 $F8 $00 $02 $00 $00
        BYTE    $1E $07 $00 $01 $00 $01 $16 $16 $00 $00 $00 $02 $08 $20 $00 $FF
        BYTE    $00 $01 $F8 $18 $00 $FE $00 $00 $F2 $07 $00 $FF $00 $FF $F7 $F6
}

PROC    :mob_platform_flyingRight               SECTION ::mobs                  `$B297
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5, [ix+#mob.flags]
	bit	0, [ix+#mob.flags]
	jr	nz,._1
	
	ld	a,[ix+#mob.Ysubpixel]
	ld	[ix+$12],a
	
	ld	a,[ix+#mob.Y.lo]
	ld	[ix+#mob.unknown13],a
	
	ld	a,[ix+#mob.Y.hi]
	ld	[ix+#mob.unknown14],a
	
	set	0,[ix+#mob.flags]
	
._1	ld	a,[$.D2A3]
	ld	c,a
	ld	de,[$.D2A1]
	ld	l,[ix+$12]
	ld	h,[ix+#mob.unknown13]
	ld	a,[ix+#mob.unknown14]
	add	hl,de
	adc	a,c
	ld	[ix+#mob.Ysubpixel],l
	ld	[ix+#mob.Y.lo],h
	ld	[ix+#mob.Y.hi],a
	
	ld	a,[$.SONIC.Ydirection]
	and	a
	jp	m,._2
	
	ld	[ix+#mob.width],$1e
	ld	[ix+#mob.height],$10
	ld	hl,$0a02
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	jr	c,._2
	
	ld	hl,$0030
	ld	[$.D26B],hl
	ld	hl,$0030
	ld	[$.D26D],hl
	ld	bc,$0010
	ld	de,$0000
	call	:_LABEL_7CC1_12
	ld	l,[ix+#mob.Xsubpixel]
	ld	h,[ix+#mob.X.lo]
	ld	a,[ix+#mob.X.hi]
	ld	de,$0080
	add	hl,de
	adc	a,$00
	ld	[ix+#mob.Xsubpixel],l
	ld	[ix+#mob.X.lo],h
	ld	[ix+#mob.X.hi],a
	ld	hl,[$.SONIC.Xsubpixel]
	ld	a,[$.SONIC.X.hi]
	add	hl,de
	adc	a,$00
	ld	[$.SONIC.Xsubpixel],hl
	ld	[$.SONIC.X.hi],a
._2	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	[$.TEMP3],hl
	ld	hl,$fff8
	ld	[$.TEMP4],hl
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	ld	hl,:_b388
	add	hl,de
	ld	b,$02
	
.loop	push	bc
	ld	e,[hl]
	ld	d,$00
	inc	hl
	ld	[$.TEMP6],de
	ld	a,[hl]
	inc	hl
	cp	$ff
	jr	z,._3
	push	hl
	call	:_3581
	pop	hl
._3	pop	bc
	djnz	.loop
	
	ld	[ix+#mob.spriteLayout.lo],:_b37b.lo
	ld	[ix+#mob.spriteLayout.hi],:_b37b.hi
	ld	a,[ix+#mob.unknown11]
	add	a,$04
	ld	[ix+#mob.unknown11],a
	cp	$10
	ret	c
	ld	[ix+#mob.unknown11],$00
	ret
}

`sprite layout
TABLE   :_b37b                                  SECTION ::mobs                  `$B37B
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $36, $36, $36, $36, $FF, $FF
        BYTE    $FF
}
TABLE   :_b388                                  SECTION ::mobs                  `$B388
{
        BYTE    $08 $1C $18 $3C $08 $1E $18 $3E $08 $38 $18 $3A $0C $1A $00 $FF
}

INCLUDE "mobs\trap_spikewall.oz80"


PROC    :mob_trap_turretFixed                   SECTION ::mobs                  `$B46D
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	ld	bc,$0000
	ld	e,c
	ld	d,b
	call	:getFloorLayoutRAMAddressForMob
	ld	a,[hl]
	sub	$3c
	cp	$04
	ret	nc
	ld	[ix+#mob.unknown11],a
	set	0,[ix+#mob.flags]
._1	inc	[ix+$12]
	ld	a,[ix+$12]
	bit	6,a
	ret	nz
	and	$0f
	ret	nz
	ld	a,[ix+#mob.unknown11]
	add	a,a
	ld	e,a
	add	a,a
	add	a,a
	add	a,e
	ld	e,a
	ld	d,$00
	ld	hl,._b4e6
	add	hl,de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	[$.TEMP4],de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	[$.TEMP6],de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	c,[hl]
	inc	hl
	ld	b,[hl]
	inc	hl
	exx	
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	hl,[$.SONIC.X]
	and	a
	sbc	hl,de
	ld	a,h
	exx	
	cp	[hl]
	ret	nz
	inc	hl
	exx	
	ld	e,[ix+#mob.Y.lo]
	ld	d,[ix+#mob.Y.hi]
	ld	hl,[$.SONIC.Y]
	and	a
	sbc	hl,de
	ld	a,h
	exx	
	cp	[hl]
	ret	nz
	call	:_b5c2
	ret

._b4e6  BYTE    $80 $FE $80 $FE $00 $00 $F8 $FF $FF $FF $80 $01 $80 $FE $18 $00
        BYTE    $F8 $FF $00 $FF $80 $FE $80 $01 $00 $00 $10 $00 $FF $00 $80 $01
        BYTE    $80 $01 $18 $00 $10 $00 $00 $00   
}

PROC    :mob_platform_flyingUpDown              SECTION ::mobs                  `$B50E
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	hl,:_b37b
	ld	a,[$.LEVEL_SOLIDITY]
	cp	$01
	jr	nz,._1
	ld	hl,._b5b5
._1	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	ld	a,$50
	ld	[$.D216],a
	call	._b53b
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$a0
	ret	c
	ld	[ix+#mob.unknown11],$00
	ret

        `--------------------------------------------------------------------[$B53B]---

._b53b 	ld	a,[$.D216]
	ld	l,a
	ld	de,$0010
	ld	c,$00
	ld	a,[ix+#mob.unknown11]
	cp	l
	jr	c,._2
	dec	c
	ld	de,$fff0
._2	ld	l,[ix+#mob.Yspeed.lo]
	ld	h,[ix+#mob.Yspeed.hi]
	ld	a,[ix+#mob.Ydirection]
	add	hl,de
	adc	a,c
	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],a
	ld	a,h
	and	a
	jp	p,._3
	ld	a,l
	cpl	
	ld	l,a
	ld	a,h
	cpl	
	ld	h,a
	inc	hl
	ld	a,h
	cp	$02
	jr	c,._4
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$fe
	ld	[ix+#mob.Ydirection],$ff
	jr	._4
	
._3	cp	$02
	jr	c,._4
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$02
	ld	[ix+#mob.Ydirection],$00
	
._4	ld	a,[$.SONIC.Ydirection]
	and	a
	ret	m
	
	ld	[ix+#mob.width],$1e
	ld	[ix+#mob.height],$1c
	ld	hl,$0802
	ld	[$.TEMP6],hl
	call	:detectCollisionWithSonic
	ret	c
	ld	e,[ix+#mob.Yspeed.lo]
	ld	d,[ix+#mob.Yspeed.hi]
	ld	bc,$0010
	call	:_LABEL_7CC1_12
	ret
        
        `sprite layout
._b5b5  BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $6C, $6E, $6C, $6E, $FF, $FF
        BYTE    $FF
}

PROC    :_b5c2                                  SECTION ::mobs                  `$B5C2
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	push	bc
	push	de
	call	:findEmptyMob
	pop	de
	pop	bc
	ret	c
	push	ix
	push	hl
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	add	hl,de
	ex	de,hl
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	add	hl,bc
	ld	c,l
	ld	b,h
	pop	ix
	xor	a;zero			        `set A to 0
	ld	[ix+#mob.type],$0D	        `unknown mob?
	ld	[ix+#mob.Xsubpixel],a;zero
	ld	[ix+#mob.X.lo],e
	ld	[ix+#mob.X.hi],d
	ld	[ix+#mob.Ysubpixel],a;zero
	ld	[ix+#mob.Y.lo],c
	ld	[ix+#mob.Y.hi],b
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown13],a;zero
	ld	[ix+#mob.unknown14],a;zero
	ld	[ix+#mob.unknown15],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	hl,[$.TEMP4]
	bit	7,h
	jr	z,._1
	ld	a,$ff
._1	ld	[ix+#mob.Xspeed.lo],l
	ld	[ix+#mob.Xspeed.hi],h
	ld	[ix+#mob.Xdirection],a
	xor	a;zero
	ld	hl,[$.TEMP6]
	bit	7,h
	jr	z,._2
	ld	a,$ff
._2	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],a
	pop	ix
	ld	a,$01
	rst	:rst_playSFX
	ret
}

PROC    :mob_boss_skyBase                       SECTION ::mobs                  `$B634
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	ld	[ix+#mob.width],$1e
	ld	[ix+#mob.height],$2f
	set	5,[ix+#mob.flags]
	bit	2,[ix+#mob.flags]
	jp	nz,._b821
	call	:_7ca6
	call	._b7e6
	bit	0,[ix+#mob.flags]
	jr	nz,._1
	
	ld	hl,$0350
	ld	de,$0120
	call	:_7c8c
	
	ld	l,[ix+#mob.X.lo]
	ld	h,[ix+#mob.X.hi]
	ld	de,$0008
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.unknown11],l
	ld	[ix+$12],h
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	ld	de,$0010
	add	hl,de
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ld	[ix+#mob.unknown13],l
	ld	[ix+#mob.unknown14],h
	xor	a;zero
	ld	[$.D2EC],a;zero
	
	ld	a,#index_music_boss3
	rst	:rst_playMusic
	
	set	4,[iy+#vars.unknown0]
	set	0,[ix+#mob.flags]
._1	ld	a,[ix+#mob.unknown15]
	and	a
	jp	nz,._4
	call	._b99f
	ld	a,[$.FRAMECOUNT]
	and	$07
	jp	nz,._8
	ld	a,[ix+#mob.unknown16]
	cp	$1c
	jr	nc,._2
	inc	[ix+#mob.unknown17]
	ld	a,[ix+#mob.unknown17]
	cp	$02
	jp	c,._3
._2	ld	[ix+#mob.unknown17],$00
._3	inc	[ix+#mob.unknown16]
	ld	a,[ix+#mob.unknown16]
	cp	$28
	jp	c,._8
	ld	[ix+#mob.unknown16],$00
	inc	[ix+#mob.unknown15]
	jp	._8
	
._4	dec	a
	jr	nz,._5
	ld	[ix+#mob.Yspeed.lo],$40
	ld	[ix+#mob.Yspeed.hi],$fe
	ld	[ix+#mob.Ydirection],$ff
	inc	[ix+#mob.unknown15]
	ld	l,[ix+#mob.unknown11]
	ld	h,[ix+$12]
	ld	de,$0004
	add	hl,de
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	[ix+#mob.spriteLayout.lo],:_bb1d.lo
	ld	[ix+#mob.spriteLayout.hi],:_bb1d.hi
	jp	._8
	
._5	dec	a
	jp	nz,._7
	ld	l,[ix+#mob.Yspeed.lo]
	ld	h,[ix+#mob.Yspeed.hi]
	ld	a,[ix+#mob.Ydirection]
	ld	de,$000e
	add	hl,de
	adc	a,$00
	ld	c,a
	jp	m,._6
	ld	a,h
	cp	$02
	jr	c,._6
	ld	hl,$0200
._6	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],c
	ld	[ix+#mob.spriteLayout.lo],:_bb1d.lo
	ld	[ix+#mob.spriteLayout.hi],:_bb1d.hi
	ld	l,[ix+#mob.Y.lo]
	ld	h,[ix+#mob.Y.hi]
	dec	hl
	ld	e,[ix+#mob.unknown13]
	ld	d,[ix+#mob.unknown14]
	and	a
	sbc	hl,de
	jr	c,._8
	ld	[ix+#mob.Y.lo],e
	ld	[ix+#mob.Y.hi],d
	xor	a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.Yspeed.lo],a;zero
	ld	[ix+#mob.Yspeed.hi],a;zero
	ld	[ix+#mob.Ydirection],a;zero
	inc	[ix+#mob.unknown15]
	jp	._8
	
._7	dec	a
	jp	nz,._8
	ld	l,[ix+#mob.unknown11]
	ld	h,[ix+$12]
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	a,[ix+#mob.unknown16]
	and	a
	call	z,._b9d5
	ld	[ix+#mob.unknown17],$02
	set	1,[ix+#mob.flags]
	call	._b99f
	inc	[ix+#mob.unknown16]
	ld	a,[ix+#mob.unknown16]
	cp	$12
	jr	c,._8
	res	1,[ix+#mob.flags]
	xor	a;zero
	ld	[ix+#mob.unknown15],a;zero
	ld	[ix+#mob.unknown16],a;zero
	
._8	ld	hl,$ba31
	bit	1,[ix+#mob.flags]
	jr	z,._9
	ld	hl,._ba3b
._9	ld	de,$.TEMP1
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ldi	
	ld	a,[hl]
	inc	hl
	push	hl
	call	:_3581
	ld	hl,[$.TEMP4]
	ld	de,$0008
	add	hl,de
	ld	[$.TEMP4],hl
	pop	hl
	ld	a,[hl]
	call	:_3581
	ld	a,[$.D2EC]
	cp	$0c
	ret	c
	xor	a;zero
	ld	[ix+#mob.unknown11],a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	set	2,[ix+#mob.flags]
	res	4,[iy+#vars.unknown0]
	
	ld	a,#index_music_scrapBrain
	rst	:rst_playMusic
	
	ld	a,$21
	rst	:rst_playSFX
	ret
        
        `--------------------------------------------------------------------[$B7E6]---

._b7e6	ld	a,[$.D2B1]
	and	a
	ret	nz
	bit	0,[iy+#vars.scrollRingFlags]
	ret	nz
	ld	a,[$.SONIC.flags]
	rrca	
	jr	c,._10
	and	$02
	ret	z
._10	ld	hl,[$.SONIC.X]
	ld	de,$0410
	and	a
	sbc	hl,de
	ret	c
	ld	hl,$fd00
	ld	a,$ff
	ld	[$.SONIC.Xspeed],hl
	ld	[$.SONIC.Xdirection],a
	ld	hl,$.D2B1
	ld	[hl],$18
	inc	hl
	ld	[hl],$0c
	inc	hl
	ld	[hl],$3f
	ld	a,$01
	rst	:rst_playSFX
	ld	hl,$.D2EC
	inc	[hl]
	ret

        `--------------------------------------------------------------------[$B821]---

._b821	bit	3,[ix+#mob.flags]
	jp	nz,._20
	res	5,[ix+#mob.flags]
	ld	a,[ix+#mob.unknown11]
	cp	$0f
	jr	nc,._11
	add	a,a
	add	a,a
	ld	e,a
	add	a,a
	add	a,e
	ld	e,a
	ld	d,$00
	ld	hl,$ba45
	add	hl,de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	[$.D2AB],de
	ld	e,[hl]
	inc	hl
	ld	d,[hl]
	inc	hl
	ld	[$.D2AD],de
	ld	[$.D2AF],hl
	inc	[ix+#mob.unknown11]
	ld	a,[ix+#mob.unknown11]
	cp	$0f
	jr	nz,._11
	set	5,[iy+#vars.flags0]
	res	1,[iy+#vars.flags2]
	
	`something to do with scrolling
	ld	hl,$0550
	ld	[$.LEVEL_RIGHT],hl
	
._11	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	ld	hl,$05e0
	xor	a;zero
	sbc	hl,de
	jr	nc,._12
	ld	c,a;zero
	ld	b,a;zero
	jp	._15
	
._12	ex	de,hl
	ld	de,[$.SONIC.X]
	xor	a;zero
	sbc	hl,de
	ld	de,$0040
	xor	a;zero
	ld	bc,[$.SONIC.Xspeed]
	bit	7,b
	jr	nz,._13
	sbc	hl,de
	jr	c,._14
._13	ld	bc,$ff80
._14	inc	b
._15	ld	[ix+#mob.Xspeed.lo],c
	ld	[ix+#mob.Xspeed.hi],b
	ld	[ix+#mob.Xdirection],a
	ld	a,[ix+#mob.unknown17]
	cp	$06
	jr	nz,._16
	ld	a,[ix+#mob.unknown16]
	dec	a
	jr	nz,._16
	bit	7,[ix+#mob.flags]
	jr	z,._16
	ld	[ix+#mob.Yspeed.lo],$00
	ld	[ix+#mob.Yspeed.hi],$ff
	ld	[ix+#mob.Ydirection],$ff
._16	ld	de,$0017
	ld	bc,$0036
	call	:getFloorLayoutRAMAddressForMob
	ld	e,[hl]
	ld	d,$00
	ld	hl,$3f28
	add	hl,de
	ld	a,[hl]
	and	$3f
	and	a
	jr	z,._17
	bit	7,[ix+#mob.flags]
	jr	z,._17
	ld	[ix+#mob.Yspeed.lo],$80
	ld	[ix+#mob.Yspeed.hi],$fd
	ld	[ix+#mob.Ydirection],$ff
._17	ld	de,$0000
	ld	bc,$0008
	call	:getFloorLayoutRAMAddressForMob
	ld	a,[hl]
	cp	$49
	jr	nz,._18
	bit	7,[ix+#mob.flags]
	jr	z,._18
	xor	a;zero
	ld	[ix+#mob.unknown16],a;zero
	ld	[ix+#mob.unknown17],a;zero
	ld	[ix+#mob.Xspeed.lo],a;zero
	ld	[ix+#mob.Xspeed.hi],a;zero
	ld	[ix+#mob.Xdirection],a;zero
	ld	[ix+#mob.unknown11],$e0
	ld	[ix+$12],$05
	ld	[ix+#mob.unknown13],$60
	ld	[ix+#mob.unknown14],$01
	
	ld	hl,$0550
	ld	de,$0120
	call	:_7c8c
	
	set	3,[ix+#mob.flags]
	jp	._20
	
._18	ld	l,[ix+#mob.Yspeed.lo]
	ld	h,[ix+#mob.Yspeed.hi]
	ld	a,[ix+#mob.Ydirection]
	ld	de,$000e
	add	hl,de
	adc	a,$00
	ld	c,a
	jp	m,._19
	ld	a,h
	cp	$02
	jr	c,._19
	ld	hl,$0200
._19	ld	[ix+#mob.Yspeed.lo],l
	ld	[ix+#mob.Yspeed.hi],h
	ld	[ix+#mob.Ydirection],c
	ld	bc,._ba28
	ld	de,:_baf9
	call	:_7c41
	ret
	
._20	ld	[iy+#vars.joypad],$ff
	call	._b99f
	ld	a,[ix+#mob.unknown16]
	cp	$30
	jr	nc,._22
	ld	c,a
	ld	a,[$.FRAMECOUNT]
	and	$07
	jr	nz,._21
	ld	a,[ix+#mob.unknown17]
	inc	a
	and	$01
	ld	[ix+#mob.unknown17],a
	inc	[ix+#mob.unknown16]
._21	ld	a,c
	cp	$2c
	ret	c
	ld	[ix+#mob.spriteLayout.lo],:_bb77.lo
	ld	[ix+#mob.spriteLayout.hi],:_bb77.hi
	ret
	
._22	xor	a;zero
	ld	[ix+#mob.spriteLayout.lo],a;zero
	ld	[ix+#mob.spriteLayout.hi],a;zero
	inc	[ix+#mob.unknown16]
	ld	a,[ix+#mob.unknown16]
	cp	$70
	ret	c
	ld	[ix+#mob.type],$FF	        `remove mob?
	ret
	
        `--------------------------------------------------------------------[$B99F]---

._b99f	ld	hl,._ba1c
	ld	a,[ix+#mob.unknown17]
	add	a,a
	add	a,a
	ld	e,a
	ld	d,$00
	ld	b,d
	add	hl,de
	ld	c,[hl]
	inc	hl
	ld	e,[hl]
	inc	hl
	ld	a,[hl]
	inc	hl
	ld	h,[hl]
	ld	l,a
	ld	[ix+#mob.spriteLayout.lo],l
	ld	[ix+#mob.spriteLayout.hi],h
	ld	l,[ix+#mob.unknown11]
	ld	h,[ix+$12]
	add	hl,bc
	ld	[ix+#mob.X.lo],l
	ld	[ix+#mob.X.hi],h
	ld	l,[ix+#mob.unknown13]
	ld	h,[ix+#mob.unknown14]
	add	hl,de
	ld	[ix+#mob.Y.lo],l
	ld	[ix+#mob.Y.hi],h
	ret

        `--------------------------------------------------------------------[$B9D5]---

._b9d5  bit	5,[IY+#vars.unknown0]
	ret	nz
        
	call	:findEmptyMob
	ret	c
        
	push	IX
	push	HL
	pop	IX
        
	xor	A;zero			        `set A to 0
	ld	[IX+#mob.type],$47	        `unknown mob
	ld	[IX+#mob.Xsubpixel],A;zero
	ld	HL,$0420
	ld	[IX+#mob.X.lo],L
	ld	[IX+#mob.X.hi],H
	ld	[IX+#mob.Ysubpixel],A;zero
	ld	HL,$012f
	ld	[IX+#mob.Y.lo],L
	ld	[IX+#mob.Y.hi],H
	ld	[IX+#mob.unknown11],A;zero
	ld	[IX+#mob.flags],A;zero
	ld	[IX+#mob.Xspeed.lo],A;zero
	ld	[IX+#mob.Xspeed.hi],A;zero
	ld	[IX+#mob.Xdirection],A;zero
	ld	[IX+#mob.Yspeed.lo],A;zero
	ld	[IX+#mob.Yspeed.hi],A;zero
	ld	[IX+#mob.Ydirection],A;zero
	
        pop	IX
	ret

._ba1b  BYTE    $C9		                `unused?
._ba1c  BYTE    $00 $00 $F9 $BA $00 $02 $0B $BB $00 $07 $0B $BB
._ba28  BYTE    $03 $08 $04 $07 $05 $08 $04 $07 $FF $30 $04 $A0 $01 $00 $00
._ba37  BYTE    $00 $00 $20 $22                 `unused, or part of above?
._ba3b  BYTE    $30 $04 $A0 $01 $00 $00 $00 $00 $24 $26 $20 $04 $60 $01 $37 $10
        BYTE    $38 $10 $4A $10 $4B $10 $30 $04 $60 $01 $28 $10 $19 $10 $4C $10
        BYTE    $4D $10 $40 $04 $60 $01 $00 $10 $2D $10 $4E $10 $4F $10 $20 $04
        BYTE    $70 $01 $00 $00 $00 $00 $00 $00 $00 $00 $30 $04 $70 $01 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $40 $04 $70 $01 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $20 $04 $80 $01 $00 $00 $00 $00 $00 $00 $00 $00 $30 $04
        BYTE    $80 $01 $00 $00 $00 $00 $00 $00 $00 $00 $40 $04 $80 $01 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $20 $04 $90 $01 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $30 $04 $90 $01 $00 $00 $00 $00 $00 $00 $00 $00 $40 $04
        BYTE    $90 $01 $00 $00 $00 $00 $00 $00 $00 $00 $20 $04 $A0 $01 $5A $10
        BYTE    $5B $10 $37 $10 $3B $10 $30 $04 $A0 $01 $5C $10 $5D $10 $3C $10
        BYTE    $00 $10 $40 $04 $A0 $01 $5E $10 $5F $10 $00 $10 $2D $10
}

INCLUDE "mobs\boss_running.oz80"

`part of sky boss only
TABLE   :_bb1d                                  SECTION ::mobs                  `$BB1D
{
        BYTE    $10 $12 $14 $16 $FF $FF
        BYTE    $30 $32 $34 $FE $FF $FF
        BYTE    $50 $52 $54 $FE $FF $FF
        
        BYTE    $18 $1A $1C $1E $FF $FF
        BYTE    $FE $3A $3C $3E $FF $FF
        BYTE    $FE $64 $66 $68 $FF $FF
        
        BYTE    $18 $1A $1C $1E $FF $FF
        BYTE    $FE $3A $3C $3E $FF $FF
        BYTE    $FE $6A $6C $6E $FF $FF
        
        BYTE    $18 $1A $1C $1E $FF $FF
        BYTE    $FE $3A $3C $3E $FF $FF
        BYTE    $70 $72 $5A $5C $5E $FF
        
        BYTE    $00 $0A $0C $0E $FF $FF
        BYTE    $28 $2A $2C $2E $FF $FF
        BYTE    $00 $4A $4C $4E $FF $FF
}

`also part of sky base boss only
TABLE   :_bb77                                  SECTION ::mobs                  `$BB77
{
        BYTE    $FE $FF $FF $FF $FF $FF
        BYTE    $FE $44 $46 $FF $FF $FF
        BYTE    $FF
}

PROC    :mob_boss_electricBeam                  SECTION ::mobs                  `$BB84
        `==============================================================================
PARAMS  IX;mob          HELP ""Address of the current mob being processed
{
	set	5,[ix+#mob.flags]
	ld	hl,$0008
	ld	[$.D26B],hl
        
	bit	0,[ix+#mob.flags]
	jr	nz,._1

	`UNKNOWN
	ld	hl,$ef3f
	ld	de,$2000
	ld	a,$0c
	call	:decompressArt

	ld	[ix+$12],$01
	set	0,[ix+#mob.flags]
._1	ld	hl,$0390
	ld	[$.TEMP1],hl
	ld	l,[ix+#mob.unknown11]
	ld	h,$00
	ld	[$.TEMP4],hl
	ld	l,h
	ld	[$.TEMP6],hl
	ld	de,$011a
	ld	hl,._bcdd
	call	._bca5
	ld	e,[ix+#mob.unknown11]
	ld	d,$00
	ld	[$.TEMP4],de
	ld	de,$01d2
	ld	hl,._bcdd
	call	._bca5
	bit	4,[iy+#vars.unknown0]
	ret	z
	bit	1,[ix+#mob.flags]
	jr	z,._2
	ld	a,[$.FRAMECOUNT]
	bit	0,a
	ret	nz
	and	$02
	ld	e,a
	ld	d,$00
	ld	hl,._bcc7
	add	hl,de
	ld	b,$0a
	ld	de,$0130
	
.loop	push	bc
	push	de
	call	._bca5
	pop	de
	push	hl
	ld	hl,$0010
	add	hl,de
	ex	de,hl
	pop	hl
	pop	bc
	djnz	.loop
	
	ld	hl,$0390
	ld	c,[ix+#mob.unknown11]
	ld	b,$00
	add	hl,bc
	ld	c,l
	ld	b,h
	ld	hl,$000c
	add	hl,bc
	ld	de,[$.SONIC.X]
	and	a
	sbc	hl,de
	jr	c,._2
	ld	hl,$000e
	add	hl,de
	and	a
	sbc	hl,bc
	jr	c,._2
	bit	0,[iy+#vars.scrollRingFlags]
	call	z,:_35fd
	
._2	ld	a,[$.D2EC]
	cp	$06
	jr	nc,._5
	bit	1,[ix+#mob.flags]
	jr	nz,._3
	ld	a,[ix+#mob.unknown11]
	inc	a
	ld	[ix+#mob.unknown11],a
	cp	$80
	ret	c
	ld	a,[$.FRAMECOUNT]
	ld	c,a
	and	$01
	ret	nz
	set	1,[ix+#mob.flags]
	ret
	
._3	ld	a,[$.FRAMECOUNT]
	and	$0f
	jr	nz,._4
        
	ld	A;sfx           $13
	rst	:rst_playSFX
        
._4	dec	[ix+#mob.unknown11]
	ret	nz
	ld	[ix+#mob.unknown11],$00
	res	1,[ix+#mob.flags]
	ret
	
._5	ld	hl,[$.SONIC.X]
	ld	e,[ix+#mob.X.lo]
	ld	d,[ix+#mob.X.hi]
	and	a
	sbc	hl,de
	jr	nc,._6
	ld	a,[ix+#mob.unknown11]
	and	a
	jr	z,._7
	dec	[ix+#mob.unknown11]
	jr	._7
	
._6	ld	a,[ix+#mob.unknown11]
	cp	$80
	jr	nc,._7
	inc	[ix+#mob.unknown11]
._7	res	1,[ix+#mob.flags]
	ld	a,[$.FRAMECOUNT]
	ld	c,a
	and	$40
	ret	nz
	ld	a,[$.D2EC]
	cp	$06
	ret	z
	set	1,[ix+#mob.flags]
	ld	a,c
	and	$1f
	ret	nz
        
	ld	A;sfx           $13
	rst	:rst_playSFX
	
        ret
        
        `--------------------------------------------------------------------[$BAC5]---

._bca5	ld	[$.TEMP3],de
	ld	a,[hl]
	inc	hl
	push	hl
	call	:_3581
	pop	hl
	ld	a,[hl]
	inc	hl
	push	hl
	ld	hl,[$.TEMP4]
	push	hl
	ld	de,$0008
	add	hl,de
	ld	[$.TEMP4],hl
	call	:_3581
	pop	hl
	ld	[$.TEMP4],hl
	pop	hl
	ret
        
        `------------------------------------------------------------------------------

._bcc7  BYTE    $36 $38 $56 $58 $36 $38 $56 $58 $36 $38 $56 $58 $36 $38 $56 $58
        BYTE    $36 $38 $56 $58 $36 $38
._bcdd  BYTE    $40 $42        
        
}

INCLUDE "mobs\unknown_bcdf.oz80"
INCLUDE "mobs\anim_final.oz80"
INCLUDE "mobs\anim_emeralds.oz80"