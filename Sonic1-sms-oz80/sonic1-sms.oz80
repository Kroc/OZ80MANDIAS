`` Sonic 1 Master System Disassembly
   created by Kroc Camen <kroc@camendesign.com>
   for MaSS1VE: The Master System Sonic 1 Visual Editor <github.com/Kroc/MaSS1VE>
   ================================================================================= ``
`` please use tab stops at 8 and a line width of 88 chars, thanks
   ================================================================================= ``
``
			W    A    R    N    I    N    G    !
	
	Here be dragons! This disassembly is in progress, expect constant
	changes as well as future planned improvements:
	
	*	split up into categorised files
	
	*	fully commented and described program flow
	
	*	portable data

   --------------------------------------------------------------------------------- ``
`` This source code is given to the public domain:
   
   whilst "SEGA" and "Sonic" are registered trademarks of SEGA Enterprises, Ltd.,
   this is not their source code (I haven't broken into SEGA's offices ¬__¬), so not
   their copyright. Neither does this contain any byte-for-byte data of the original
   ROM (this is all ASCII codes, even the hex data parts). the fact that this text
   file can be processed with an algorithm and produces a file that is the same as
   the original ROM is also not a copyright violation -- SEGA don't own a patent on
   the compiling algorithm

   --------------------------------------------------------------------------------- ``
`` this disassembly was made possible by earlier documentation provided by
   David Declerk, ValleyBell, Penta Penguin and Ravenfreak
   
   --------------------------------------------------------------------------------- ``
`` this disassembly was made by using these tools:

:: SMSExamine: <smspower.org/Development/SMSExamine>
	this excellent tool disassembles much of the ROM by effectively 'running'
	the code to determine what parts are code and what parts are data.
	this saved a very large amount of effort, but due to the dynamic and complex
	nature of code, it didn't get all of it right, therefore I used:
 
:: dz80: <inkland.org.uk/dz80>
	to do a byte-for-byte disassembly to fill in the blanks (this had to all be
	manually labelled!). that was largely wasted time as I later got help from
	the author of:
 
:: Emulicious: <emulicious.net>
	which was able to provide a far superior disassembly that filled in all the
	gaps through a specific configuration file provided kindly by the author to
	assist me
 
:: WLA DX <villehelin.com/wla.html>
	I used this assembler to get things working, and after having explored the
        syntax and the task at hand, I opted to write my own assembler:

:: OZ80MANDIAS <github.com/Kroc/OZ80MANDIAS>
        A brand-new SMS-specific assembler with a new syntax designed for writing
        clean, flexible code and data
        
   
``


`SECTION ::interrupts    BANK 0 SLOT 0
`SECTION ::main          BANK 0 SLOT 0
`SECTION ::objects       BANK 1, 2 SLOT 1, 2
`SECTION ::sound         BANK 3, SLOT 2
   
``
IF EXISTS "ROM.sms" {
	`once all large data is inserted with `INCLUDE BINARY`, this won't be needed
	FILL BINARY "ROM.sms"
} ELSE {
	ECHO "Please provide a Sonic 1 ROM "
	ECHO "named 'ROM.sms' to fill in the data banks\n"
	FAIL
}
``

`hardware constants:
`======================================================================================
``the banking of the cartridge ROM into the slots of the Z80 address space is handled
  by the mapper chip. for standard SEGA mappers, writing to $FFFC configures the
  mapper and $FFFD/E/F sets the ROM bank number to page into the relevant memory slot.
  for more details, see http://www.smspower.org/Development/Mappers
`` 
VAR #SMS_PAGE_RAM		$FFFC	`RAM select register
VAR #SMS_PAGE_0			$FFFD	`Page 0 ROM Bank
VAR #SMS_PAGE_1			$FFFE	`Page 1 ROM Bank
VAR #SMS_PAGE_2			$FFFF	`Page 2 ROM Bank

`VDP:
`--------------------------------------------------------------------------------------
``the Video Display Processor in the Master System handles the graphics and sprites
  stored in video RAM ("VRAM"), composites the display and outputs it to the display
``
VAR #SMS_CURRENT_SCANLINE 	$7E	`read current vertical scanline from 0 to 191
VAR #SMS_VDP_DATA		$BE	`graphics data port
VAR #SMS_VDP_CONTROL		$BF	`graphics control port

``VDP registers are written to by sending first the data byte, and then the 4-bit
  register number with bit 7 set. for more details, see
  http://www.smspower.org/Development/VDPRegisters
``
VAR #SMS_VDP_REGISTER_WRITE	%10000000
VAR #SMS_VDP_REGISTER_0		#SMS_VDP_REGISTER_WRITE | 0
VAR #SMS_VDP_REGISTER_1		#SMS_VDP_REGISTER_WRITE | 1
VAR #SMS_VDP_REGISTER_2		#SMS_VDP_REGISTER_WRITE | 2
VAR #SMS_VDP_REGISTER_5		#SMS_VDP_REGISTER_WRITE | 5
VAR #SMS_VDP_REGISTER_6		#SMS_VDP_REGISTER_WRITE | 6
VAR #SMS_VDP_REGISTER_7		#SMS_VDP_REGISTER_WRITE | 7
VAR #SMS_VDP_REGISTER_8		#SMS_VDP_REGISTER_WRITE | 8
VAR #SMS_VDP_REGISTER_9		#SMS_VDP_REGISTER_WRITE | 9
VAR #SMS_VDP_REGISTER_10	#SMS_VDP_REGISTER_WRITE | 10

VAR #SMS_VDP_SCREENNAMETABLE	$3800

`how many blocks (32x32px) fit in the screen height
VAR #SMS_SCREENHEIGHT_PX	192
VAR #SMS_SCREENHEIGHT_BLOCKS	#SMS_SCREENHEIGHT_PX / 32

`--------------------------------------------------------------------------------------
VAR #SMS_SOUND_PORT		$7F	`write-only port to send data to sound chip

VAR #SMS_JOYPAD_1		$DC
VAR #SMS_JOYPAD_2		$DD


`game variables:
`======================================================================================

``the programmers use the IY register as a shortcut to $D200
  to access commonly used variables and flags`` 

OBJECT  #vars {				`$D200:
	
	`program flow control / loading flags?
	.flags0			AS BYTE	`IY+$00
	`bit 0 - `waitForInterrupt` will loop until the bit is set
	`bit 1 - unknown (set at level load)
	`bit 3 - flag to load palette on IRQ
	`bit 5 - unknown
	`bit 6 - set when the camera has moved left
	`bit 7 - set when the camera has moved up
	
	`this is used only as the comparison byte in `:loadFloorLayout`
	.temp			AS BYTE	`IY+$01
	
	.flags2			AS BYTE	`IY+$02
	`bit 0 - unknown
	`bit 1 - unknown
	`bit 2 - unknown
	
	`value of joypad port 1 - the bits are 1 for unpressed and 0 for pressed
	.joypad			AS BYTE	`IY+$03
	`bit 0 - joypad 1 up
	`bit 1 - joypad 1 down
	`bit 2 - joypad 1 left
	`bit 3 - joypad 1 right
	`bit 4 - joypad button A
	`bit 5 - joypad button B
	
	`this does not appear referenced in any code
	.unused			AS BYTE	`IY+$04
	
	`taken from the level header, this controls screen scrolling and the
	 `presence of the "rings" count on the HUD
	.scrollRingFlags	AS BYTE	`IY+$05
	`bit 0 - unknown, but causes Sonic to immediately die
	`bit 1 - demo mode
	`bit 2 - ring count displayed in HUD, rings visible in the level
	`bit 3 - automatic scrolling to the right
	`bit 4 - automatic scrolling upwards
	`bit 5 - smooth scrolling
	`bit 6 - up and down wave scrolling
	`bit 7 - screen does not scroll down
	
	.flags6			AS BYTE	`IY+$06
	`bit 0 - unknown
	`bit 1 - unknown
	`bit 3 - unknown
	`bit 4 - unknown
	`bit 5 - unknown
	`bit 6 - unknown
	`bit 7 - level underwater flag (enables water line)
	
	`taken from the level header, this controls the presence of the time on
	 `the HUD and if the lightning effect is in use
	.timeLightningFlags	AS BYTE	`IY+$07
	`bit 0 - centers the time in the screen on special stages
	`bit 1 - enables the lightning effect
	`bit 4 - use the boss underwater palette (specially for Labyrinth Act 3)
	`bit 5 - time is displayed in the HUD
	`bit 6 - locks the screen, no scrolling
	
	`part of the level header -- always "0" for all levels, but unknown function
	.unknown0		AS BYTE	`IY+$08
	
	.flags9			AS BYTE	`IY+$09
	`bit 0 - unknown
	`bit 1 - enables interrupts during `decompressArt`
	
	.spriteUpdateCount	AS BYTE	`IY+$0A, number of sprites requiring updates
	.origScrollRingFlags	AS BYTE	`IY+$0B, copy made during level loading UNUSED
	.origFlags6		AS BYTE	`IY+$0C, copy made during level loading
        
        `currently unknown purpose
        .unknown_0D             AS BYTE `IY+$0D
}

`--------------------------------------------------------------------------------------

RAM     `name                   `size                                           `addr
{       
        ``the floor layout (i.e. the tiles Sonic runs around on).
          a 'level' is a sub-portion of this floor layout since sometimes multiple
          levels are crammed into one layout (such as the special stages)``
        .FLOORLAYOUT            AS BYTE x 4 KB                                  `$C000
        
        `X/Y/I data for the 64 sprites
        .SPRITES                AS BYTE x 64*3                                  `$D000
        
        ``when the screen scrolls and new tiles need to be filled in, they are pulled
          from these caches which have the necessary tiles already in horizontal
          / vertical order for speed``
        `(NOTE: though these are 128 bytes each, I don't think that much is used)
        .OVERSCROLLCACHE_VERT   AS BYTE x 128                                   `$D100
        .OVERSCROLLCACHE_HORZ   AS BYTE x 128                                   `$D180
        
        ``throughout the codebase, IY is used as a shorthand to $D200 where many
          commonly used RAM variables exist. therefore these use the `(iy+#vars.abc)`
          form of addressing. for the sake of completeness, we'll also define the
          absolute location of these variables too, i.e. `$.VARS.abc```
        .VARS                   AS #vars                                        `$D200
        
        ``these temporary variables are reused throughout, some times for passing
          extra parameters to a function and sometimes as extra working space within
          a function``
        .TEMP1                  AS BYTE                                         `$D20E
        .TEMP2                  AS BYTE                                         `$D20F
        .TEMP3                  AS WORD                                         `$D210
        .TEMP4                  AS BYTE                                         `$D212
        .TEMP5                  AS BYTE                                         `$D213
        .TEMP6                  AS BYTE                                         `$D214
        .TEMP7                  AS BYTE                                         `$D215
        
        .D216                   AS WORD `UNKNOWN                                `$D216
        
        .VDPREGISTER_0          AS BYTE `RAM cache of the VDP register 0        `$D218
        .VDPREGISTER_1          AS BYTE `RAM cache of the VDP register 1        `$D219
        
        `though the code copies the VDP registers here, these ones are not recalled
        .VDPREGISTER_2          AS BYTE                                         `$D21A
        .VDPREGISTER_3          AS BYTE                                         `$D21B
        .VDPREGISTER_4          AS BYTE                                         `$D21C
        .VDPREGISTER_5          AS BYTE                                         `$D21D
        .VDPREGISTER_6          AS BYTE                                         `$D21E
        .VDPREGISTER_7          AS BYTE                                         `$D21F
        .VDPREGISTER_8          AS BYTE                                         `$D220
        .VDPREGISTER_9          AS BYTE                                         `$D221
        .VDPREGISTER_10         AS BYTE                                         `$D222
        
        .FRAMECOUNT	        AS WORD                                         `$D223
        
        `referenced by unused function ":unused_0323"
        .UNUSED_D225            AS WORD                                         `$D225
        .UNUSED_D227            AS WORD                                         `$D227
        .UNUSED_D229            AS WORD                                         `$D229
        
        ``":loadPaletteOnInterrupt" and ":loadPaletteFromInterrupt" use these to pass
          parameters``
        .LOADPALETTE_ADDRESS    AS WORD                                         `$D22B
        .D22D                   AS WORD                                         `UNUSED
        .LOADPALETTE_FLAGS      AS BYTE                                         `$D22F
        
        ``":loadPalette" uses these to pass the addresses of the tile/sprite palettes
          to load``
        .LOADPALETTE_TILE       AS WORD                                         `$D230
        .LOADPALETTE_SPRITE	AS WORD                                         `$D232
        
        .D234                   AS BYTE                                         `UNUSED
        
        `these keep track of which bank is in which page; page 0 is always bank 0
        .PAGE_1                 AS BYTE                                         `$D235
        .PAGE_2                 AS BYTE                                         `$D236
        
        .D237                   AS BYTE                                         `UNUSED
        
        .LEVEL_FLOORWIDTH       AS WORD `width of the floor layout in blocks    `$D238
        .LEVEL_FLOORHEIGHT      AS WORD `height of the floor layout in blocks   `$D23A
        
        .SPRITES_CURRENT        AS WORD `pointer to which sprite table to use   `$D23C
        
        .CURRENT_LEVEL          AS BYTE                                         `$D23E
        
        .D23F                   AS BYTE `UNKNOWN                                `$D23F
        .D240                   AS WORD `UNKNOWN                                `$D240
        .D242                   AS WORD `UNKNOWN                                `$D242
        .D244                   AS WORD `UNKNOWN                                `$D244
        
        `NOTE: some code accesses this value using two-bytes, not one!?
        .LIVES			AS BYTE	`player's lives count                   `$D246
        
        .RASTERSPLIT_STEP	AS BYTE                                         `$D247
        .RASTERSPLIT_LINE	AS BYTE                                         `$D248
        
        .D249                   AS BYTE x 6                                     `UNUSED
        
        `absolute address of the block mappings when in page 1 (i.e. $4000)
        .BLOCKMAPPINGS		AS WORD                                         `$D24F
        
        .VDPSCROLL_HORZ         AS BYTE                                         `$D251
        .VDPSCROLL_VERT         AS BYTE                                         `$D252
        
        .D253                   AS BYTE x 4                                     `UNUSED
        
        .BLOCK_X		AS BYTE `number of blocks across the camera is  `$D257
        .BLOCK_Y		AS BYTE	`number of blocks down the camera is    `$D258
        
        .D259                   AS BYTE                                         `UNUSED
        
        .CAMERA_X		AS WORD                                         `$D25A
        .D25C                   AS BYTE `UNKNOWN?? (read as $D25C/D)            `$D25C
        .CAMERA_Y               AS WORD                                         `$D25D
        
        .D25F                   AS WORD `UNKNOWN                                `$D25F
        .D261                   AS WORD `UNKNOWN                                `$D261
        .D263                   AS WORD `UNKNOWN                                `$D263
        .D265                   AS WORD `UNKNOWN                                `$D265
        .D267                   AS WORD `UNKNOWN                                `$D267
        .D269                   AS WORD `UNKNOWN                                `$D269
        .D26B                   AS WORD `UNKNOWN                                `$D26B
        .D26D                   AS WORD `UNKNOWN                                `$D26D
        
        .CAMERA_X_LEFT		AS WORD `used to check if the camera went left  `$D26F
        .CAMERA_Y_UP		AS WORD `used to check if the camera went up    `$D271
        
        .LEVEL_LEFT		AS WORD                                         `$D273
        ``prevents the level scrolling past this left-most point (i.e. sets an
          effective right-hand limit to the level -- this + width of the screen)``
        .LEVEL_RIGHT		AS WORD                                         `$D275
        .LEVEL_TOP		AS WORD                                         `$D277
        .LEVEL_BOTTOM		AS WORD                                         `$D279
        
        .CAMERA_X_GOTO		AS WORD	`a point to move the camera to          `$D27B
        .CAMERA_Y_GOTO		AS WORD                                         `$D27D
        
        .D27F                   AS BYTE `UNKNOWN ($D27F/80)                     `$D27F
        .D280                   AS BYTE `UNKNOWN ($D280/1)                      `$D280
        .D281                   AS BYTE `UNKNOWN ($D281/2)                      `$D281
        .D282                   AS BYTE `UNKNOWN ($D282/3)                      `$D282
        .D283                   AS BYTE `UNKNOWN                                `$D283
        .D284                   AS BYTE `UNKNOWN ($D284/5)                      `$D284
        .D285                   AS BYTE `UNKNOWN ($D285/6)                      `$D285
        .D286                   AS BYTE `UNKNOWN                                `$D286 
        .D287                   AS BYTE `UNKNOWN ($D287/8)                      `$D287
        .D288                   AS BYTE `UNKNOWN                                `$D288
        .D289                   AS BYTE `UNKNOWN                                `$D289
        .D28A                   AS BYTE `UNKNOWN                                `$D28A
        .D28B                   AS BYTE `UNKNOWN                                `$D28B
        .D28C                   AS BYTE `UNKNOWN                                `$D28C
        .D28D                   AS BYTE `UNKNOWN ($D28D/E)                      `$D28D
        .D28E                   AS BYTE `UNKNOWN                                `$D28E
        
        .SONIC_CURRENT_FRAME	AS WORD                                         `$D28F
        .SONIC_PREVIOUS_FRAME	AS WORD                                         `$D291
        
        .RING_CURRENT_FRAME	AS WORD                                         `$D293
        .RING_PREVIOUS_FRAME	AS WORD                                         `$D295
        
        .D297                   AS BYTE `UNKNOWN                                `$D297
        .D298                   AS BYTE `UNKNOWN ($D298/9)                      `$D298
        .D299                   AS WORD `UNKNOWN                                `$D299
        .D29B                   AS WORD `UNKNOWN                                `$D29B
        .D29D                   AS WORD `UNKNOWN                                `$D29D
        
        .TIME			AS WORD `the level's time                       `$D29F
        
        .D2A1                   AS BYTE `UNKNOWN ($D2A1/2)                      `$D2A1
        .D2A2                   AS BYTE `UNKNOWN ($D2A2/3)                      `$D2A2
        .D2A3                   AS BYTE `UNKNOWN                                `$D2A3
        
        .CYCLEPALETTE_COUNTER   AS BYTE	`counter for applying the speed         `$D2A4
        .CYCLEPALETTE_SPEED     AS BYTE `number of frames between each palette  `$D2A5
        
        .CYCLEPALETTE_INDEX	AS WORD `current palette in the cycle palette   `$D2A6
        .CYCLEPALETTE_POINTER	AS WORD `address where cycle palette begins     `$D2A8
        
        .RINGS			AS BYTE `player's ring count                    `$D2AA
        
        .D2AB                   AS WORD `UNKNOWN                                `$D2AB
        .D2AD                   AS WORD `UNKNOWN                                `$D2AD
        .D2AF                   AS WORD `UNKNOWN                                `$D2AF
        .D2B1                   AS WORD `UNKNOWN                                `$D2B1
        .D2B3                   AS BYTE `UNKNOWN                                `$D2B3
        
        .ACTIVESPRITECOUNT	AS BYTE `number of hardware sprites "in use"    `$D2B4
        
        .D2B5                   AS WORD `UNKNOWN                                `$D2B5
        .D2B7                   AS WORD `UNKNOWN                                `$D2B7
        .D2B9                   AS BYTE `UNKNOWN                                `$D2B9
        .D2BA                   AS WORD `UNKNOWN                                `$D2BA
        
        .D2BC                   AS BYTE                                         `UNUSED
        
        .D2BD                   AS BYTE `UNKNOWN ($D2BD/E)                      `$D2BD
        .D2BE                   AS BYTE `UNKNOWN ($D2BE/F)                      `$D2BE
        .D2BF                   AS WORD `UNKNOWN                                `$D2BF
        .D2C1                   AS BYTE `UNKNOWN                                `$D2C1
        .D2C2                   AS BYTE `probably part of above                 `UNUSED
        
        `UNKNOWN - probably text in RAM
        .D2C3                   AS BYTE x 11                                    `$D2C3
        .D2CE                   AS WORD `UNKNOWN                                `$D2CE
        .D2D0                   AS WORD `UNKNOWN                                `$D2D0
        
        ``the previous song played is checked during level load to avoid starting
          the same song again (for example, when teleporting in Scrap Brain)``
        .PREVIOUS_MUSIC		AS BYTE                                         `$D2D2
        
        .D2D3                   AS BYTE `UNKNOWN                                `$D2D3
        
        .LEVEL_SOLIDITY		AS BYTE                                         `$D2D4
        
        .D2D5                   AS WORD `UNKNOWN                                `$D2D5
        .D2D7                   AS WORD `UNKNOWN                                `$D2D7
        .D2D9                   AS WORD `UNKNOWN                                `$D2D9
        
        .WATERLINE		AS BYTE                                         `$D2DB
        
        .D2DC                   AS WORD `UNKNOWN                                `$D2DC
        .D2DE                   AS BYTE `UNKNOWN                                `$D2DE
        .D2DF                   AS BYTE `UNKNOWN                                `$D2DF
        .D2E0                   AS BYTE `UNKNOWN                                `$D2E0
        .D2E1                   AS BYTE `UNKNOWN                                `$D2E1
        .D2E2                   AS WORD `UNKNOWN                                `$D2E2
        .D2E4                   AS WORD `UNKNOWN                                `$D2E4
        .D2E6                   AS WORD `UNKNOWN                                `$D2E6
        .D2E8                   AS BYTE `UNKNOWN                                `$D2E8
        .D2E9                   AS WORD `UNKNOWN                                `$D2E9
        
        .D2EB                   AS BYTE                                         `UNUSED
        
        `...
}

`a copy of the level music index is kept so that the music can be started again (?)
 `after other sound events like invincibility
VAR $.LEVEL_MUSIC		$D2FC

VAR $.PALETTE		        $D3BC

`======================================================================================

INCLUDE "interrupts.oz80"

INCLUDE "main.oz80"

INCLUDE "screens\map.oz80"

INCLUDE "objects\objects.oz80"

`======================================================================================
`music code and song data

BANK 3 SLOT 1

INCLUDE "SOUND\sound_driver.asm"
INCLUDE "SOUND\music.asm"

`we might be able to set a background repeating text like this so that we don't have
 `to specify precise gap-filling like this
AT $7FB1 - $4000
DATA "Master System & Game Gear Version.  "
DATA "'1991 (C)Ancient. (BANK0-4)", $A2
DATA "SONIC THE HEDGE"

`======================================================================================
`block mappings

BANK 4

`[$10000]
:S1_BlockMappings

:S1_BlockMappings_GreenHill
INCLUDE BINARY "ROM.sms" START $10000 LENGTH 2944

:S1_BlockMappings_Bridge
INCLUDE BINARY "ROM.sms" START $10B80 LENGTH 2304

:S1_BlockMappings_Jungle
INCLUDE BINARY "ROM.sms" START $11480 LENGTH 2560

:S1_BlockMappings_Labyrinth
INCLUDE BINARY "ROM.sms" START $11E80 LENGTH 2816

:S1_BlockMappings_ScrapBrain
INCLUDE BINARY "ROM.sms" START $12980 LENGTH 3072

:S1_BlockMappings_SkyBaseExterior
`INCLUDE BINARY "ROM.sms" SKIP $13580 READ 3456
INCLUDE BINARY "ROM.sms" START $13580 LENGTH ($14000 - $13580)
BANK 5
AT $0000
INCLUDE BINARY "ROM.sms" START $14000 LENGTH 3456 - ($14000 - $13580)

:S1_BlockMappings_SkyBaseInterior
INCLUDE BINARY "ROM.sms" START $14300 LENGTH 1664

:S1_BlockMappings_SpecialStage
INCLUDE BINARY "ROM.sms" START $14980 LENGTH 2048

`======================================================================================
`"blinking items"
`(need to properly break these down)

`[$15180]
INCLUDE BINARY "ROM.sms" START $15180 LENGTH 1024

`======================================================================================
`level headers:

BANK 5

`[$15580]
:S1_LevelHeader_Pointers

`[$155CA]
AT $155CA - $14000
